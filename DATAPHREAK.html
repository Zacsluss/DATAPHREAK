<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>DATAPHREAK - AI-Powered Data Analysis Tool</title>
  
  <!-- SEO Meta Tags -->
  <meta name="description" content="Professional offline data analysis tool with AI pattern detection, fuzzy duplicate matching, and comprehensive data quality scoring. No installation required.">
  <meta name="keywords" content="data analysis,CSV,Excel,offline,data cleaning,AI,analytics,duplicate detection,data quality,business intelligence">
  <meta name="author" content="DATAPHREAK">
  
  <!-- Open Graph for Social Sharing -->
  <meta property="og:title" content="DATAPHREAK - AI-Powered Data Analysis Tool">
  <meta property="og:description" content="Professional data analysis tool with AI pattern detection, fuzzy matching, and comprehensive reporting - works completely offline">
  <meta property="og:type" content="website">
  <meta property="og:url" content="https://zacsluss.github.io/DATAPHREAK/DATAPHREAK.html">
  
  <!-- Twitter Card -->
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:title" content="DATAPHREAK - Data Analysis Tool">
  <meta name="twitter:description" content="Professional offline data analysis with AI pattern detection and comprehensive quality scoring">
  
  <!-- Performance Resource Hints -->
  <link rel="dns-prefetch" href="//cdn.sheetjs.com">
  <link rel="preload" href="https://cdn.sheetjs.com/xlsx-0.20.3/package/dist/xlsx.full.min.js" as="script" crossorigin>
  
    <!-- Custom DATAPHREAK Icon - Data Analytics Theme -->
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzIiIGhlaWdodD0iMzIiIHZpZXdCb3g9IjAgMCAzMiAzMiIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICA8cmVjdCB3aWR0aD0iMzIiIGhlaWdodD0iMzIiIHJ4PSI0IiBmaWxsPSIjMjIyMjIyIi8+CiAgPCEtLSBEYXRhIEJhcnMgLS0+CiAgPHJlY3QgeD0iNCIgeT0iMjAiIHdpZHRoPSIzIiBoZWlnaHQ9IjgiIGZpbGw9IiMyMmM1NWUiLz4KICA8cmVjdCB4PSI5IiB5PSIxNiIgd2lkdGg9IjMiIGhlaWdodD0iMTIiIGZpbGw9IiMyMmM1NWUiLz4KICA8cmVjdCB4PSIxNCIgeT0iMTIiIHdpZHRoPSIzIiBoZWlnaHQ9IjE2IiBmaWxsPSIjMzhiZGY4Ii8+CiAgPHJlY3QgeD0iMTkiIHk9IjgiIHdpZHRoPSIzIiBoZWlnaHQ9IjIwIiBmaWxsPSIjMzhiZGY4Ii8+CiAgPHJlY3QgeD0iMjQiIHk9IjE0IiB3aWR0aD0iMyIgaGVpZ2h0PSIxNCIgZmlsbD0iI2Y1OWUwYiIvPgogIDwhLS0gRGF0YSBQb2ludHMgLS0+CiAgPGNpcmNsZSBjeD0iNS41IiByPSIxLjUiIGZpbGw9IiNlZjQ0NDQiLz4KICA8Y2lyY2xlIGN4PSIxMC41IiBjeT0iNCIgcj0iMS41IiBmaWxsPSIjZWY0NDQ0Ii8+CiAgPGNpcmNsZSBjeD0iMTUuNSIgY3k9IjYiIHI9IjEuNSIgZmlsbD0iI2VmNDQ0NCIvPgogIDxjaXJjbGUgY3g9IjIwLjUiIGN5PSIzIiByPSIxLjUiIGZpbGw9IiNlZjQ0NDQiLz4KICA8Y2lyY2xlIGN4PSIyNS41IiBjeT0iOCIgcj0iMS41IiBmaWxsPSIjZWY0NDQ0Ii8+Cjwvc3ZnPgo=">
    <!-- Fallback PNG favicon for older browsers -->
    <link rel="icon" type="image/png" sizes="32x32" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAAdgAAAHYBTnsmCAAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAKBSURBVFiFtZc9aBRBFMd/s5vdJBcSCysrwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLwcJCG1sLWZpbGw9IjM4YmRmOCIgcj0iMTMiLz4KPC9zdmc+Cg==">
    <!--
      Content Security Policy (CSP)
      -----------------------------
      Allow loading resources only from this document's origin and data URIs. To ensure the app's
      inline JavaScript executes, 'unsafe-inline' is permitted for scripts. Styles may still
      include inline definitions. Remote sources are disallowed to help protect against
      cross‑site scripting (XSS) or injection attacks.
    -->
    <meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' 'unsafe-inline' https://cdn.sheetjs.com; style-src 'self' 'unsafe-inline'; img-src 'self' data:; font-src 'self'; connect-src 'self';">
  <!--
    DATAPHREAK v0.8.0: AI-powered single‑file data analysis tool for CSV/TSV/Excel files. 
    Features include: AI pattern detection (emails, phones, dates), fuzzy duplicate matching,
    comprehensive data quality scoring with A-F grades, smart data cleaning with auto-corrections,
    and professional reporting. Works completely offline with no installations required.
    Analysis remains responsive for large datasets with enterprise-grade performance.
  -->
  <style>
    /*
      Theme variables are defined on the root element. By default the
      application loads in a “dark” theme. Switching the theme adds
      the `theme-light` class to the <body>, which overrides these
      variables with a cream‑coloured palette. All colours within the
      UI reference these variables, so adding new themes only requires
      defining a new set of values here.
    */
    :root {
      /* Gradient start/end define the overall page backdrop. */
      /* Use a single colour for the page backdrop to avoid a visible
         gradient banding effect.  The start and end values are the same,
         which means the linear gradient resolves to a flat fill. */
      --bg-start: #2a2a2a;      /* dark theme: medium gray for optimal viewing */
      --bg-end:   #2a2a2a;      /* dark theme: use the same value as start */
      /* Panel colours for headers, navs and cards. */
      /* Overall panel colour: lighten the base card background for a cleaner look */
      --panel:    #333333;
      /* Text colours */
      --text:     #f7f7f7;
      --muted:    #cccccc;
      /* Accent colours */
      --accent:   #22c55e;
      --accent2:  #38bdf8;
      --warn:     #f59e0b;
      --err:      #ef4444;
      --ok:       #10b981;
      /* Utility colours */
      --chip:     #3a3a3a;
      --border:   #4a4a4a;
      /* Card and table backgrounds: slightly lighter for improved polish */
      --card-bg:      rgba(255,255,255,0.08);

      /* Typography: use most readable system font for all text except title */
      --font-main: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
      /* Logo colour uses the primary accent by default */
      --logo-color: var(--accent);
      --table-row-bg: rgba(255,255,255,0.04);
      /* Alternate stripe and hover backgrounds for table rows. Increase contrast slightly */
      --table-row-alt-bg: rgba(255,255,255,0.06);
      --table-row-hover-bg: rgba(255,255,255,0.1);
      /* Input backgrounds */
      --input-bg:     rgba(255,255,255,0.06);
      /* Button gradient */
      --button-bg-start: rgba(255,255,255,0.12);
      --button-bg-end:   rgba(255,255,255,0.06);
      /* Nav hover background */
      --nav-hover-bg: rgba(255,255,255,0.1);
    }

    /* Light theme overrides: cream palette with dark text. The
       .theme-light class is applied to the body when toggled. */
    body.theme-light {
      /* Flatten the light theme backdrop: use the same colour for both
         start and end stops of the gradient to eliminate banding. */
      --bg-start: #f9f5ee;
      --bg-end:   #f9f5ee;
      /* Lighten panels and borders further for a softer cream appearance */
      --panel:    #f8f6f1;
      --text:     #333333;
      --muted:    #555555;
      --chip:     #ece6dd;
      --border:   #b8860b;
      --card-bg:      rgba(0,0,0,0.025);
      --table-row-bg: rgba(0,0,0,0.02);
      /* Light theme alternate row shading slightly darker for improved contrast */
      --table-row-alt-bg: rgba(0,0,0,0.025);
      --table-row-hover-bg: rgba(0,0,0,0.07);
      --input-bg:     rgba(0,0,0,0.05);
      --button-bg-start: rgba(255,255,255,0.92);
      --button-bg-end:   rgba(255,255,255,0.75);
      --nav-hover-bg: rgba(0,0,0,0.1);
    }

    /* =====================================================================
       LIGHT MODE ENHANCEMENTS - MATCH MATRIX/DARK LEVEL OF DETAIL
       ===================================================================== */
    
    /* Light Mode Golden Accent Glows */
    body.theme-light .card {
      box-shadow: 0 10px 30px rgba(0,0,0,.08), inset 0 1px 0 rgba(255,255,255,.8), 0 0 20px rgba(218,165,32,0.05);
      border: 1px solid var(--border);
      transition: all 0.3s ease;
    }
    
    body.theme-light .card:hover {
      transform: translateY(-4px);
      box-shadow: 0 20px 40px rgba(0,0,0,0.15), inset 0 1px 0 rgba(184,134,11,0.3), 0 0 30px rgba(184,134,11,0.4);
      border-color: #b8860b;
    }
    
    /* Light Mode Button 3D Press Effects */
    body.theme-light button {
      box-shadow: 0 4px 8px rgba(0,0,0,0.1), inset 0 1px 0 rgba(184,134,11,0.2);
      transition: all 0.2s ease;
      text-shadow: 0 0 2px rgba(184,134,11,0.4);
      border: 1px solid #b8860b;
      background: linear-gradient(180deg, rgba(218,165,32,0.08), rgba(184,134,11,0.06));
    }
    
    body.theme-light button:hover {
      transform: translateY(-2px);
      box-shadow: 0 8px 16px rgba(0,0,0,0.2), inset 0 1px 0 rgba(184,134,11,0.4), 0 0 15px rgba(184,134,11,0.5);
      text-shadow: 0 0 4px rgba(184,134,11,0.8);
      border-color: #b8860b;
    }
    
    /* Light Mode Navigation Button Consistency - Match Tile Boundaries */
    body.theme-light nav#topNav button {
      border: 1px solid #b8860b !important;
      text-shadow: 0 0 2px rgba(184,134,11,0.6) !important;
      background: linear-gradient(135deg, rgba(218,165,32,0.6), rgba(255,193,7,0.2)) !important;
      color: #333333 !important;
    }
    
    body.theme-light nav#topNav button:hover {
      border-color: #b8860b !important;
      text-shadow: 0 0 4px rgba(184,134,11,0.8) !important;
      box-shadow: 0 0 8px rgba(184,134,11,0.3) !important;
      background: linear-gradient(135deg, rgba(218,165,32,0.7), rgba(255,193,7,0.3)) !important;
    }
    
    /* Light Mode Navigation Actions Container */
    body.theme-light .nav-actions button {
      border: 1px solid #b8860b !important;
      text-shadow: 0 0 2px rgba(184,134,11,0.6) !important;
      background: linear-gradient(135deg, rgba(218,165,32,0.6), rgba(255,193,7,0.2)) !important;
      color: #333333 !important;
    }
    
    body.theme-light .nav-actions button:hover {
      border-color: #b8860b !important;
      text-shadow: 0 0 4px rgba(184,134,11,0.8) !important;
      box-shadow: 0 0 8px rgba(184,134,11,0.3) !important;
      background: linear-gradient(135deg, rgba(218,165,32,0.7), rgba(255,193,7,0.3)) !important;
    }
    
    body.theme-light button:active {
      transform: translateY(1px);
      box-shadow: 0 2px 4px rgba(0,0,0,0.2), inset 0 -1px 0 rgba(0,0,0,0.1);
    }
    
    /* Light Mode Input Focus Rings */
    body.theme-light input:focus, 
    body.theme-light select:focus, 
    body.theme-light textarea:focus {
      box-shadow: 0 0 0 2px rgba(218,165,32,0.6), 0 0 20px rgba(218,165,32,0.2);
      border-color: rgba(218,165,32,0.8);
      text-shadow: 0 0 3px rgba(218,165,32,0.6);
    }
    
    /* Light Mode Background Glow Animation */
    body.theme-light::before {
      content: '';
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      pointer-events: none;
      z-index: -2;
      background: linear-gradient(180deg, transparent 0%, rgba(218,165,32,0.015) 50%, transparent 100%);
      animation: lightGlow 6s ease-in-out infinite alternate;
    }
    
    @keyframes lightGlow {
      0% { opacity: 0.2; }
      100% { opacity: 0.5; }
    }
    
    /* Light Mode Header Pulse Animation */
    body.theme-light header {
      animation: lightHeaderPulse 8s ease-in-out infinite;
      background: linear-gradient(180deg, rgba(248,246,241,0.95), rgba(249,245,238,0.98));
    }
    
    @keyframes lightHeaderPulse {
      0%, 100% { box-shadow: 0 2px 15px rgba(218,165,32,0.05); }
      50% { box-shadow: 0 2px 25px rgba(218,165,32,0.1); }
    }
    
    /* Light Mode Enhanced Loading Animation */
    body.theme-light .loading::after {
      border-top: 2px solid rgba(218,165,32,0.8);
      box-shadow: 0 0 8px rgba(218,165,32,0.15);
    }
    
    /* Light Mode Table Effects */
    body.theme-light table {
      backdrop-filter: blur(1px);
    }
    
    body.theme-light tbody tr:hover td {
      background: rgba(218,165,32,0.1);
      text-shadow: 0 0 2px #b8860b;
    }
    
    /* Light Mode Toast Notifications */
    body.theme-light #toast > div {
      background: rgba(249,245,238,0.95) !important;
      border: 2px solid #b8860b !important;
      box-shadow: 0 0 15px rgba(218,165,32,0.15) !important;
      text-shadow: 0 0 3px rgba(218,165,32,0.3) !important;
    }
    
    /* Light Mode Body Background Override (allow particles to show) */
    body.theme-light {
      background: transparent !important;
    }
    
    /* Light Mode Content Area Masking (match Matrix solid approach) */
    body.theme-light .container {
      background: var(--bg-start);
      border-radius: 0;
      position: relative;
      z-index: 0;
    }
    
    /* Light Mode Floating Sparkles */
    body.theme-light {
      position: relative;
      overflow-x: hidden;
    }
    
    body.theme-light .light-sparkle {
      position: fixed;
      width: 6px;
      height: 6px;
      background: radial-gradient(circle, rgba(218,165,32,1) 0%, rgba(218,165,32,1) 50%, rgba(218,165,32,0.8) 80%, transparent 100%);
      border-radius: 50%;
      pointer-events: none;
      z-index: -1;
      box-shadow: 0 0 12px rgba(218,165,32,1), 0 0 24px rgba(218,165,32,0.8), 0 0 36px rgba(218,165,32,0.4);
      animation: sparkleFloat linear infinite;
    }
    
    
    @keyframes sparkleFloat {
      0% {
        transform: translateY(100vh) rotate(0deg);
        opacity: 0;
      }
      10% {
        opacity: 1;
      }
      90% {
        opacity: 1;
      }
      100% {
        transform: translateY(-20px) rotate(360deg);
        opacity: 0;
      }
    }
    
    /* Light Mode Enhanced Border and Separator Visibility */
    body.theme-light nav#topNav {
      border-top: 1px solid #b8860b;
    }
    
    body.theme-light header {
      border-bottom: 1px solid #b8860b;
    }
    
    body.theme-light .card {
      border: 1px solid #b8860b;
    }
    
    body.theme-light table thead th {
      border-bottom: 2px solid #b8860b;
    }
    
    body.theme-light tbody td {
      border-top: 1px solid rgba(184,134,11,0.3);
      border-bottom: 1px solid rgba(184,134,11,0.3);
    }
    
    body.theme-light tbody tr td:first-child { 
      border-left: 1px solid rgba(184,134,11,0.3); 
    }
    
    body.theme-light tbody tr td:last-child  { 
      border-right: 1px solid rgba(184,134,11,0.3); 
    }
    
    body.theme-light .section-header {
      border-bottom: 1px solid rgba(184,134,11,0.4);
    }
    
    body.theme-light .modal-content {
      border: 2px solid #b8860b;
    }
    
    
    /* Light Mode Text Color Override - ALL TEXT MUST BE BLACK */
    body.theme-light,
    body.theme-light * {
      color: #333333 !important;
    }
    
    /* Light Mode Button Text Override */
    body.theme-light button,
    body.theme-light button * {
      color: #333333 !important;
    }
    
    /* Light Mode Input Text Override */
    body.theme-light input,
    body.theme-light select,
    body.theme-light textarea,
    body.theme-light option {
      color: #333333 !important;
    }
    
    /* Light Mode Specific Element Text Override */
    body.theme-light .quick-action,
    body.theme-light .primary-btn,
    body.theme-light .btn-primary,
    body.theme-light .quick-btn {
      color: #333333 !important;
    }
    
    /* Light Mode ALL Button Border Override - Comprehensive */
    body.theme-light button,
    body.theme-light .card button,
    body.theme-light .card-header button,
    body.theme-light .field-btn,
    body.theme-light .secondary-btn,
    body.theme-light .icon-btn,
    body.theme-light .header-select {
      border: 1px solid #b8860b !important;
    }
    
    /* Light Mode ALL Button Hover Override */
    body.theme-light button:hover,
    body.theme-light .card button:hover,
    body.theme-light .card-header button:hover,
    body.theme-light .field-btn:hover,
    body.theme-light .secondary-btn:hover,
    body.theme-light .icon-btn:hover {
      border-color: #b8860b !important;
      box-shadow: 0 0 8px rgba(184,134,11,0.3) !important;
    }
    
    /* Light Mode Accent Gradient Buttons - Soft Translucent (10% lighter) */
    body.theme-light .quick-action {
      background: linear-gradient(135deg, rgba(218,165,32,0.7), rgba(255,193,7,0.3)) !important;
      color: #333333 !important;
    }
    
    body.theme-light .primary-btn {
      background: linear-gradient(135deg, rgba(218,165,32,0.7), rgba(255,193,7,0.3)) !important;
      color: #333333 !important;
    }
    
    body.theme-light .btn-primary {
      background: linear-gradient(135deg, rgba(218,165,32,0.7), rgba(255,193,7,0.3)) !important;
      color: #333333 !important;
    }
    
    body.theme-light .quick-btn {
      background: linear-gradient(135deg, rgba(218,165,32,0.7), rgba(255,193,7,0.3)) !important;
      color: #333333 !important;
    }
    
    /* Light Mode Missing Tile Buttons */
    body.theme-light .field-btn {
      background: linear-gradient(135deg, rgba(218,165,32,0.7), rgba(255,193,7,0.3)) !important;
      color: #333333 !important;
    }
    
    body.theme-light .secondary-btn {
      background: linear-gradient(135deg, rgba(218,165,32,0.7), rgba(255,193,7,0.3)) !important;
      color: #333333 !important;
    }
    
    body.theme-light .sample-btn {
      background: linear-gradient(135deg, rgba(218,165,32,0.6), rgba(255,193,7,0.2)) !important;
      color: #333333 !important;
    }
    
    /* Light Mode Missing Export and View Buttons */
    body.theme-light #exportExactDupCsv {
      background: linear-gradient(135deg, rgba(218,165,32,0.7), rgba(255,193,7,0.3)) !important;
      color: #333333 !important;
    }
    
    body.theme-light #exportFuzzyCrossCsv {
      background: linear-gradient(135deg, rgba(218,165,32,0.7), rgba(255,193,7,0.3)) !important;
      color: #333333 !important;
    }
    
    body.theme-light .view-mode {
      background: linear-gradient(135deg, rgba(218,165,32,0.6), rgba(255,193,7,0.2)) !important;
      color: #333333 !important;
    }
    
    body.theme-light .view-mode.active {
      background: linear-gradient(135deg, rgba(218,165,32,0.9), rgba(255,193,7,0.7)) !important;
      color: #333333 !important;
      border-color: rgba(218,165,32,0.8) !important;
      box-shadow: 0 0 16px rgba(218,165,32,0.8), 0 0 8px rgba(255,193,7,0.6) !important;
      text-shadow: 0 0 6px rgba(218,165,32,0.9) !important;
    }

    /* Light Mode Icon Buttons (UNDO/REDO) */
    body.theme-light .icon-btn {
      background: linear-gradient(135deg, rgba(218,165,32,0.7), rgba(255,193,7,0.3)) !important;
      color: #333333 !important;
      text-shadow: 0 0 2px rgba(184,134,11,0.6) !important;
    }

    body.theme-light .icon-btn:hover:not(:disabled) {
      background: linear-gradient(135deg, rgba(218,165,32,0.8), rgba(255,193,7,0.4)) !important;
      text-shadow: 0 0 4px rgba(184,134,11,0.8) !important;
      box-shadow: 0 0 8px rgba(184,134,11,0.3) !important;
    }

    /* Matrix theme overrides: black/green palette inspired by the Matrix.
       Apply via the .theme-matrix class on the body. */
    body.theme-matrix {
      /* Flatten the high‑tech theme backdrop: use the same colour for both
         gradient stops so the background is uniform. */
      --bg-start: #03140a;
      --bg-end:   #03140a;
      --panel:    #042612;
      --text:     #00ff99;
      --muted:    #00cc77;
      --chip:     #05351c;
      --border:   #075e33;
      --card-bg:      rgba(0,64,32,0.4);
      --table-row-bg: rgba(0,64,32,0.5);
      /* High-tech theme alternate row shading: adjust to improve contrast */
      --table-row-alt-bg: rgba(0,64,32,0.4);
      --table-row-hover-bg: rgba(0,128,64,0.5);
      --input-bg:     rgba(0,48,24,0.5);
      --button-bg-start: rgba(0,128,64,0.6);
      --button-bg-end:   rgba(0,64,32,0.4);
      --nav-hover-bg: rgba(0,128,64,0.2);
      /* Use the global monospace stack defined in --font-main for the matrix theme. */
      /* Inherit the font from the root so all themes share the same futuristic typeface. */
    }
    
    /* Matrix Mode Animations and Effects */
    body.theme-matrix {
      position: relative;
      overflow-x: hidden;
    }
    
    /* Matrix digital rain effect overlay */
    body.theme-matrix::before {
      content: '';
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      pointer-events: none;
      z-index: -1;
      background: linear-gradient(180deg, transparent 0%, rgba(0,255,153,0.02) 50%, transparent 100%);
      animation: matrixGlow 4s ease-in-out infinite alternate;
    }
    
    @keyframes matrixGlow {
      0% { opacity: 0.3; }
      100% { opacity: 0.7; }
    }
    
    /* Matrix text effects */
    body.theme-matrix .card {
      box-shadow: 0 0 20px rgba(0,255,153,0.1), inset 0 1px 0 rgba(0,255,153,0.05);
      border: 1px solid rgba(0,255,153,0.15);
      backdrop-filter: blur(1px);
    }
    
    body.theme-matrix .card:hover {
      box-shadow: 0 0 30px rgba(0,255,153,0.4), inset 0 1px 0 rgba(0,255,153,0.2);
      transform: translateY(-2px);
    }
    
    /* Matrix button effects */
    body.theme-matrix button {
      text-shadow: 0 0 5px rgba(0,255,153,0.5);
      border: 1px solid rgba(0,255,153,0.4);
      background: linear-gradient(180deg, rgba(0,128,64,0.6), rgba(0,64,32,0.4));
      transition: all 0.3s ease;
    }
    
    body.theme-matrix button:hover {
      box-shadow: 0 0 15px rgba(0,255,153,0.6);
      text-shadow: 0 0 10px rgba(0,255,153,0.8);
      transform: translateY(-1px);
    }
    
    body.theme-matrix button:active {
      transform: translateY(1px);
      box-shadow: 0 2px 4px rgba(0,0,0,0.3), inset 0 -1px 0 rgba(0,0,0,0.2);
      background: linear-gradient(180deg, rgba(0,64,32,0.8), rgba(0,128,64,0.6));
    }
    
    /* Matrix table effects */
    body.theme-matrix table {
      backdrop-filter: blur(2px);
    }
    
    body.theme-matrix tbody tr:hover td {
      background: rgba(0,128,64,0.7);
      text-shadow: 0 0 3px rgba(0,255,153,0.8);
    }
    
    /* Matrix input glow */
    body.theme-matrix input:focus, 
    body.theme-matrix select:focus, 
    body.theme-matrix textarea:focus {
      box-shadow: 0 0 0 2px rgba(0,255,153,0.8), 0 0 10px rgba(0,255,153,0.3);
      text-shadow: 0 0 3px rgba(0,255,153,0.6);
    }
    
    /* Matrix header pulse effect */
    body.theme-matrix header {
      box-shadow: 0 2px 20px rgba(0,255,153,0.15);
      background: linear-gradient(180deg, rgba(4,38,18,0.95), rgba(3,20,10,0.98));
      animation: matrixHeaderPulse 6s ease-in-out infinite;
    }
    
    @keyframes matrixHeaderPulse {
      0%, 100% { box-shadow: 0 2px 20px rgba(0,255,153,0.15); }
      50% { box-shadow: 0 2px 30px rgba(0,255,153,0.25); }
    }
    
    /* Matrix loading animation */
    body.theme-matrix .loading::after {
      border-top: 2px solid rgba(0,255,153,0.8);
      box-shadow: 0 0 10px rgba(0,255,153,0.25);
    }
    
    /* Matrix toast notifications */
    body.theme-matrix #toast > div {
      background: rgba(4,38,18,0.95) !important;
      border: 1px solid rgba(0,255,153,0.25) !important;
      box-shadow: 0 0 15px rgba(0,255,153,0.15) !important;
      text-shadow: 0 0 5px rgba(0,255,153,0.3) !important;
    }
    
    /* Matrix Mode Content Area Masking */
    body.theme-matrix .container {
      background: var(--bg-start);
      border-radius: 0;
      position: relative;
      z-index: 0;
    }
    
    /* =====================================================================
       DARK MODE ENHANCEMENTS - MATCH MATRIX LEVEL OF DETAIL
       ===================================================================== */
    
    
    /* Dark Mode Purple Accent Glows */
    body:not(.theme-light):not(.theme-matrix) .card {
      box-shadow: 0 10px 30px rgba(0,0,0,.15), inset 0 1px 0 rgba(255,255,255,.04), 0 0 20px rgba(147,51,234,0.05);
      border: 1px solid var(--border);
      transition: all 0.3s ease;
      backdrop-filter: blur(1px);
    }
    
    body:not(.theme-light):not(.theme-matrix) .card:hover {
      transform: translateY(-4px);
      box-shadow: 0 20px 40px rgba(0,0,0,0.25), inset 0 1px 0 rgba(255,255,255,.04), 0 0 30px rgba(147,51,234,0.2);
      border-color: rgba(147,51,234,0.3);
    }
    
    /* Dark Mode Button 3D Press Effects */
    body:not(.theme-light):not(.theme-matrix) button {
      box-shadow: 0 4px 8px rgba(0,0,0,0.2), inset 0 1px 0 rgba(255,255,255,0.1);
      transition: all 0.2s ease;
      text-shadow: 0 0 2px rgba(147,51,234,0.3);
      border: 1px solid rgba(147,51,234,0.2);
      background: linear-gradient(180deg, rgba(147,51,234,0.1), rgba(75,25,117,0.08));
    }
    
    body:not(.theme-light):not(.theme-matrix) button:hover {
      transform: translateY(-2px);
      box-shadow: 0 8px 16px rgba(0,0,0,0.3), inset 0 1px 0 rgba(255,255,255,0.15), 0 0 15px rgba(147,51,234,0.3);
      text-shadow: 0 0 4px rgba(147,51,234,0.6);
    }
    
    body:not(.theme-light):not(.theme-matrix) button:active {
      transform: translateY(1px);
      box-shadow: 0 2px 4px rgba(0,0,0,0.3), inset 0 -1px 0 rgba(0,0,0,0.2);
      background: linear-gradient(180deg, rgba(75,25,117,0.15), rgba(147,51,234,0.1));
    }
    
    /* Dark Mode Input Focus Rings */
    body:not(.theme-light):not(.theme-matrix) input:focus, 
    body:not(.theme-light):not(.theme-matrix) select:focus, 
    body:not(.theme-light):not(.theme-matrix) textarea:focus {
      box-shadow: 0 0 0 2px rgba(147,51,234,0.6), 0 0 20px rgba(147,51,234,0.2);
      border-color: rgba(147,51,234,0.8);
      text-shadow: 0 0 3px rgba(147,51,234,0.6);
    }
    
    /* Dark Mode Background Glow Animation */
    body:not(.theme-light):not(.theme-matrix)::before {
      content: '';
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      pointer-events: none;
      z-index: -2;
      background: linear-gradient(180deg, transparent 0%, rgba(147,51,234,0.015) 50%, transparent 100%);
      animation: darkGlow 6s ease-in-out infinite alternate;
    }
    
    /* Dark Mode Content Area Masking */
    body:not(.theme-light):not(.theme-matrix) .container {
      background: var(--bg-start);
      border-radius: 0;
      position: relative;
      z-index: 0;
    }
    
    @keyframes darkGlow {
      0% { opacity: 0.2; }
      100% { opacity: 0.5; }
    }
    
    /* Dark Mode Header Pulse Animation */
    body:not(.theme-light):not(.theme-matrix) header {
      animation: darkHeaderPulse 8s ease-in-out infinite;
      background: linear-gradient(180deg, rgba(51,51,51,0.95), rgba(42,42,42,0.98));
    }
    
    @keyframes darkHeaderPulse {
      0%, 100% { box-shadow: 0 2px 15px rgba(147,51,234,0.05); }
      50% { box-shadow: 0 2px 25px rgba(147,51,234,0.1); }
    }
    
    /* Dark Mode Enhanced Loading Animation */
    body:not(.theme-light):not(.theme-matrix) .loading::after {
      border-top: 2px solid rgba(147,51,234,0.8);
      box-shadow: 0 0 8px rgba(147,51,234,0.15);
    }
    
    /* Dark Mode Table Effects */
    body:not(.theme-light):not(.theme-matrix) table {
      backdrop-filter: blur(1px);
    }
    
    body:not(.theme-light):not(.theme-matrix) tbody tr:hover td {
      text-shadow: 0 0 2px rgba(147,51,234,0.4);
    }
    
    /* Dark Mode Toast Notifications */
    body:not(.theme-light):not(.theme-matrix) #toast > div {
      background: rgba(42,42,42,0.95) !important;
      border: 1px solid rgba(147,51,234,0.25) !important;
      box-shadow: 0 0 15px rgba(147,51,234,0.15) !important;
      text-shadow: 0 0 3px rgba(147,51,234,0.3) !important;
    }
    
    /* Dark Mode Enhanced View Mode Active State */
    body:not(.theme-light):not(.theme-matrix) .view-mode.active {
      background: linear-gradient(135deg, rgba(147,51,234,0.9), rgba(75,25,117,0.8)) !important;
      color: #ffffff !important;
      border-color: rgba(147,51,234,0.8) !important;
      box-shadow: 0 0 12px rgba(147,51,234,0.6) !important;
      text-shadow: 0 0 4px rgba(147,51,234,0.8) !important;
    }
    
    /* Dark Mode Cosmic Dust Particles */
    body:not(.theme-light):not(.theme-matrix) {
      position: relative;
      overflow-x: hidden;
    }
    
    body:not(.theme-light):not(.theme-matrix) .cosmic-dust {
      position: fixed;
      width: 4.5px;
      height: 4.5px;
      background: radial-gradient(circle, rgba(147,51,234,1) 0%, rgba(147,51,234,1) 50%, rgba(147,51,234,0.9) 80%, transparent 100%);
      border-radius: 50%;
      pointer-events: none;
      z-index: -1;
      box-shadow: 0 0 9px rgba(147,51,234,1), 0 0 18px rgba(147,51,234,0.8), 0 0 27px rgba(147,51,234,0.4);
      animation: cosmicFall linear infinite;
    }
    
    @keyframes cosmicFall {
      0% {
        transform: translateY(-20px);
        opacity: 0;
      }
      10% {
        opacity: 1;
      }
      90% {
        opacity: 1;
      }
      100% {
        transform: translateY(100vh);
        opacity: 0;
      }
    }
    
    
    
    
    
    
    
    /* Matrix digital rain particles */
    body.theme-matrix .matrix-particle {
      position: fixed;
      color: rgba(0,255,153,0.8);
      font-family: 'Courier New', monospace;
      font-size: 14px;
      pointer-events: none;
      z-index: -1;
      text-shadow: 0 0 5px rgba(0,255,153,0.6);
      font-weight: bold;
      animation: matrixFall linear infinite;
    }
    
    @keyframes matrixFall {
      0% {
        transform: translateY(-20px);
        opacity: 0;
      }
      10% {
        opacity: 1;
      }
      90% {
        opacity: 1;
      }
      100% {
        transform: translateY(100vh);
        opacity: 0;
      }
    }
    * { box-sizing: border-box; }
    html, body { height: 100%; margin: 0; }
    body {
      /* Use gradient variables for the page backdrop. The colours are
         defined in theme variables and change when the theme toggles. */
      background: linear-gradient(180deg,var(--bg-start) 0%,var(--bg-end) 100%);
      color: var(--text);
      font-family: var(--font-main);
      font-size: 14px;
      line-height: 1.45;
    }
    
    /* Apply readable font to all elements except title */
    *, *::before, *::after {
      font-family: inherit;
    }
    
    /* Override any custom fonts with the most readable system font */
    button, input, select, textarea, label, span, div, p, a, td, th, li, small, code,
    .card, .section-title, .section-subtitle, .kpi-label, .kpi-value, .quick-action-text,
    .control-label, .view-mode, .legend-item, .result-summary, .breakdown-item,
    .stat-label, .stat-value, .info-label, .info-value, .op-text, .ops-label,
    .modal-content, .help-body, .nav-actions {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif !important;
    }
    
    /* Keep title font special */
    h1 {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif !important;
    }
    /* Header and nav */
    header {
      position: sticky;
      top: 0;
      z-index: 100;
      /* Use panel colour for header background; remains consistent across themes */
      background: var(--panel);
      border-bottom: 1px solid var(--border);
    }
    .header-inner {
      /* Use a three‑column grid so the title sits in the centre and
         contextual items can flow to the left and right. */
      display: grid;
      grid-template-columns: 1fr auto 1fr;
      align-items: center;
      gap: 16px;
      padding: 16px 20px;
      width: 100%;
    }

    /* Left and right areas hold pills and badges. Use flex to keep
       items aligned on a single line. */
    .header-left,
    .header-right {
      display: flex;
      align-items: center;
      gap: 12px;
    }
    /* Push right‑hand items to the far edge */
    .header-right {
      justify-content: flex-end;
    }
    header h1 {
      margin: 0;
      font-size: 25px;
      letter-spacing: .2px;
    }

/* Logo styling: align icon with text and set colour via theme variable */
.logo {
  display: inline-flex;
  align-items: center;
  margin-right: 6px;
}
.logo svg {
  width: 18px;
  height: 18px;
  fill: var(--logo-color);
  margin-right: 4px;
}
    .version {
      font-size: 14px;
      font-weight: normal;
      color: var(--muted);
      margin-left: 8px;
    }
    .pill {
      background: var(--chip);
      border: 1px solid var(--border);
      padding: 6px 10px;
      border-radius: 999px;
      color: var(--muted);
      font-size: 13px;
    }
    nav#topNav {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      justify-content: center;
      gap: 12px;
      padding: 8px 20px;
      border-top: 1px solid var(--border);
      background: var(--panel);
    }

    /* Ensure Salesforce ID select and its options have legible text on light background
       The modal appears over the dark-themed app, so we explicitly set the select
       element and its option elements to use black text and a white background. */
    /* Force the Salesforce ID select and its options to always display black text
       and a white background. The !important flag ensures these styles override
       any conflicting styles applied elsewhere or by the browser default. */
    #sfColumnSelect {
      color: #000 !important;
      background-color: #fff !important;
    }
    #sfColumnSelect option {
      color: #000 !important;
      background-color: #fff !important;
    }


    /* Merge modal selects also need clear contrast; force black text on white background */
    #mergePrimaryCol, #mergePrimaryCol option,
    #mergeSecondaryCol, #mergeSecondaryCol option,
    #mergeJoinType, #mergeJoinType option {
      color: #000 !important;
      background-color: #fff !important;
    }

    /* Settings modal selects: ensure the drop‑down options are legible.  The
       settings dialog appears on top of the dark application theme, so
       force the select elements and their options to use black text and
       white backgrounds for maximum contrast. */
    #settingsModal select,
    #settingsModal select option {
      color: #000 !important;
      background-color: #fff !important;
    }

    /* Dataset switcher select: always use black text on a white background for clarity */
    #datasetSwitch,
    #datasetSwitch option {
      color: #000 !important;
      background-color: #fff !important;
      /* Provide basic styling similar to other inputs */
      border: 1px solid var(--border) !important;
      border-radius: 4px !important;
      padding: 3px 4px !important;
      min-width: 60px;
    }

    /* Data Operations column selector: ensure options remain legible regardless of theme */
    #opColumns {
      color: #000 !important;
      background-color: #fff !important;
    }
    #opColumns option {
      color: #000 !important;
      background-color: #fff !important;
    }
    .nav-actions {
      display: flex;
      flex-wrap: wrap;
      gap: 4px;
      /* Left‑align nav actions within the navigation bar. */
      justify-content: flex-start;
    }

    /* Give each card a maximum height and allow scrolling inside. This prevents
       very tall datasets (e.g. invalid rows > 200) from overflowing the page.
       The cards will expand up to 60% of the viewport height, after which
       internal scrollbars appear. */
    .card {
      max-height: 60vh;
      overflow-y: auto;
    }

    /*
      When a card is collapsed (i.e. it has the `collapsed` class), remove the
      height constraint and allow it to shrink to just the heading. Also
      disable overflow so no scrollbars appear on an empty panel. Without
      this rule, collapsed panels continue to occupy large vertical space
      due to the max-height defined above.
    */
    .card.collapsed {
      max-height: unset;
      overflow: visible;
    }
    button {
      border: 1px solid var(--border);
      background: linear-gradient(180deg,var(--button-bg-start),var(--button-bg-end));
      padding: 4px 8px;
      font-size: 11px;
      color: var(--text);
      border-radius: 4px;
      cursor: pointer;
      /* Smooth transitions for subtle hover effects */
      transition: transform .15s ease, background .2s ease, filter .2s ease, box-shadow .2s ease;
    }
    
    /* Icon button styles for undo/redo */
    .icon-btn {
      background: rgba(255,255,255,0.08);
      border: 1px solid var(--border);
      border-radius: 3px;
      padding: 0;
      cursor: pointer;
      transition: all 0.2s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      color: var(--text);
      width: 28px;
      height: 28px;
      min-width: 28px;
      min-height: 28px;
      font-size: 10px;
    }
    
    /* Header select dropdown */
    .header-select {
      min-width: 80px;
      padding: 4px 8px;
      font-size: 11px;
      min-height: 28px;
    }
    
    .icon-btn:hover:not(:disabled) {
      background: rgba(255,255,255,0.12);
      border-color: var(--accent);
      transform: translateY(-1px);
    }
    
    .icon-btn:active:not(:disabled) {
      background: rgba(255,255,255,0.16);
      transform: translateY(0px);
    }
    
    .icon-btn:disabled {
      opacity: 0.4;
      cursor: not-allowed;
    }
    /* On hover, gently lift the button and brighten it for a responsive feel */
    button:hover {
      transform: translateY(-1px);
      filter: brightness(1.15);
      box-shadow: 0 3px 6px rgba(0,0,0,0.2);
    }
    /* Main content */
    .container {
      /* Stretch the container to fill the viewport width; remove fixed max width */
      width: 100%;
      max-width: none;
      margin: 0;
      padding: 16px;
      display: grid;
      /* Use an even two‑column layout for all cards, giving each tile equal width. */
      grid-template-columns: repeat(2, 1fr);
      gap: 16px;
      /* Let rows expand to fit their content instead of forcing equal heights. */
      grid-auto-rows: auto;
    }
    .card {
      background: var(--card-bg);
      border: 1px solid var(--border);
      border-radius: 6px;
      padding: 16px;
      /* Subtle shadow for depth; uses the same colour across themes. */
      box-shadow: 0 10px 30px rgba(0,0,0,.15), inset 0 1px 0 rgba(255,255,255,.04);
      /* Micro‑interaction: allow cards to animate slightly on hover */
      transition: transform .2s ease, box-shadow .2s ease;
      /* Position children absolutely relative to the card so export buttons can sit in the top‑right corner */
      position: relative;
    }
    .card:hover {
      transform: translateY(-2px);
      box-shadow: 0 14px 36px rgba(0,0,0,0.25), inset 0 1px 0 rgba(255,255,255,.04);
    }
    /* Layout header rows inside cards: spread the title and actions */
    .card-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 8px;
    }
    /* Card header buttons - consistent sizing */
    .card-header button {
      padding: 6px 12px;
      font-size: 10px;
      min-width: 100px;
      height: 28px;
      border-radius: 4px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
    }
    .card h2 {
      margin: 0 0 8px;
      font-size: 14px;
      font-weight: 600;
    }
    .row {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      align-items: center;
    }
    input[type="file"] { display: none; }
    input, select {
      background: var(--input-bg);
      color: var(--text);
      border: 1px solid var(--border);
      border-radius: 4px;
      padding: 4px 8px;
      font-size: 11px;
      min-height: 28px;
      /* Add a subtle transition so inputs glow when they receive focus. */
      transition: box-shadow .2s ease;
    }
    /* Focus state for inputs, selects and textareas: add a glow using the accent colour */
    input:focus, select:focus, textarea:focus {
      outline: none;
      box-shadow: 0 0 0 2px var(--accent);
    }
    .dropzone {
      border: 2px dashed #10b981;
      border-radius: 6px;
      padding: 12px;
      text-align: center;
      background: rgba(16,185,129,.08);
      transition: all 0.3s ease;
      position: relative;
      overflow: hidden;
      box-shadow: 0 0 8px rgba(16,185,129,0.2);
    }
    .dropzone:hover {
      border-color: #10b981;
      background: rgba(16,185,129,.15);
      transform: translateY(-1px);
      box-shadow: 0 0 16px rgba(16,185,129,0.4), 0 4px 12px rgba(16,185,129,0.3);
    }
    .dropzone-main {
      margin-bottom: 8px;
      font-size: 12px;
    }
    .dropzone-main .btn {
      background: linear-gradient(135deg, var(--accent), rgba(147,51,234,0.8));
      color: white;
      padding: 6px 12px;
      border-radius: 4px;
      font-size: 11px;
      font-weight: 500;
      cursor: pointer;
      display: inline-block;
      transition: all 0.2s ease;
    }
    .dropzone-main .btn:hover {
      transform: translateY(-1px);
      box-shadow: 0 4px 8px rgba(147,51,234,0.3);
    }
    .dropzone-formats {
      display: flex;
      justify-content: center;
      gap: 8px;
      margin: 6px 0;
    }
    .format-hint {
      background: rgba(255,255,255,0.1);
      padding: 3px 6px;
      border-radius: 10px;
      font-size: 10px;
      font-weight: 500;
      color: var(--accent);
      border: 1px solid rgba(147,51,234,0.2);
      transition: all 0.2s ease;
    }
    .format-hint:hover {
      background: rgba(147,51,234,0.15);
      transform: translateY(-1px);
    }
    .dropzone-divider {
      position: relative;
      margin: 16px 0;
      color: var(--muted);
      font-size: 12px;
    }
    .dropzone-divider::before {
      content: '';
      position: absolute;
      top: 50%;
      left: 0;
      right: 0;
      height: 1px;
      background: rgba(255,255,255,0.1);
      z-index: 1;
    }
    .dropzone-divider span {
      background: var(--card-bg);
      padding: 0 12px;
      position: relative;
      z-index: 2;
    }
    .sample-btn {
      background: linear-gradient(135deg, rgba(147,51,234,0.1), rgba(168,85,247,0.1));
      border: 1px solid rgba(147,51,234,0.3);
      border-radius: 4px;
      padding: 6px 10px;
      color: var(--accent);
      font-weight: 500;
      cursor: pointer;
      transition: all 0.3s ease;
      margin: 8px 0;
    }
    .sample-btn:hover {
      background: linear-gradient(135deg, rgba(147,51,234,0.15), rgba(168,85,247,0.15));
      border-color: var(--accent);
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(147,51,234,0.2);
    }
    .dropzone-details {
      margin-top: 16px;
      opacity: 0.7;
      font-size: 11px;
    }
    .dropzone.drag-active {
      border-color: var(--accent);
      background: rgba(147,51,234,.2);
      transform: scale(1.02);
      box-shadow: 0 8px 25px rgba(147,51,234,0.15);
    }
    .dropzone.drop-success {
      border-color: #10b981;
      background: rgba(16,185,129,.1);
      animation: dropSuccess 0.6s ease;
    }
    @keyframes dropSuccess {
      0% { transform: scale(1); }
      50% { transform: scale(1.05); }
      100% { transform: scale(1); }
    }
    
    /* Streamlined Data Operations Styling */
    .ops-step {
      margin: 8px 0;
      padding: 6px;
      background: rgba(255,255,255,0.02);
      border-radius: 4px;
      border: 1px solid rgba(255,255,255,0.05);
    }
    .ops-label {
      display: block;
      font-weight: 600;
      margin-bottom: 4px;
      color: var(--accent);
      font-size: 11px;
    }
    .ops-select {
      width: 100%;
      min-height: 60px;
      background: var(--input-bg);
      border: 1px solid var(--border);
      border-radius: 4px;
      padding: 6px;
      color: var(--text);
      font-size: 11px;
    }
    .quick-actions {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 4px;
    }
    /* Quick buttons in operations - improved legibility sizing */
    .quick-btn {
      background: linear-gradient(135deg, var(--accent), rgba(168,85,247,0.8));
      border: none;
      border-radius: 6px;
      padding: 12px 20px;
      color: white;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s ease;
      font-size: 13px;
      flex: 1;
      min-width: 140px;
      height: 44px;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
    }
    .quick-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 8px 20px rgba(147,51,234,0.3);
    }
    .download-dropdown {
      display: flex;
      gap: 4px;
      flex: 1;
    }
    .download-dropdown .quick-btn {
      font-size: 11px;
      padding: 10px 14px;
    }
    
    /* Histogram animations */
    .histogram-item {
      animation: slideInUp 0.6s ease-out;
      animation-fill-mode: both;
    }
    
    .histogram-item:nth-child(1) { animation-delay: 0.1s; }
    .histogram-item:nth-child(2) { animation-delay: 0.2s; }
    .histogram-item:nth-child(3) { animation-delay: 0.3s; }
    .histogram-item:nth-child(4) { animation-delay: 0.4s; }
    .histogram-item:nth-child(5) { animation-delay: 0.5s; }
    .histogram-item:nth-child(n+6) { animation-delay: 0.6s; }
    
    @keyframes slideInUp {
      from {
        opacity: 0;
        transform: translateY(30px) scale(0.95);
      }
      to {
        opacity: 1;
        transform: translateY(0) scale(1);
      }
    }
    
    /* Loading animation for histogram container */
    .histogram-loading {
      animation: pulse 1.5s ease-in-out infinite;
    }
    
    @keyframes pulse {
      0%, 100% { opacity: 0.6; }
      50% { opacity: 1; }
    }
    .custom-ops {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 4px;
    }
    .op-checkbox {
      display: flex;
      align-items: flex-start;
      padding: 6px;
      border-radius: 4px;
      cursor: pointer;
      transition: background 0.2s ease;
    }
    .op-checkbox:hover {
      background: rgba(147,51,234,0.05);
    }
    .op-checkbox input {
      margin-right: 8px;
      margin-top: 2px;
      width: 14px;
      height: 14px;
    }
    .op-text {
      font-weight: 500;
      font-size: 12px;
      display: block;
    }
    .ops-actions {
      display: flex;
      gap: 12px;
      margin-top: 16px;
      flex-wrap: wrap;
      align-items: center;
    }
    .primary-btn {
      background: linear-gradient(135deg, var(--accent), rgba(147,51,234,0.8));
      border: none;
      border-radius: 4px;
      padding: 6px 10px;
      color: white;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s ease;
      font-size: 11px;
    }
    .primary-btn:hover:not(:disabled) {
      transform: translateY(-1px);
      box-shadow: 0 6px 16px rgba(147,51,234,0.4);
    }
    .primary-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    /* Secondary action buttons - compact uniform size */
    .secondary-btn {
      background: var(--button-bg-start);
      border: 1px solid var(--border);
      border-radius: 6px;
      padding: 10px 16px;
      color: var(--text);
      cursor: pointer;
      transition: all 0.2s ease;
      font-size: 12px;
      min-width: 110px;
      height: 40px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
    }
    .secondary-btn:hover:not(:disabled) {
      background: var(--button-bg-end);
      transform: translateY(-1px);
    }
    .secondary-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    .ops-results {
      margin-top: 8px;
      padding: 6px;
      background: rgba(16,185,129,0.05);
      border: 1px solid rgba(16,185,129,0.2);
      border-radius: 4px;
    }
    .result-summary {
      color: var(--accent);
      font-weight: 500;
      margin-bottom: 4px;
    }
    .result-keys {
      font-size: 11px;
      color: var(--muted);
    }
    
    /* =====================================================
       DATAPHREAK DESIGN SYSTEM - UNIFIED PATTERNS
       ===================================================== */
    
    
    /* Smart Button Hierarchy */
    /* Field action buttons - consistent small size */
    .field-btn {
      padding: 6px 12px;
      font-size: 10px;
      min-width: 80px;
      height: 28px;
      border-radius: 4px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
    }
    
    .btn-primary {
      background: linear-gradient(135deg, var(--accent), rgba(147,51,234,0.8));
      border: none;
      border-radius: 4px;
      padding: 6px 10px;
      color: white;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s ease;
      font-size: 11px;
      position: relative;
      overflow: hidden;
    }
    .btn-primary::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
      transition: left 0.5s ease;
    }
    .btn-primary:hover::before {
      left: 100%;
    }
    .btn-primary:hover:not(:disabled) {
      transform: translateY(-2px);
      box-shadow: 0 8px 20px rgba(147,51,234,0.4);
    }
    
    .btn-secondary {
      background: var(--button-bg-start);
      border: 1px solid var(--border);
      border-radius: 6px;
      padding: 10px 16px;
      color: var(--text);
      cursor: pointer;
      transition: all 0.2s ease;
      font-size: 12px;
      font-weight: 500;
      min-width: 110px;
      height: 40px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
    }
    .btn-secondary:hover:not(:disabled) {
      background: var(--button-bg-end);
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(0,0,0,0.1);
    }
    
    .btn-tertiary {
      background: transparent;
      border: 1px solid transparent;
      border-radius: 3px;
      padding: 4px 6px;
      color: var(--muted);
      cursor: pointer;
      transition: all 0.2s ease;
      font-size: 10px;
    }
    .btn-tertiary:hover:not(:disabled) {
      background: rgba(255,255,255,0.05);
      color: var(--text);
      border-color: var(--border);
    }
    
    /* Status Indicators */
    .status-success {
      color: #10b981;
      background: rgba(16,185,129,0.1);
      border: 1px solid rgba(16,185,129,0.2);
      border-radius: 3px;
      padding: 2px 4px;
      font-size: 9px;
      font-weight: 500;
    }
    .status-warning {
      color: #f59e0b;
      background: rgba(245,158,11,0.1);
      border: 1px solid rgba(245,158,11,0.2);
      border-radius: 3px;
      padding: 2px 4px;
      font-size: 9px;
      font-weight: 500;
    }
    .status-error {
      color: #ef4444;
      background: rgba(239,68,68,0.1);
      border: 1px solid rgba(239,68,68,0.2);
      border-radius: 3px;
      padding: 2px 4px;
      font-size: 9px;
      font-weight: 500;
    }
    
    /* Section Headers with Emoji */
    .section-header {
      display: flex;
      align-items: center;
      gap: 6px;
      margin-bottom: 12px;
      padding-bottom: 8px;
      border-bottom: 1px solid rgba(255,255,255,0.08);
    }
    .section-emoji {
      font-size: 14px;
      opacity: 0.8;
    }
    .section-title {
      font-size: 13px;
      font-weight: 600;
      color: var(--text);
      flex: 1;
    }
    .section-subtitle {
      font-size: 10px;
      color: var(--muted);
    }
    
    /* Quick Action Grid */
    .quick-grid {
      display: flex;
      flex-direction: row;
      gap: 12px;
      margin: 12px 0;
      justify-content: space-between;
    }
    
    /* Quick Action Buttons */
    .quick-action {
      background: linear-gradient(135deg, var(--accent), rgba(168,85,247,0.8));
      border: none;
      border-radius: 6px;
      padding: 12px 18px;
      color: white;
      cursor: pointer;
      transition: all 0.2s ease;
      text-align: center;
      position: relative;
      overflow: hidden;
      flex: 1;
      height: 76px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 6px;
    }
    .quick-action::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(255,255,255,0.1);
      opacity: 0;
      transition: opacity 0.2s ease;
    }
    .quick-action:hover::before {
      opacity: 1;
    }
    .quick-action:hover {
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(147,51,234,0.2);
    }
    .quick-action-emoji {
      font-size: 22px;
      display: block;
    }
    .quick-action-text {
      font-size: 12px;
      font-weight: 600;
      margin: 0;
      text-align: center;
    }
    
    /* Results & Feedback */
    .result-card {
      margin-top: 8px;
      padding: 8px;
      border-radius: 4px;
      border-left: 2px solid var(--accent);
      background: rgba(147,51,234,0.05);
      animation: slideInUp 0.3s ease;
    }
    
    /* Loading States */
    .loading {
      position: relative;
      pointer-events: none;
      opacity: 0.7;
    }
    .loading::after {
      content: '';
      position: absolute;
      top: 50%;
      left: 50%;
      width: 20px;
      height: 20px;
      margin: -10px 0 0 -10px;
      border: 2px solid transparent;
      border-top: 2px solid var(--accent);
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    
    /* Smart KPI Cards */
    .kpi-grid {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      margin: 12px 0;
      justify-content: space-between;
    }
    .kpi-card {
      background: linear-gradient(135deg, rgba(255,255,255,0.04), rgba(255,255,255,0.02));
      border: 1px solid rgba(255,255,255,0.08);
      border-radius: 6px;
      padding: 10px 12px;
      display: flex;
      align-items: center;
      gap: 8px;
      transition: all 0.2s ease;
      position: relative;
      overflow: hidden;
      width: 140px;
      flex: 0 0 auto;
    }
    .kpi-card::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 1px;
      background: linear-gradient(90deg, var(--accent), rgba(168,85,247,0.8));
      opacity: 0;
      transition: opacity 0.2s ease;
    }
    .kpi-card:hover::before {
      opacity: 1;
    }
    .kpi-card:hover {
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(0,0,0,0.08);
      border-color: var(--accent);
    }
    .kpi-icon {
      font-size: 16px;
      opacity: 0.7;
    }
    .kpi-content {
      flex: 1;
    }
    .kpi-value {
      font-size: 14px;
      font-weight: 600;
      color: var(--text);
      line-height: 1.1;
    }
    .kpi-label {
      font-size: 9px;
      color: var(--muted);
      font-weight: 500;
      text-transform: uppercase;
      letter-spacing: 0.3px;
    }
    .kpi-status {
      font-size: 8px;
      margin-top: 2px;
      opacity: 0.7;
    }
    
    /* Dataset Info Panel */
    .dataset-info-panel {
      display: flex;
      flex-wrap: wrap;
      gap: 16px;
      margin: 16px 0;
      padding: 12px;
      background: rgba(255,255,255,0.03);
      border-radius: 6px;
      border: 1px solid rgba(255,255,255,0.06);
    }
    .info-item {
      display: flex;
      align-items: center;
      gap: 6px;
      flex: 1;
      min-width: 120px;
    }
    .info-label {
      font-size: 11px;
      color: var(--muted);
      font-weight: 500;
    }
    .info-value {
      font-size: 12px;
      color: var(--text);
      font-weight: 600;
    }
    
    .control-group {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .control-label {
      font-size: 12px;
      font-weight: 500;
      color: var(--muted);
    }
    .range-slider {
      width: 120px;
      height: 4px;
      background: rgba(255,255,255,0.1);
      border-radius: 2px;
      outline: none;
      cursor: pointer;
    }
    .range-slider::-webkit-slider-thumb {
      width: 14px;
      height: 14px;
      background: var(--accent);
      border-radius: 50%;
      cursor: pointer;
      border: none;
      box-shadow: 0 2px 4px rgba(0,0,0,0.2);
    }
    .control-value {
      font-size: 11px;
      color: var(--accent);
      font-weight: 600;
      min-width: 30px;
    }
    .view-modes {
      display: flex;
      gap: 10px;
    }
    /* View mode buttons - grouped toggle style */
    .view-mode {
      padding: 8px 14px;
      border-radius: 6px;
      border: 1px solid rgba(255,255,255,0.1);
      background: transparent;
      color: var(--muted);
      font-size: 11px;
      cursor: pointer;
      transition: all 0.2s ease;
      min-width: 80px;
      height: 36px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 4px;
    }
    .view-mode.active {
      background: var(--accent);
      color: white;
      border-color: var(--accent);
    }
    .view-mode:hover:not(.active) {
      background: rgba(255,255,255,0.05);
      color: var(--text);
    }
    
    .legend-item {
      display: flex;
      align-items: center;
      gap: 3px;
      font-size: 9px;
      color: var(--muted);
    }
    .legend-color {
      width: 8px;
      height: 8px;
      border-radius: 2px;
      border: 1px solid rgba(255,255,255,0.2);
    }
    .legend-color.missing {
      background: #ef4444;
    }
    .legend-color.present {
      background: #6b7280;
    }
    
    /* Alternative Views */
    .analysis-controls {
      display: flex;
      justify-content: center;
      align-items: center;
      margin: 16px 0;
      padding: 8px;
      background: rgba(255,255,255,0.02);
      border-radius: 6px;
      border: 1px solid rgba(255,255,255,0.05);
    }
    
    .analysis-view {
      margin-top: 16px;
      padding: 16px;
      background: rgba(255,255,255,0.02);
      border-radius: 6px;
      border: 1px solid rgba(255,255,255,0.05);
    }
    
    .stats-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 12px;
      margin-top: 12px;
    }
    .view-header {
      font-weight: 600;
      margin-bottom: 6px;
      color: var(--accent);
      font-size: 11px;
    }
    
    /* Missing Values List View */
    .no-data {
      text-align: center;
      padding: 20px;
      color: var(--muted);
      font-size: 12px;
    }
    .missing-list {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }
    .missing-item {
      padding: 12px;
      border-radius: 6px;
      border-left: 3px solid;
      background: rgba(255,255,255,0.02);
      margin-bottom: 8px;
    }
    
    .missing-item-content {
      width: 100%;
    }
    
    .missing-item-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 4px;
    }
    
    .missing-item-details {
      font-size: 11px;
      color: var(--muted);
      opacity: 0.8;
    }
    .missing-item.high {
      border-left-color: #ef4444;
      background: rgba(239,68,68,0.05);
    }
    .missing-item.medium {
      border-left-color: #f59e0b;
      background: rgba(245,158,11,0.05);
    }
    .missing-item.low {
      border-left-color: #10b981;
      background: rgba(16,185,129,0.05);
    }
    .missing-column {
      font-weight: 600;
      color: var(--text);
    }
    .missing-stats {
      display: flex;
      gap: 12px;
      align-items: center;
    }
    .missing-count {
      color: var(--muted);
      font-size: 12px;
    }
    .missing-percentage {
      font-weight: 600;
      font-size: 14px;
      color: var(--accent);
    }
    
    /* Missing Values Stats View */
    .stats-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
      gap: 12px;
      margin-bottom: 20px;
    }
    .stat-card {
      text-align: center;
      padding: 8px 6px;
      border-radius: 4px;
      background: linear-gradient(135deg, rgba(147,51,234,0.05), rgba(168,85,247,0.05));
      border: 1px solid rgba(147,51,234,0.1);
    }
    .stat-value {
      font-size: 14px;
      font-weight: 700;
      color: var(--accent);
      margin-bottom: 2px;
    }
    .stat-label {
      font-size: 8px;
      color: var(--muted);
      text-transform: uppercase;
      letter-spacing: 0.3px;
    }
    .stats-overview {
      margin-bottom: 20px;
    }
    
    .stats-cards {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
      gap: 12px;
      margin-top: 12px;
    }
    
    .breakdown-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 16px;
      margin-top: 12px;
    }
    
    .breakdown-section {
      background: rgba(255,255,255,0.02);
      padding: 12px;
      border-radius: 6px;
      border: 1px solid rgba(255,255,255,0.05);
    }
    
    .breakdown-section h5 {
      margin: 0 0 8px 0;
      font-size: 12px;
      color: var(--accent);
    }
    
    .breakdown-label {
      font-weight: 500;
      color: var(--text);
    }
    
    .stats-breakdown h4 {
      margin: 16px 0 8px 0;
      color: var(--text);
      font-size: 13px;
    }
    .breakdown-item {
      display: flex;
      justify-content: space-between;
      padding: 4px 6px;
      border-radius: 2px;
      background: rgba(255,255,255,0.02);
      margin-bottom: 2px;
      font-size: 10px;
    }
    .breakdown-column {
      color: var(--text);
      font-weight: 500;
    }
    .breakdown-value {
      color: var(--muted);
      font-size: 10px;
    }
    .small { font-size: 10px; }
    .muted { color: var(--muted); }
    .kpi {
      display: flex;
      justify-content: space-between;
    }
    .kpi .inner {
      flex: 1;
      padding: 3px 6px;
      /* Use chip colour as a subtle backdrop for each statistic */
      background: var(--chip);
      /* Remove the inner border for a cleaner look */
      border: none;
    }
    /* Draw a thin divider between KPI items except the last */
    .kpi .inner:not(:last-child) {
      border-right: 1px solid var(--border);
    }
    table {
      width: 100%;
      border-collapse: separate;
      border-spacing: 0 3px;
    }
    thead th {
      font-size: 10px;
      color: var(--muted);
      text-align: left;
      padding: 0 5px 3px;
      white-space: nowrap;
    }
    tbody td {
      padding: 5px;
      font-size: 10px;
      vertical-align: top;
      background: var(--table-row-bg);
      border-top: 1px solid var(--border);
      border-bottom: 1px solid var(--border);
    }
    tbody tr td:first-child { border-left: 1px solid var(--border); border-radius: 4px 0 0 4px; }
    tbody tr td:last-child  { border-right: 1px solid var(--border); border-radius: 0 4px 4px 0; }

    /*
      Row striping and hover highlighting: alternate the background of
      table rows for better readability, and highlight a row when the
      mouse moves over it. These colours use theme variables defined
      above.
    */
    tbody tr:nth-child(even) td {
      background: var(--table-row-alt-bg);
    }
    tbody tr:hover td {
      background: var(--table-row-hover-bg);
    }
    .bar {
      height: 4px;
      background: rgba(255,255,255,.08);
      border: 1px solid var(--border);
      border-radius: 3px;
      overflow: hidden;
    }
    .bar span {
      display: block;
      height: 100%;
      background: var(--ok);
    }

    /*
      Collapsible panels: when a card has the `collapsed` class, hide all
      child elements except the heading (`h2`). The chevron in the
      heading rotates to indicate the collapsed state. A small
      transition on the chevron makes the rotation smooth.
    */
    .card.collapsed > :not(h2):not(.card-header):not(.section-header) {
      display: none;
    }
    /* For cards with card-header structure, hide content but keep header visible */
    .card.collapsed .card-header ~ * {
      display: none;
    }
    /* For cards with section-header structure, hide content but keep header visible */
    .card.collapsed .section-header ~ * {
      display: none;
    }
    .collapse-toggle {
      transition: transform 0.2s ease;
      /* Increase the clickable area of the chevron so that
         users don’t have to click precisely on the symbol. */
      display: inline-block;
      width: 1.2em;
      height: 1em;
      text-align: center;
      cursor: pointer;
    }
    .card.collapsed h2 .collapse-toggle,
    .card.collapsed .section-header .collapse-toggle {
      transform: rotate(-90deg);
    }

    /*
      Sticky headers for tables: keep the header row visible as you scroll
      through long tables. Applies to the Field Analysis and Invalid Rows
      tables. The background is set to the panel colour so headers stand
      out from the scrolling content.
    */
    #profileTable thead th,
    #invalidTableWrap table thead th {
      position: sticky;
      top: 0;
      background: var(--panel);
      z-index: 2;
    }
    .tag {
      display: inline-block;
      padding: 2px 6px;
      font-size: 12px;
      border: 1px solid var(--border);
      border-radius: 999px;
      background: var(--chip);
      color: var(--muted);
      margin-right: 6px;
    }
    .rule-input { width: 100%; }
    #rulesStatus { display: none; }

    /* Modal styles for Salesforce ID converter */
    .modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.75);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 200;
      /* Fade in/out animation: modals are initially visible but can
         transition their opacity. Pointer events ensure clicks are
         ignored when hidden. */
      opacity: 1;
      pointer-events: auto;
      transition: opacity 0.25s ease;
    }
    .modal.hidden {
      /* Do not remove the element from the layout; instead fade it out and
         disable interaction. The opacity and pointer-events properties
         are transitioned smoothly to create a fade effect. */
      opacity: 0;
      pointer-events: none;
    }
    .modal-content {
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 20px;
      /* Widen help modal for better readability */
      max-width: 680px;
      width: 100%;
      box-shadow: 0 10px 30px rgba(0,0,0,0.3);
    }
    .modal-content h3 {
      margin-top: 0;
      margin-bottom: 12px;
      font-size: 18px;
    }
    .modal-content p {
      margin-top: 0;
      margin-bottom: 12px;
    }
    .modal-buttons {
      display: flex;
      justify-content: flex-end;
      gap: 8px;
    }

    /* Allow fuzzy duplicate results to scroll within the card if too long */
    #fuzzyResults {
      max-height: 250px;
      overflow-y: auto;
    }

    /* Help modal index styles */
    .help-index {
      margin-top: 0;
    }
    .help-index a {
      display: inline-block;
      padding: 6px 12px;
      border-radius: 999px;
      border: 1px solid var(--border);
      background: var(--panel);
      color: var(--text);
      text-decoration: none;
      font-size: 13px;
      white-space: nowrap;
      line-height: 1.3;
      min-height: 24px;
      box-sizing: border-box;
      transition: all 0.2s ease;
      margin: 2px 0;
    }
    .help-index a:hover {
      background: var(--nav-hover-bg);
      color: var(--text);
      transform: translateY(-1px);
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    
    /* Responsive help navigation */
    @media (max-width: 768px) {
      .help-index a {
        font-size: 12px;
        padding: 4px 8px;
        margin: 1px;
      }
    }
    
    @media (max-width: 480px) {
      .help-index a {
        font-size: 11px;
        padding: 3px 6px;
        margin: 1px;
        line-height: 1.2;
      }
    }
  </style>
</head>
<body>
  <header>
    <!--
      The header is split into three logical sections: a left area for
      contextual badges (e.g. single‑file/offline status), a centre area
      containing the app title and version, and a right area for
      dataset‑specific pills (current file name and rules status). By
      using a three‑column grid here the title remains centred while
      the other items can float to either side.
    -->
    <div class="header-inner">
      <div class="header-left">
        <span class="pill">Single‑file • Offline‑ready</span>
      </div>
      <h1>
        <span class="logo" aria-hidden="true" title="DATAPHREAK logo">
          <!-- Simple bar chart icon -->
          <svg width="22" height="22" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg">
            <rect x="3"  y="10" width="4" height="11" rx="1"></rect>
            <rect x="10" y="6"  width="4" height="15" rx="1"></rect>
            <rect x="17" y="2"  width="4" height="19" rx="1"></rect>
          </svg>
        </span>
        DATAPHREAK<span class="version">v0.8.0</span>
      </h1>
      <div class="header-right">
        <!-- Undo/Redo controls -->
        <div class="undo-redo-controls" style="display: flex; gap: 8px; margin-right: 8px;">
          <button id="undoBtn" type="button" class="icon-btn" title="Nothing to undo" disabled>
            <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
              <path d="M12.5 8c-2.65 0-5.05 1.18-6.68 3.06L3.94 9.18C5.96 6.35 9.02 5 12.5 5c5.08 0 9.31 3.75 9.94 8.65l-2.01-.2C19.8 9.64 16.46 8 12.5 8z"/>
              <path d="M5.82 14.24l1.92-1.92c.8.78 1.86 1.3 3.03 1.47L11 15.84c-.82-.13-1.57-.44-2.18-.92z"/>
              <path d="M3 12l4-4v8z"/>
            </svg>
          </button>
          <button id="redoBtn" type="button" class="icon-btn" title="Nothing to redo" disabled>
            <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
              <path d="M11.5 8c2.65 0 5.05 1.18 6.68 3.06l1.88-1.88C17.96 6.35 14.98 5 11.5 5c-5.08 0-9.31 3.75-9.94 8.65l2.01-.2C4.2 9.64 7.54 8 11.5 8z"/>
              <path d="M18.18 14.24l-1.92-1.92c-.8.78-1.86 1.3-3.03 1.47L13 15.84c.82-.13 1.57-.44 2.18-.92z"/>
              <path d="M21 12l-4-4v8z"/>
            </svg>
          </button>
        </div>
        <span id="datasetName" class="pill">No dataset loaded</span>
        <!-- Dataset switcher: allows toggling between primary and secondary datasets -->
        <select id="datasetSwitch" title="Toggle between the primary and secondary datasets" style="min-width:120px">
          <option value="primary" selected>Primary</option>
          <option value="secondary" disabled>Secondary (none)</option>
        </select>
        <span id="rulesStatus" class="pill"></span>
      </div>
    </div>
    <nav id="topNav">
      <div class="nav-actions">
        <button id="navLoadSample" type="button" title="📁 Upload your CSV file or try sample data to get started">Load File</button>
        <!-- Run Checks button moved into Field Analysis panel -->
        <!-- Export Dict button moved into Dataset Summary panel -->
        <!-- Save Rules, Clear Rules and Download Rules buttons moved into Field Analysis panel -->
        <!-- Salesforce ID conversion has been integrated into Data Operations; the nav button has been removed. -->
        <!-- Launch cross‑file merge & ID matching -->
        <button id="navMerge" type="button" title="🔗 Combine two files together - great for joining customer lists or datasets">Merge Files</button>
        <!-- Data visualization histograms -->
        <button id="navHistograms" type="button" title="📊 See beautiful charts showing how your data is distributed">Histograms</button>
        <!-- Help: open documentation modal -->
        <button id="navHelp" type="button" title="❓ Get help and learn how to use all features">Help</button>
    <!-- Settings: open preferences modal -->
    <button id="navSettings" type="button" title="⚙️ Customize themes, preferences, and data saving options">Settings</button>
        <!-- Theme toggle: cycles through dark, light and high‑tech modes -->
        <button id="themeToggle" type="button" title="🎨 Switch between Dark, Light, and cool Matrix themes">Light Mode</button>
      </div>
    </nav>
  </header>
  <div class="container">
    <!-- Load Data -->
    <section class="card" id="loadSection">
      <h2 title="Start here: drag or choose a CSV/TSV/Excel file. The file must include header names">Load Data <span class="collapse-toggle" role="button" aria-label="Collapse section" title="Collapse or expand this section">▼</span></h2>
      <div class="dropzone" id="dropzone">
        <div class="dropzone-main">
          <strong>Drag &amp; drop</strong> your file here or
          <label class="btn" for="fileInput">Choose file</label>
          <input type="file" id="fileInput" accept=".csv,.tsv,.xlsx,.xls,text/csv,text/tab-separated-values,application/vnd.openxmlformats-officedocument.spreadsheetml.sheet,application/vnd.ms-excel" title="📁 Choose a CSV, TSV, or Excel file from your computer">
        </div>
        <div class="dropzone-formats">
          <span class="format-hint">📊 CSV</span>
          <span class="format-hint">📋 TSV</span> 
          <span class="format-hint">📈 Excel</span>
        </div>
        <div class="dropzone-divider">
          <span>or</span>
        </div>
        <div style="display: flex; justify-content: center; margin: 8px 0;">
          <button id="loadSample" type="button" class="quick-btn" style="flex: none;" title="✨ Try sample data first - perfect for learning how DATAPHREAK works!">✨ Try Sample Data</button>
        </div>
        <div class="dropzone-details muted small">
          Column names required • Automatically detects format • Works with any CSV file
        </div>
      </div>
      <!-- Hide the underlying control buttons in Load Data. They remain in the DOM for functionality but are not visible to users. -->
      <div class="row" style="margin-top:8px; display:none">
        <button id="exportDict" type="button" disabled title="Download a summary file describing each field (counts, unique values, min/max, etc.)">Export Data Dictionary</button>
        <button id="runRules" type="button" disabled title="🔍 Check your data for issues based on your quality rules">Run Rule Checks</button>
      </div>
      <div class="row" style="margin-top:4px; display:none">
        <button id="saveRules" type="button" disabled title="💾 Save your data quality rules so they're remembered next time you open this file">Save Rules</button>
        <button id="clearRules" type="button" disabled title="Reset all rules for this dataset back to suggestions by removing any saved rules">Clear Rules</button>
        <button id="downloadRules" type="button" disabled title="Download your current rule settings as a file so you can share them or import them later">Download Rules</button>
      </div>
      <div class="small muted" style="margin-top:12px">Empty values recognized: <code>""</code>, <code>NA</code>, <code>N/A</code>, <code>null</code>, <code>NaN</code> (case‑insensitive).</div>
    </section>
    <!-- Dataset Overview -->
    <section class="card" id="summarySection">
      <div class="section-header">
        <div>
          <div class="section-title">Data Overview</div>
        </div>
        <span class="collapse-toggle" role="button" aria-label="Collapse section" title="Collapse or expand this section">▼</span>
      </div>
      
      <!-- Dataset Info Display -->
      <div id="datasetInfo" class="dataset-info-panel">
        <div class="info-item">
          <span class="info-label">📄 File:</span>
          <span id="infoFileName" class="info-value">No file loaded</span>
        </div>
        <div class="info-item">
          <span class="info-label">📏 Size:</span>
          <span id="infoFileSize" class="info-value">—</span>
        </div>
        <div class="info-item">
          <span class="info-label">🕒 Loaded:</span>
          <span id="infoLoadTime" class="info-value">—</span>
        </div>
        <div class="info-item">
          <span class="info-label">✨ Status:</span>
          <span id="infoStatus" class="info-value">Ready to analyze</span>
        </div>
      </div>
      
      <!-- Visual Analysis Tiles -->
      <div class="kpi-grid">
        <div class="kpi-card" id="kpiRowsCard">
          <div class="kpi-icon"></div>
          <div class="kpi-content">
            <div class="kpi-value" id="kpiRows">—</div>
            <div class="kpi-label">Rows</div>
            <div class="kpi-status" id="kpiRowsStatus"></div>
          </div>
        </div>
        <div class="kpi-card" id="kpiColsCard">
          <div class="kpi-icon"></div>
          <div class="kpi-content">
            <div class="kpi-value" id="kpiCols">—</div>
            <div class="kpi-label">Columns</div>
            <div class="kpi-status" id="kpiColsStatus"></div>
          </div>
        </div>
        <div class="kpi-card" id="kpiDupesCard">
          <div class="kpi-icon"></div>
          <div class="kpi-content">
            <div class="kpi-value" id="kpiDupes">—</div>
            <div class="kpi-label">Duplicates</div>
            <div class="kpi-status" id="kpiDupesStatus"></div>
          </div>
        </div>
        <div class="kpi-card" id="kpiMissingCard">
          <div class="kpi-icon"></div>
          <div class="kpi-content">
            <div class="kpi-value" id="kpiMissing">—</div>
            <div class="kpi-label">Missing</div>
            <div class="kpi-status" id="kpiMissingStatus"></div>
          </div>
        </div>
        <div class="kpi-card" id="kpiCompletenessCard">
          <div class="kpi-icon"></div>
          <div class="kpi-content">
            <div class="kpi-value" id="kpiCompleteness">—</div>
            <div class="kpi-label">Data Completeness</div>
            <div class="kpi-status" id="kpiCompletenessStatus"></div>
          </div>
        </div>
        <div class="kpi-card" id="kpiTotalCellsCard">
          <div class="kpi-icon"></div>
          <div class="kpi-content">
            <div class="kpi-value" id="kpiTotalCells">—</div>
            <div class="kpi-label">Total Cells</div>
            <div class="kpi-status" id="kpiTotalCellsStatus"></div>
          </div>
        </div>
        <div class="kpi-card" id="kpiQualityCard" title="AI-powered data quality assessment - hover status for detailed breakdown of completeness, consistency, and validity">
          <div class="kpi-icon">🎯</div>
          <div class="kpi-content">
            <div class="kpi-value" id="kpiQuality">—</div>
            <div class="kpi-label">Data Quality</div>
            <div class="kpi-status" id="kpiQualityStatus"></div>
          </div>
        </div>
      </div>
      

      <!-- Smart Recommendations -->
      <div id="smartRecommendations" class="result-card" style="display:none;">
        <div style="font-weight: 600; margin-bottom: 8px;">🤖 Smart Recommendations</div>
        <div id="recommendationsList"></div>
      </div>
    </section>
    <!-- Data Quality -->
    <section class="card" id="heatmapSection">
      <div class="section-header">
        <div>
          <div class="section-title">Data Quality</div>
        </div>
        <span class="collapse-toggle" role="button" aria-label="Collapse section" title="Collapse or expand this section">▼</span>
      </div>
      
      <!-- Analysis View Controls -->
      <div class="analysis-controls">
        <div class="view-modes">
          <button class="view-mode" data-mode="list" title="📋 See which columns have missing data and how many gaps">📋 Column Analysis</button>
          <button class="view-mode" data-mode="stats" title="📊 View overall data quality metrics and statistics">📊 Quality Statistics</button>
        </div>
      </div>
      
      <!-- Analysis Views -->
      <div id="listView" class="analysis-view">
        <div class="view-header">📋 Missing Values by Column</div>
        <div id="missingValuesList" class="missing-list"></div>
      </div>
      
      <div id="statsView" class="analysis-view" style="display:none;">
        <div class="view-header">📊 Data Quality Statistics</div>
        <div id="missingValuesStats" class="stats-grid"></div>
      </div>
      
    </section>
    <!-- Data Operations -->
    <section class="card" id="operationsSection">
      <h2 title="Clean your data and manage unique identifiers">Data Cleaning &amp; IDs <span class="collapse-toggle" role="button" aria-label="Collapse section" title="Collapse or expand this section">▼</span></h2>
      <div class="small muted">Select fields and choose your approach: quick fixes or custom operations.</div>
      
      <!-- Field Selection and Custom Operations Row -->
      <div class="ops-row">
        <!-- Field Selection (50% width) -->
        <div class="ops-step ops-half">
          <label for="opColumns" class="ops-label">📋 Select Fields</label>
          <select id="opColumns" multiple class="ops-select" title="📋 Choose which columns to clean - hold Ctrl/Cmd to select multiple">
            <option disabled>Load data to see fields...</option>
          </select>
        </div>
        
        <!-- Custom Operations (50% width) -->
        <div class="ops-step ops-half">
          <div class="ops-label">🎛️ Custom Operations</div>
          <div class="custom-ops">
            <label class="op-checkbox" title="✂️ Remove extra spaces before and after text (e.g., '  John  ' becomes 'John')">
              <input type="checkbox" id="opTrim">
              <span class="op-text">Trim spaces</span>
            </label>
            <label class="op-checkbox" title="✏️ Smart capitalization - Names become Title Case, emails lowercase, IDs UPPERCASE">
              <input type="checkbox" id="opNormalize">
              <span class="op-text">Fix letter case</span>
            </label>
            <label class="op-checkbox" title="🧹 Convert special characters to regular ones (e.g., 'José' becomes 'Jose')">
              <input type="checkbox" id="opClean">
              <span class="op-text">Remove accents</span>
            </label>
            <label class="op-checkbox" title="🔧 Convert short Salesforce IDs to long format (for Salesforce users only)">
              <input type="checkbox" id="opSfConvert">
              <span class="op-text">Convert SF IDs</span>
            </label>
          </div>
        </div>
      </div>
      
      <!-- Apply Changes -->
      <div class="ops-actions">
        <button id="opApply" type="button" class="primary-btn" title="Apply selected operations">
          Apply Changes
        </button>
      </div>
      
      <!-- Quick Actions -->
      <div class="ops-step">
        <div class="ops-label">⚡ Quick Actions</div>
        <div class="quick-actions" style="grid-template-columns: repeat(5, 1fr);">
          <button type="button" class="quick-btn" id="quickCleanAll" title="🧹 Smart one-click cleanup - fixes spacing, capitalization, special characters, and auto-corrects email/phone/date formats using AI pattern detection">
            🧹 Clean All
          </button>
          <button type="button" class="quick-btn" id="quickAnalyzeKeys" title="🔑 Find columns that can uniquely identify each row (like ID numbers)">
            🔑 Analyze Keys
          </button>
          <button type="button" class="quick-btn" id="quickPrepare" title="✨ Clean your data then find unique identifiers - perfect combo for data prep!">
            ✨ Prepare Data
          </button>
          <button type="button" class="quick-btn" id="quickAddId" title="🆔 Add a new ID column with unique numbers for each row">
            🆔 Add ID
          </button>
          <div class="download-dropdown">
            <button type="button" class="quick-btn" id="quickDownloadCSV" title="Download current dataset as CSV" disabled>
              📥 Download CSV
            </button>
            <button type="button" class="quick-btn" id="quickDownloadJSON" title="Download current dataset as JSON" disabled>
              📄 Download JSON
            </button>
          </div>
        </div>
      </div>
      
      <!-- Results Area -->
      <div id="opResults" class="ops-results" style="display:none;">
        <div id="opChangeSummary" class="result-summary"></div>
        <div id="opKeyResults" class="result-keys"></div>
      </div>
    </section>
    <!-- Duplicate Rows -->
    <section class="card" id="dupeSection">
      <!-- Header row with title and export button -->
      <div class="card-header">
        <h2 title="Find both exact duplicates and similar records using AI - catches more issues than basic matching">Single-File Duplicates <span class="collapse-toggle" role="button" aria-label="Collapse section" title="Collapse or expand this section">▼</span></h2>
        <button id="exportExactDupCsv" type="button" title="📥 Download your data with both exact and similar duplicates marked in separate columns - perfect for review in Excel">Export duplicates CSV</button>
      </div>
      <div id="dupeSummary" class="small muted">&mdash;</div>
      <div id="dupeList" class="small" style="margin-top:8px"></div>
    </section>

    <!-- Fuzzy Duplicates -->
    
    <!-- Cross-File Fuzzy Duplicates (single-file controls removed for MVP) -->
    <section class="card" id="fuzzySection">
      <!-- Header row with title and export button -->
      <div class="card-header">
        <h2 title="Find near‑duplicate values across two datasets">Cross‑File Duplicates <span class="collapse-toggle" role="button" aria-label="Collapse section" title="Collapse or expand this section">▼</span></h2>
        <button id="exportFuzzyCrossCsv" type="button" title="Download a merged CSV of both datasets with cross‑file duplicates highlighted">Export cross‑file duplicates</button>
      </div>
      <!-- Cross-file fuzzy matching only -->
      <div class="fuzzy-controls" style="display:flex;flex-wrap:wrap;gap:8px;align-items:center;margin-top:8px;">
        <label class="small" style="margin-right:4px" title="Compare values across datasets">Cross‑file:</label>
        <select id="fuzzyACol" title="Select the column from the primary dataset" style="min-width:100px"></select>
        <span class="small" aria-hidden="true" style="margin:0 2px">↔</span>
        <select id="fuzzyBCol" title="Select the column from the secondary dataset" style="min-width:100px"></select>
        <label for="fuzzyThreshold" class="small" style="margin-left:8px;margin-right:4px" title="Higher values count only very similar entries; lower values allow more differences">Threshold:</label>
        <input id="fuzzyThreshold" type="range" min="0.50" max="1.00" step="0.01" value="0.85" title="Set how similar values must be to count as duplicates: 1.00 is exact matches; lower values allow more differences" style="width:100px">
        <span id="fuzzyThresholdLabel" class="small muted" style="margin-left:4px">0.85</span>
        <button id="fuzzyRunCross" type="button" class="secondary-btn" title="Compare the selected columns across the primary and secondary datasets" style="margin-left:auto">Compare A↔B</button>
      </div>
      <div id="fuzzyCrossResults" class="small" style="margin-top:8px"></div>
    </section>


    <!-- Column Profiles -->
    <section class="card" id="profilesSection">
      <h2 title="Detailed analysis of each column with AI pattern detection - see data types, patterns, statistics, and quality rules">Field Overview <span class="collapse-toggle" role="button" aria-label="Collapse section" title="Collapse or expand this section">▼</span></h2>
      <!-- Field Analysis action buttons: moved from the top navigation bar. Align to the right inside the panel. -->
      <div class="field-actions" style="display:flex;justify-content:flex-end;margin-top:-4px;margin-bottom:12px;gap:6px;flex-wrap:wrap">
        <button id="navSaveRules" type="button" class="field-btn" title="💾 Save your data quality rules so they're remembered next time you open this file">Save Rules</button>
        <button id="navDownloadRules" type="button" class="field-btn" title="📄 Download your data quality rules to share with others or backup">Download Rules</button>
        <button id="navClearRules" type="button" class="field-btn" title="🗑️ Remove your saved rules and start fresh (doesn't change your data)">Clear Rules</button>
        <button id="navRunRules" type="button" class="field-btn" title="🔍 Check your data for problems and highlight any issues">Run Checks</button>
        <button id="quickExportSummary" type="button" class="field-btn" title="Export detailed data dictionary with field statistics">Export Report</button>
      </div>
      <div class="small muted" style="margin-bottom:8px">Click headers to sort. Allowed values fields accept comma‑separated lists. Rule issues appear after running checks.</div>
      <div style="overflow:auto">
        <table id="profileTable">
          <thead>
            <tr>
              <th>Column</th>
              <th>Type</th>
              <th class="nowrap">Non‑null</th>
              <th class="nowrap">Nulls</th>
              <th>Coverage</th>
              <th>Unique</th>
              <th>Min</th>
              <th>Max</th>
              <th>Mean</th>
              <th>Outliers</th>
              <th>Examples</th>
              <th>Patterns</th>
              <th>Expected</th>
              <th style="min-width:180px">Allowed set</th>
              <th>Rule issues</th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>
      </div>
    </section>
    <!-- Invalid rows -->
    <section class="card" id="invalidSection">
      <h2 title="Rows that have data quality issues will appear here for review">Rows with Issues <span class="collapse-toggle" role="button" aria-label="Collapse section" title="Collapse or expand this section">▼</span></h2>
      <div id="invalidSummary" class="small muted">No rule checks run yet.</div>
      <div id="invalidTableWrap" style="overflow:auto;margin-top:8px"></div>
    </section>
  </div>


  <!-- Merge Files modal (hidden by default) -->
  <div id="mergeModal" class="modal hidden">
    <div class="modal-content">
      <h3>Merge Files</h3>
      <p class="small muted">Merge the currently loaded dataset with another CSV/TSV/Excel file. Choose the key columns and optionally convert Salesforce IDs to 18 characters for matching.</p>
      <div id="mergeStepFile">
        <label class="small" for="mergeFileInput">Select file to merge:</label>
        <input type="file" id="mergeFileInput" accept=".csv,.tsv,.xlsx,.xls,text/csv,text/tab-separated-values,application/vnd.openxmlformats-officedocument.spreadsheetml.sheet,application/vnd.ms-excel" style="display:block;margin-top:4px;margin-bottom:12px">
      </div>
      <div id="mergeStepOptions" style="display:none;">
        <label class="small" style="display:block;margin-top:8px">Primary dataset key:</label>
        <select id="mergePrimaryCol" style="width:100%;margin-bottom:8px"></select>
        <label class="small" style="display:block;margin-top:4px">Second dataset key:</label>
        <select id="mergeSecondaryCol" style="width:100%;margin-bottom:8px"></select>
        <label class="small" style="display:block;margin-top:4px"><input type="checkbox" id="mergeConvertIds" style="margin-right:4px">Convert 15‑char Salesforce IDs to 18‑char</label>
        <label class="small" style="display:block;margin-top:4px">Join type:</label>
        <select id="mergeJoinType" style="width:100%;margin-bottom:12px">
          <option value="left">Left (keep all primary rows)</option>
          <option value="inner">Inner (only rows with matches)</option>
                  <option value="right">Right (keep all secondary rows)</option>
          <option value="full">Full (keep all rows)</option>
        </select>
      </div>
      <div class="modal-buttons" style="margin-top:12px">
        <button id="mergeDo" type="button" disabled>Merge &amp; Download</button>
        <button id="mergeCancel" type="button">Cancel</button>
      </div>
    </div>
  </div>

  <!-- Help & Documentation modal (hidden by default) -->
  <div id="helpModal" class="modal hidden">
    <div class="modal-content">
      <h3>
        <!-- Repeat the logo next to the Help title for a cohesive brand feel -->
        <span class="logo" aria-hidden="true" title="DATAPHREAK logo">
          <svg width="22" height="22" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg">
            <rect x="3"  y="10" width="4" height="11" rx="1"></rect>
            <rect x="10" y="6"  width="4" height="15" rx="1"></rect>
            <rect x="17" y="2"  width="4" height="19" rx="1"></rect>
          </svg>
        </span>
        Help &amp; Documentation
      </h3>
      <!-- Index of help topics: click to jump to section -->
      <nav class="help-index" aria-label="Help topics" style="margin-bottom:16px">
        <!-- Start Here Button -->
        <div style="margin-bottom:12px">
          <a href="#help-start" class="help-tab" style="background:#22c55e;color:white;font-weight:bold;font-size:16px;padding:8px 16px"><strong>START HERE</strong> 🚀 Getting Started</a>
        </div>
        
        <!-- Basics Section -->
        <div class="help-section" style="margin-bottom:12px">
          <div style="color:#38bdf8;font-size:12px;font-weight:bold;margin-bottom:6px;padding-left:4px">📋 BASICS</div>
          <div style="display:flex;flex-wrap:wrap;gap:6px">
            <a href="#help-loading" class="help-tab" style="border-color:#38bdf8"><strong>1.</strong> Loading Your Data</a>
            <a href="#help-summary" class="help-tab" style="border-color:#38bdf8"><strong>2.</strong> Understanding Results</a>
            <a href="#help-histograms" class="help-tab" style="border-color:#38bdf8"><strong>3.</strong> Data Visualizations</a>
            <a href="#help-ops" class="help-tab" style="border-color:#38bdf8"><strong>4.</strong> Quick Data Cleaning</a>
            <a href="#help-exports" class="help-tab" style="border-color:#38bdf8"><strong>5.</strong> Saving Your Work</a>
          </div>
        </div>
        
        <!-- Analysis Section -->
        <div class="help-section" style="margin-bottom:12px">
          <div style="color:#f59e0b;font-size:12px;font-weight:bold;margin-bottom:6px;padding-left:4px">📊 ANALYSIS</div>
          <div style="display:flex;flex-wrap:wrap;gap:6px">
            <a href="#help-quality" class="help-tab" style="border-color:#f59e0b"><strong>6.</strong> AI Quality Assessment</a>
            <a href="#help-duplicates" class="help-tab" style="border-color:#f59e0b"><strong>7.</strong> AI Duplicate Detection</a>
            <a href="#help-patterns" class="help-tab" style="border-color:#22c55e"><strong>8.</strong> 🤖 AI Pattern Detection</a>
            <a href="#help-field" class="help-tab" style="border-color:#f59e0b"><strong>9.</strong> Column Analysis</a>
            <a href="#help-rules" class="help-tab" style="border-color:#f59e0b"><strong>10.</strong> Data Validation</a>
            <a href="#help-keys" class="help-tab" style="border-color:#f59e0b"><strong>11.</strong> Unique Identifiers</a>
          </div>
        </div>
        
        <!-- Advanced Section -->
        <div class="help-section" style="margin-bottom:8px">
          <div style="color:#8b5cf6;font-size:12px;font-weight:bold;margin-bottom:6px;padding-left:4px">⚙️ ADVANCED</div>
          <div style="display:flex;flex-wrap:wrap;gap:6px">
            <a href="#help-fuzzy" class="help-tab" style="border-color:#8b5cf6"><strong>11.</strong> Compare Files</a>
            <a href="#help-merge" class="help-tab" style="border-color:#8b5cf6"><strong>12.</strong> Merge Files</a>
            <a href="#help-settings" class="help-tab" style="border-color:#8b5cf6"><strong>13.</strong> Settings</a>
            <a href="#help-keyboard" class="help-tab" style="border-color:#8b5cf6"><strong>14.</strong> Shortcuts</a>
            <a href="#help-security" class="help-tab" style="border-color:#8b5cf6"><strong>15.</strong> Security</a>
            <a href="#help-legal" class="help-tab" style="border-color:#8b5cf6"><strong>16.</strong> Legal</a>
          </div>
        </div>
      </nav>
      <div class="help-body" style="max-height:60vh;overflow-y:auto">
        <p>Welcome to <strong>DATAPHREAK</strong>, your comprehensive data analysis and cleaning tool. This guide covers all features and capabilities.</p>
        
        <h4 id="help-start" style="color:#22c55e;border-left:4px solid #22c55e;padding-left:12px">🚀 Getting Started - Your First 5 Minutes</h4>
        <div style="background:rgba(34,197,94,0.1);padding:16px;border-radius:8px;margin:12px 0">
          <p><strong>New to DATAPHREAK?</strong> Follow this quick walkthrough to get started immediately!</p>
          
          <h5 style="color:#22c55e;margin:16px 0 8px 0">📊 Step 1: Try Sample Data (30 seconds)</h5>
          <p>• Click the <strong>"✨ Try Sample Data"</strong> button in the Load Data section<br>
          • This loads 400 rows of customer data with some intentional issues to explore<br>
          • Perfect for learning without uploading your own files</p>
          
          <h5 style="color:#22c55e;margin:16px 0 8px 0">👀 Step 2: See Your Data Overview (1 minute)</h5>
          <p>• Check the <strong>KPI cards</strong> that appear - they show row count, columns, missing values, and duplicates<br>
          • Look for the <strong>Data Quality Score</strong> - higher is better!<br>
          • Notice the <strong>Quick Actions</strong> like "Analyze All" and "Quick Fix"</p>
          
          <h5 style="color:#22c55e;margin:16px 0 8px 0">📈 Step 3: Visualize Your Data (1 minute)</h5>
          <p>• Click the <strong>"Histograms"</strong> button to see beautiful charts<br>
          • Hover over bars to see exact counts and percentages<br>
          • Age data automatically groups into 5-year ranges</p>
          
          <h5 style="color:#22c55e;margin:16px 0 8px 0">🧹 Step 4: Clean Your Data (2 minutes)</h5>
          <p>• Click <strong>"🧹 Clean All"</strong> for AI-powered instant cleaning<br>
          • Or go to <strong>"Data Operations"</strong> section to choose specific fixes<br>
          • Watch the data quality score improve!</p>
          
          <h5 style="color:#22c55e;margin:16px 0 8px 0">💾 Step 5: Export Results (30 seconds)</h5>
          <p>• Use <strong>"Export"</strong> to download your cleaned data<br>
          • Choose CSV, JSON, or create a Data Dictionary report<br>
          • Files are automatically named based on operations performed</p>
          
          <div style="background:rgba(34,197,94,0.2);padding:12px;border-radius:6px;margin:16px 0">
            <p><strong>🎯 Pro Tip:</strong> Start with sample data to learn, then upload your own CSV files. Everything happens locally in your browser - your data never leaves your computer!</p>
          </div>
          
          <p><strong>Ready to dive deeper?</strong> Continue reading the sections below, or jump to any topic using the navigation above.</p>
        </div>

        <h4 id="help-loading">1. Loading Your Data</h4>
        <p><strong>Getting your files into DATAPHREAK is easy!</strong></p>
        <ul>
          <li><strong>Drag &amp; Drop:</strong> Simply drag your CSV or TSV file into the gray drop zone</li>
          <li><strong>Browse Files:</strong> Click "Choose File" to select from your computer</li>
          <li><strong>Try Sample Data:</strong> Click "✨ Try Sample Data" to practice with example data first</li>
        </ul>
        <div style="background:rgba(56,189,248,0.1);padding:12px;border-radius:6px;margin:12px 0">
          <p><strong>💡 File Requirements:</strong><br>
          • First row should contain column names (like: Name, Email, Age)<br>
          • CSV files work best, but TSV (tab-separated) files work too<br>
          • Excel files need to be saved as CSV first</p>
        </div>
        
        <h4 id="help-summary">2. Understanding Your Results</h4>
        <p><strong>Once your data loads, here's what you'll see:</strong></p>
        <ul>
          <li><strong>KPI Cards:</strong> Quick stats showing total rows, columns, missing values, and duplicate records</li>
          <li><strong>Data Quality Score:</strong> AI-powered assessment (0-100%) measuring completeness, consistency, and pattern validity with A-F grading</li>
          <li><strong>Quick Actions:</strong> One-click buttons for common tasks:
            <ul style="margin:8px 0 0 20px">
              <li><strong>Analyze All:</strong> Deep-dive into every column</li>
              <li><strong>Clean All:</strong> AI-powered cleaning that auto-corrects emails, phones, and dates</li>
              <li><strong>Health Check:</strong> Get a detailed data quality report</li>
            </ul>
          </li>
        </ul>
        <div style="background:rgba(56,189,248,0.1);padding:12px;border-radius:6px;margin:12px 0">
          <p><strong>🎯 What's a good quality score?</strong><br>
          • 90-100%: Excellent - very clean data<br>
          • 80-89%: Good - minor issues to fix<br>
          • 70-79%: Fair - several problems to address<br>
          • Below 70%: Needs significant cleaning</p>
        </div>
        <h4 id="help-quality">AI-Powered Data Quality Assessment</h4>
        <p>Comprehensive quality scoring that analyzes your entire dataset:</p>
        <ul>
          <li><strong>Overall Score:</strong> 0-100% assessment with letter grades (A-F) like a report card</li>
          <li><strong>Completeness:</strong> How much of your data is filled vs missing</li>
          <li><strong>Consistency:</strong> Measures duplicate rows and data conflicts</li>
          <li><strong>Validity:</strong> Checks if data follows expected patterns (emails, phones, dates)</li>
          <li><strong>Visual Indicators:</strong> Color-coded quality cards (green = good, red = needs work)</li>
          <li><strong>Actionable Insights:</strong> Shows exactly what needs attention</li>
          <li><strong>Real-time Updates:</strong> Quality score improves as you clean your data</li>
        </ul>
        <h4 id="help-duplicates">AI-Powered Duplicate Detection</h4>
        <p>Advanced duplicate detection that goes beyond basic matching:</p>
        <ul>
          <li><strong>Exact Duplicates:</strong> Finds rows that are completely identical across all fields</li>
          <li><strong>Fuzzy Duplicates:</strong> AI similarity matching finds near-duplicates like "John Smith" vs "Jon Smith"</li>
          <li><strong>Smart Export:</strong> CSV includes both exact_duplicate_group and fuzzy_duplicate_group columns</li>
          <li><strong>Performance Optimized:</strong> Handles large datasets with chunked processing</li>
          <li><strong>Visual Grouping:</strong> Clear separation between exact matches and similar records</li>
          <li><strong>Row References:</strong> Shows exact row numbers for easy verification in Excel</li>
        </ul>
        <h4 id="help-field">Field Analysis & Profiling</h4>
        <p>Detailed analysis for each column in your data with AI pattern detection:</p>
        <ul>
          <li><strong>Data Types:</strong> Number, date, boolean, string with confidence scores</li>
          <li><strong>AI Patterns:</strong> Automatically detects emails, phone numbers, and dates with confidence indicators</li>
          <li><strong>Pattern Confidence:</strong> Green = high confidence, yellow = partial match, gray = low confidence</li>
          <li><strong>Coverage:</strong> Percentage of filled vs missing values</li>
          <li><strong>Uniqueness:</strong> How many different values appear in each column</li>
          <li><strong>Number Analysis:</strong> Minimum, maximum, average, and unusual values</li>
          <li><strong>Date Ranges:</strong> Earliest and latest dates in date columns</li>
          <li><strong>Text Analysis:</strong> Character length patterns and text formatting details</li>
          <li><strong>Sample Values:</strong> Representative examples from each column</li>
        </ul>

        <h4 id="help-patterns">🤖 AI Pattern Detection</h4>
        <p>Intelligent recognition and standardization of common data formats:</p>
        <ul>
          <li><strong>Email Detection:</strong> Automatically identifies and standardizes email addresses to lowercase</li>
          <li><strong>Phone Numbers:</strong> Recognizes various phone formats and standardizes to consistent formatting</li>
          <li><strong>Date Intelligence:</strong> Handles mixed international date formats (US, European, ISO) and converts to YYYY-MM-DD</li>
          <li><strong>Smart Confidence:</strong> Shows green (high), yellow (partial), or gray (low) confidence indicators</li>
          <li><strong>Auto-Correction:</strong> Clean All button applies pattern-based fixes automatically</li>
          <li><strong>International Support:</strong> Properly handles global phone and date formats</li>
          <li><strong>Column Intelligence:</strong> Uses column names for better pattern prioritization</li>
        </ul>

        <h4 id="help-histograms">Data Distribution Histograms</h4>
        <p>Professional-grade interactive charts accessible via the <strong>Histograms</strong> button:</p>
        <ul>
          <li><strong>Smart Binning:</strong> Automatic age grouping (5-year ranges) and intelligent numeric binning</li>
          <li><strong>Visual Features:</strong> Gradient colors, grid lines, Y-axis labels with professional styling</li>
          <li><strong>Statistical Overlays:</strong> Mean (μ) and median (M) lines with exact values displayed</li>
          <li><strong>Interactive Tooltips:</strong> Hover for exact counts, ranges, and percentages</li>
          <li><strong>Color Coding:</strong> Frequency-based colors (red=high frequency, blue=low frequency)</li>
          <li><strong>Categorical Charts:</strong> Top 10 values for text columns with horizontal bars</li>
          <li><strong>Smooth Animations:</strong> Loading transitions and hover effects for enhanced user experience</li>
          <li><strong>Print Function:</strong> Export histograms to PDF with professional formatting</li>
          <li><strong>Responsive Design:</strong> Charts automatically scale from 580px to 1160px based on screen size</li>
          <li><strong>Age Detection:</strong> Automatically formats age data with meaningful 5-year groupings</li>
        </ul>

        <h4 id="help-rules">Validation Rules & Quality Checks</h4>
        <p>Define and enforce data quality standards:</p>
        <ul>
          <li><strong>Allowed Values:</strong> Comma-separated lists of valid values per column</li>
          <li><strong>Pattern Matching:</strong> Custom rules for complex data validation</li>
          <li><strong>Rule Persistence:</strong> Automatically saves rules using column header signatures</li>
          <li><strong>Issue Detection:</strong> Highlights cells that don't match your rules</li>
          <li><strong>Issue Reporting:</strong> "Rows with Issues" section shows problematic data</li>
          <li><strong>Batch Processing:</strong> Apply rules across entire datasets efficiently</li>
        </ul>

        <h4 id="help-exports">Export Options</h4>
        <p>Multiple export formats and customization options:</p>
        <ul>
          <li><strong>CSV Export:</strong> Standard comma-separated format with proper escaping</li>
          <li><strong>JSON Export:</strong> Array of objects with column headers as keys</li>
          <li><strong>Data Dictionary:</strong> Complete field definitions with statistics and rules</li>
          <li><strong>Enhanced Duplicate Exports:</strong> Includes both exact_duplicate_group and fuzzy_duplicate_group columns for comprehensive review</li>
          <li><strong>Histogram Printing:</strong> Professional PDF reports of distribution charts</li>
          <li><strong>Security:</strong> Formula injection protection (prefixes dangerous characters)</li>
          <li><strong>File Naming:</strong> Intelligent naming based on operations performed</li>
        </ul>
        
        <h4 id="help-fuzzy">11. Compare Files (Find Similar Records)</h4>
        <p><strong>Have two files with similar but not identical data?</strong> This feature helps you find matching records across files.</p>
        
        <h5 style="color:#8b5cf6;margin:16px 0 8px 0">📋 Common Use Cases:</h5>
        <ul>
          <li><strong>Customer Lists:</strong> Find "John Smith" in file A that matches "Jon Smith" in file B</li>
          <li><strong>Email Variations:</strong> Match "j.smith@company.com" with "john.smith@company.com"</li>
          <li><strong>Company Names:</strong> Find "ABC Corp" that matches "ABC Corporation"</li>
        </ul>
        
        <h5 style="color:#8b5cf6;margin:16px 0 8px 0">🔧 How to Use:</h5>
        <p><strong>Step 1:</strong> Load your first file (becomes your "primary" dataset)<br>
        <strong>Step 2:</strong> Use "Merge Files" to load a second file (becomes "secondary")<br>
        <strong>Step 3:</strong> Choose which columns to compare between the files<br>
        <strong>Step 4:</strong> Set similarity level (0.80 = very similar, 0.50 = somewhat similar)<br>
        <strong>Step 5:</strong> Click "Compare A↔B" to find matches</p>
        
        <div style="background:rgba(139,92,246,0.1);padding:12px;border-radius:6px;margin:12px 0">
          <p><strong>⚡ Performance Note:</strong> To keep your browser responsive, we limit comparisons for very large files. If you see a message about too many comparisons, try increasing the similarity setting or working with smaller datasets.</p>
        </div>
<h4 id="help-merge">Cross‑File Merging &amp; ID Matching</h4>
        <p>The <em>Merge Files</em> feature allows combining the loaded dataset with another CSV or TSV file. Choose key columns from each dataset, select a join type (Left, Inner, Right or Full) and optionally enable Salesforce ID conversion for matching. The merged output is downloaded automatically and the second file persists in memory as your <strong>secondary dataset</strong> for subsequent cross‑file analysis. You can switch between the primary and secondary datasets via the dataset selector next to the dataset name.</p>
        <h4 id="help-themes">Themes</h4>
        <p>Use the theme button to toggle between Dark, Light, and Matrix modes. Your selection is saved locally and persists between sessions.</p>

        <!-- Settings & Preferences section -->
        <h4 id="help-settings">Settings &amp; Preferences</h4>
        <p>Open the <em>Settings</em> panel from the top navigation to customise DATAPHREAK. From this modal you can:</p>
        <ul>
          <li><strong>Choose a theme</strong> – Dark, Light and Matrix Mode styles are available.</li>
          <li><strong>Select default cleaning operations</strong> – decide which actions (trim spaces, fix letter case, remove accents and convert Salesforce IDs) are pre‑selected when you open the <em>Data Cleaning &amp; IDs</em> panel.</li>
          <li><strong>Pick your language</strong> – switch the interface language once translations are available.</li>
          <li><strong>Enable or disable persistence</strong> – save preferences and rules to your browser’s local storage or opt to discard them on page reload.</li>
          <li><strong>Encrypt local data</strong> – optionally protect your preferences and rules with a passphrase using in‑browser AES‑GCM encryption.</li>
        </ul>
        <p>Your preferences are stored locally only and never sent to a server. If persistence is disabled, settings revert to defaults when the page is refreshed.</p>
        <h4 id="help-keyboard">Keyboard Navigation</h4>
        <p>You can tab through inputs and use keyboard shortcuts like <kbd>Ctrl+L</kbd> to reload the file or <kbd>Esc</kbd> to close modals. Most buttons also display an informative tooltip when hovered.</p>

        <h4 id="help-ops">4. Quick Data Cleaning</h4>
        <p><strong>Fix common data problems with one click!</strong> Select columns and choose which fixes to apply:</p>
        
        <h5 style="color:#38bdf8;margin:16px 0 8px 0">🧹 Available Cleaning Options:</h5>
        <ul>
          <li><strong>Trim Spaces:</strong> Removes extra spaces before/after text
            <br><em>Example: "  John Smith  " becomes "John Smith"</em></li>
          <li><strong>Fix Letter Case:</strong> Smart formatting based on field type
            <br><em>Names → Title Case, Emails → lowercase, IDs → UPPERCASE</em></li>
          <li><strong>Remove Accents:</strong> Converts special characters to regular letters
            <br><em>Example: "José" becomes "Jose"</em></li>
          <li><strong>Convert Salesforce IDs:</strong> Extends 15-character IDs to 18-character format
            <br><em>Useful if you work with Salesforce data</em></li>
        </ul>
        
        <h5 style="color:#38bdf8;margin:16px 0 8px 0">🚀 Quick Start:</h5>
        <p><strong>Step 1:</strong> Click checkboxes next to columns you want to clean<br>
        <strong>Step 2:</strong> Choose which operations to apply<br>
        <strong>Step 3:</strong> Click "Apply" to clean your data<br>
        <strong>Step 4:</strong> Watch your data quality score improve!</p>
        
        <div style="background:rgba(56,189,248,0.1);padding:12px;border-radius:6px;margin:12px 0">
          <p><strong>💡 Pro Tip:</strong> Use "🧹 Clean All" button for AI-powered instant cleaning that auto-corrects email, phone, and date formats, or customize specific operations below.</p>
        </div>

        <!-- Unique keys section moved outside of Data Operations -->

        <h4 id="help-keys">Unique Keys &amp; IDs</h4>
        <p>The assistant in the <strong>Data Cleaning &amp; IDs</strong> panel helps you find one or two fields that can uniquely identify each row. It scans for fields or field pairs with no missing values and no duplicates. These are ideal as primary keys or External IDs. If none exist, the assistant offers to add a new <code>surrogate_id</code> column with sequential values.</p>

        <!-- Security & Privacy section -->
        <h4 id="help-security">Security &amp; Privacy</h4>
        <p>DATAPHREAK is designed to keep your data private and secure. All processing happens locally in your browser&mdash;no network calls are made. This section summarises the key security measures:</p>
        <ul>
          <li><strong>Offline‑only operation</strong>: your datasets never leave your computer.</li>
          <li><strong>Sanitised exports</strong>: exported CSV values are escaped to prevent formula injection and malicious scripts; cells that begin with <code>=</code>, <code>+</code>, <code>-</code>, or <code>@</code> are prefixed with a single quote to turn them into plain text.</li>
          <li><strong>No macros or scripting engine</strong>: unlike traditional spreadsheets, DATAPHREAK has no macro support, eliminating a major attack vector.</li>
          <li><strong>Strict Content Security Policy</strong>: the page is served with a Content Security Policy that blocks inline and remote scripts.</li>
          <li><strong>Cross‑file comparison cap</strong>: approximate matching across files is capped at ~200,000 comparisons with lightweight blocking to prevent browser lock‑ups.</li>
          <li><strong>Error handling</strong>: file parsing is wrapped in <code>try</code>/<code>catch</code> blocks with friendly error messages.</li>
          <li><strong>Local persistence</strong>: rule sets and preferences are stored only in your browser’s <code>localStorage</code>; nothing is uploaded to any server. You can disable persistence entirely or encrypt your saved data with a passphrase in the Settings panel.</li>
        </ul>



        <h4 id="help-legal">Legal Notice</h4>
        <p>This tool is currently in beta and is provided “as is” without warranty of any kind. It was created and is owned by Zachary Sluss. During the beta period it is made available as open source. For inquiries, contact <a href="mailto:zacsluss@yahoo.com">zacsluss@yahoo.com</a>.</p>

      </div>
      <div class="modal-buttons" style="margin-top:12px">
        <button id="devLogOpen" type="button" style="margin-right: auto;">Dev Log</button>
        <button id="helpClose" type="button">Close</button>
      </div>
    </div>
  </div>
  <!-- Settings modal (hidden by default) -->
  <div id="settingsModal" class="modal hidden" role="dialog" aria-modal="true" aria-labelledby="settingsTitle">
    <div class="modal-content">
      <h3 id="settingsTitle">Settings</h3>
      <div class="row" style="flex-direction:column;gap:8px">
        <label>Theme
          <select id="prefTheme">
            <option value="dark">Dark</option>
            <option value="light">Light</option>
            <option value="matrix">Matrix Mode</option>
          </select>
        </label>
        <fieldset>
          <legend class="small muted">Default operations</legend>
          <label class="small"><input type="checkbox" id="prefTrim"> Trim spaces</label>
          <label class="small"><input type="checkbox" id="prefNormalize"> Fix letter case</label>
          <label class="small"><input type="checkbox" id="prefClean"> Remove accents</label>
          <label class="small"><input type="checkbox" id="prefSf"> Convert SF IDs</label>
        </fieldset>
        <label>Language
          <select id="prefLang">
            <option value="en">English</option>
            <option value="es">Español</option>
          </select>
        </label>
        <label class="small"><input type="checkbox" id="prefPersist"> Enable persistence (localStorage)</label>
        <label class="small"><input type="checkbox" id="prefEncrypt"> Encrypt saved data</label>
        <label>Password <input type="password" id="prefPass" placeholder="Optional passphrase"></label>
      </div>
      <div class="modal-buttons" style="margin-top:12px">
        <button id="settingsSave" type="button">Save</button>
        <button id="settingsCancel" type="button">Cancel</button>
      </div>
    </div>
  </div>

  <!-- Dev Log modal (hidden by default) -->
  <div id="devLogModal" class="modal hidden" role="dialog" aria-modal="true" aria-labelledby="devLogTitle">
    <div class="modal-content">
      <h3 id="devLogTitle">Development Log</h3>
      <div class="help-body" style="max-height:60vh;overflow-y:auto">
        <p>Development history and feature updates for <strong>DATAPHREAK</strong>:</p>
        
        <h4>v0.8.0 (Current)</h4>
        <ul>
          <li><strong>Revolutionary Help System Redesign</strong>: Complete transformation of user documentation for optimal new user experience:
            <ul>
              <li><strong>🚀 Getting Started Section</strong>: Brand new 5-minute walkthrough with step-by-step instructions for immediate user success</li>
              <li><strong>📋 Logical Navigation Structure</strong>: Reorganized from beginner → advanced with color-coded sections (Basics/Analysis/Advanced)</li>
              <li><strong>🎯 Plain English Content</strong>: Replaced technical jargon with user-friendly explanations and real-world examples</li>
              <li><strong>📊 Visual Enhancement</strong>: Added icons, step-by-step guides, Pro Tips, and helpful callout boxes throughout</li>
              <li><strong>🔧 Improved Navigation Pills</strong>: Fixed clustered layout with proper spacing, responsive design, and smooth hover animations</li>
            </ul>
          </li>
          <li><strong>Complete Hover Tooltip Enhancement</strong>: Comprehensive tooltip system overhaul for superior user guidance:
            <ul>
              <li><strong>✅ 100% Coverage</strong>: Added tooltips to every interactive element including buttons, inputs, selects, and navigation items</li>
              <li><strong>🎨 Visual Consistency</strong>: Standardized all tooltips with emojis, friendly language, and contextual examples</li>
              <li><strong>📝 Beginner-Friendly Language</strong>: Replaced technical terms with plain English and added "what this does" explanations</li>
              <li><strong>🎯 Contextual Help</strong>: Each tooltip provides immediate value with examples like "e.g., '  John  ' becomes 'John'"</li>
            </ul>
          </li>
          <li><strong>Professional Icon Integration</strong>: Custom data analytics favicon for brand identity:
            <ul>
              <li><strong>📊 Data-Themed Design</strong>: Custom icon featuring data charts and analytics symbols in your brand colors</li>
              <li><strong>🔄 Universal Compatibility</strong>: Professional favicon that displays perfectly in all modern browsers</li>
              <li><strong>💾 Self-Contained</strong>: No external dependencies - everything works offline without internet connection</li>
              <li><strong>🎨 Theme Coordination</strong>: Icon automatically matches your chosen theme colors for consistent branding</li>
            </ul>
          </li>
          <li><strong>Enhanced User Experience</strong>: Streamlined interface improvements for better workflow efficiency:
            <ul>
              <li><strong>🎯 Intuitive Navigation</strong>: Improved button layouts and consistent visual design throughout the application</li>
              <li><strong>⚡ Faster Workflow</strong>: Optimized performance and reduced loading times for smoother data processing</li>
              <li><strong>🛡️ Enhanced Security</strong>: Improved data protection and privacy safeguards for sensitive information</li>
              <li><strong>📱 Better Responsiveness</strong>: Enhanced mobile and tablet compatibility for on-the-go data analysis</li>
            </ul>
          </li>
        </ul>

        <h4>v0.6.1</h4>
        <ul>
          <li><strong>Professional-Grade Data Visualization</strong>: Revolutionary histogram system with enterprise-level features:
            <ul>
              <li>Interactive data distribution charts with hover tooltips showing exact counts, ranges, and percentages</li>
              <li>Intelligent data grouping including automatic age ranges (5-year groups) and smart number categories</li>
              <li>Statistical overlays with mean (μ) and median (M) lines displayed with exact values</li>
              <li>Frequency-based color coding system (red=high frequency, blue=low frequency)</li>
              <li>Beautiful gradient fills and professional grid lines with Y-axis labels</li>
              <li>Smooth loading animations and staggered bar transitions for enhanced user experience</li>
            </ul>
          </li>
          <li><strong>Enhanced Export Capabilities</strong>: Dual-format export system with improved usability:
            <ul>
              <li>JSON export functionality converting rows to objects with headers as keys</li>
              <li>Separate CSV and JSON download buttons with intuitive icons</li>
              <li>Professional PDF histogram printing with formatted layouts</li>
              <li>Formula injection protection for all export formats</li>
            </ul>
          </li>
          <li><strong>Comprehensive Help Documentation</strong>: Complete documentation overhaul with:
            <ul>
              <li>16 organized sections covering all features and capabilities</li>
              <li>Dedicated histogram documentation with detailed feature explanations</li>
              <li>Enhanced navigation with logical categorization and improved discoverability</li>
              <li>Professional documentation standards with consistent formatting and user-friendly language</li>
            </ul>
          </li>
          <li><strong>Responsive Design Excellence</strong>: Advanced scalability and user interface improvements:
            <ul>
              <li>Histogram charts automatically scale from 580px to 1160px based on screen size</li>
              <li>Improved age data detection and specialized formatting</li>
              <li>Enhanced categorical data visualization with top 10 value horizontal bars</li>
              <li>Professional modal layouts with optimized space utilization</li>
            </ul>
          </li>
        </ul>

        <h4>v0.6.0</h4>
        <ul>
          <li><strong>Complete Theme System Overhaul</strong>: Achieved perfect visual parity across all themes with:
            <ul>
              <li>Enhanced Light Theme with golden accent animations, particle system, and comprehensive visual effects</li>
              <li>Dark Mode cosmic dust particle system with purple accent theme conversion</li>
              <li>Matrix Mode particle system optimization and consistency improvements</li>
              <li>Uniform accent gradient coverage across all button types in all themes</li>
              <li>Perfect particle masking and visibility controls across all themes</li>
            </ul>
          </li>
          <li><strong>Advanced Particle Systems</strong>: Implemented three unique particle effects with:
            <ul>
              <li>Light Theme: Golden glowing sparkles with gentle rising animation</li>
              <li>Dark Theme: Purple cosmic dust with natural falling patterns</li>
              <li>Matrix Theme: Enhanced digital rain effects with smooth performance</li>
              <li>Intelligent positioning ensuring visual effects appear in the right places</li>
              <li>Consistent visual effects and controls across all available themes</li>
            </ul>
          </li>
          <li><strong>Visual Consistency Excellence</strong>: Perfect theme uniformity including:
            <ul>
              <li>Standardized glow effects, hover animations, and interaction feedback</li>
              <li>Enhanced button gradients with translucent accent color treatments</li>
              <li>Improved border visibility and separator line consistency</li>
              <li>Fixed collapsible card functionality across all header structures</li>
              <li>Universal green dropzone styling with enhanced hover effects</li>
            </ul>
          </li>
        </ul>
        
        <h4>v0.5.4</h4>
        <ul>
          <li><strong>Interface Flow Optimization</strong>: Perfect logical organization including:
            <ul>
              <li>Reordered Data Cleaning section for optimal workflow: Field Selection → Custom Operations → Apply Changes → Quick Actions</li>
              <li>Positioned Apply Changes button directly below Custom Operations checkboxes for clear visual connection</li>
              <li>Moved Quick Actions below Apply Changes to separate preset utilities from custom operations</li>
              <li>Clear task separation making it easy to understand: configure → apply → use utilities</li>
              <li>Improved workflow reducing confusion about which buttons to use when</li>
            </ul>
          </li>
          <li><strong>User Experience Excellence</strong>: Streamlined interface design with:
            <ul>
              <li>Perfect logical grouping of related functions for intuitive workflows</li>
              <li>Reduced cognitive load with visually connected operation configuration and execution</li>
              <li>Clear distinction between custom operations and preset quick actions</li>
              <li>Enhanced usability through optimal button placement and visual hierarchy</li>
            </ul>
          </li>
        </ul>
        
        <h4>v0.5.3</h4>
        <ul>
          <li><strong>UI/UX Enhancements</strong>: Major interface improvements including:
            <ul>
              <li>Reorganized Data Cleaning & IDs section with expanded Quick Actions (5 buttons)</li>
              <li>Moved Analyze Keys and Add ID Column to Quick Actions for better accessibility</li>
              <li>Added Download button to Quick Actions for streamlined workflow</li>
              <li>Simplified bottom action area to focus on Apply Changes functionality</li>
              <li>Improved visual balance with evenly distributed quick action buttons</li>
            </ul>
          </li>
          <li><strong>User Experience</strong>: Enhanced workflow optimization with:
            <ul>
              <li>More intuitive button grouping: instant actions vs. custom operations</li>
              <li>Reduced scrolling with key tools prominently placed in Quick Actions</li>
              <li>Faster access to critical data preparation features</li>
              <li>Cleaner, more organized interface with logical button placement</li>
            </ul>
          </li>
        </ul>
        
        <h4>v0.5.2</h4>
        <ul>
          <li><strong>Code Cleanup & Optimization</strong>: Major codebase improvements including:
            <ul>
              <li>Removed all orphaned code and unused event handlers for better performance</li>
              <li>Eliminated test code from production export functions</li>
              <li>Removed unused metadata functionality (~120 lines of dead code)</li>
              <li>Cleaned up navigation proxy handlers for non-existent elements</li>
              <li>Streamlined validation system to focus on user-defined rules</li>
            </ul>
          </li>
          <li><strong>UI/UX Improvements</strong>: Enhanced user experience with:
            <ul>
              <li>Reordered sections for better workflow: Data Cleaning now appears before Duplicate Analysis</li>
              <li>Removed unused table columns and simplified interface</li>
              <li>Improved logical flow from data loading → cleaning → analysis → validation</li>
              <li>Enhanced export functionality with cleaner output (no test messages)</li>
            </ul>
          </li>
        </ul>
        
        <h4>v0.5.1</h4>
        <ul>
          <li><strong>Bug Fixes & Code Quality</strong>: Critical fixes and improvements including:
            <ul>
              <li>Fixed canvas null reference error that prevented file loading</li>
              <li>Added missing event listeners for Dataset Overview quick action buttons</li>
              <li>Improved null safety with optional chaining for all DOM element access</li>
              <li>Replaced loose equality checks with strict equality for better type safety</li>
              <li>Removed debug console.log statements for cleaner production code</li>
            </ul>
          </li>
          <li><strong>UI Streamlining</strong>: Simplified interface with:
            <ul>
              <li>Removed unused heatmap visualization system to focus on core analysis features</li>
              <li>Streamlined Data Quality section to Column Analysis and Quality Statistics views</li>
              <li>Fixed dual-file loading system to properly support primary and secondary datasets</li>
              <li>Enhanced user feedback with improved toast messages and error handling</li>
            </ul>
          </li>
        </ul>
        
        <h4>v0.5.0</h4>
        <ul>
          <li><strong>Interface Refinement</strong>: Major usability improvements including:
            <ul>
              <li>Optimized typography with most readable system fonts across all interface text</li>
              <li>Enhanced button sizing and spacing for better touch targets and visual clarity</li>
              <li>Improved quick action button layouts with proper horizontal distribution</li>
              <li>Added meaningful emojis to action buttons for better visual communication</li>
            </ul>
          </li>
          <li><strong>Layout Improvements</strong>: Streamlined section organization with:
            <ul>
              <li>Redesigned Data Cleaning layout with side-by-side field selection and operations</li>
              <li>Enhanced Dataset Overview info panel with larger, more readable text</li>
              <li>Removed non-functional placeholder buttons to reduce interface clutter</li>
              <li>Streamlined navigation for better user experience</li>
            </ul>
          </li>
        </ul>
        
        <h4>v0.4.0</h4>
        <ul>
          <li><strong>Excel Support</strong>: Added comprehensive support for .xlsx and .xls files using SheetJS library, allowing users to analyze Excel workbooks alongside CSV/TSV files</li>
          <li><strong>Undo/Redo System</strong>: Implemented complete undo/redo functionality for data operations using Command pattern with:
            <ul>
              <li>Visual undo/redo buttons in header with dynamic tooltips</li>
              <li>Keyboard shortcuts (Ctrl+Z for undo, Ctrl+Y for redo)</li>
              <li>Memory management with 50 operation limit</li>
              <li>State persistence for all data transformations</li>
            </ul>
          </li>
          <li><strong>Performance Optimizations</strong>: Major performance improvements including:
            <ul>
              <li>Optimized data visualization rendering</li>
              <li>Increased analysis capacity to 1M cells</li>
              <li>Chunked file processing for large files</li>
              <li>Optimized duplicate detection with async processing</li>
              <li>Added progress indicators for long-running operations</li>
            </ul>
          </li>
          <li><strong>Enhanced User Experience</strong>: Improved file type validation, better error handling, and streamlined interface for business users</li>
        </ul>
        
        <h4>v0.3.9</h4>
        <ul>
          <li>Initial comprehensive data profiling capabilities</li>
          <li>CSV/TSV file support with drag-and-drop interface</li>
          <li>Missing values analysis and visualization</li>
          <li>Exact duplicate detection and reporting</li>
          <li>Field-level statistics and type detection</li>
          <li>Rule-based validation with allowed value sets</li>
          <li>Data validation via user-defined rules</li>
          <li>Cross-file fuzzy duplicate detection</li>
          <li>File merging with multiple join types</li>
          <li>Data cleaning operations (trim, case normalization, accent removal)</li>
          <li>Salesforce ID conversion (15→18 character)</li>
          <li>Theme support (Dark, Light, Matrix Mode)</li>
          <li>Local storage persistence with optional encryption</li>
          <li>Offline-first architecture with security focus</li>
        </ul>
      </div>
      <div class="modal-buttons" style="margin-top:12px">
        <button id="devLogClose" type="button">Close</button>
      </div>
    </div>
  </div>

  <!-- Histograms Modal -->
  <div id="histogramsModal" class="modal hidden" role="dialog" aria-modal="true" aria-labelledby="histogramsTitle">
    <div class="modal-content" style="max-width: 95%; max-height: 90%;">
      <h3 id="histogramsTitle">Data Distribution Histograms</h3>
      <div class="modal-buttons" style="margin-bottom: 16px;">
        <button id="printHistograms" type="button" title="Print histogram charts">🖨️ Print</button>
        <button id="histogramsClose" type="button" style="margin-left: auto;">Close</button>
      </div>
      <div id="histogramContainer" style="max-height: 70vh; overflow-y: auto; padding: 20px; background: var(--card-bg); border-radius: 8px; display: flex; flex-direction: column; align-items: center; position: relative;">
        <p class="muted">Load a dataset to view histograms for each column...</p>
        <!-- Tooltip for histogram interactions -->
        <div id="histogramTooltip" style="position: absolute; background: var(--panel); border: 1px solid var(--border); border-radius: 6px; padding: 8px 12px; font-size: 12px; pointer-events: none; opacity: 0; transition: opacity 0.2s ease; z-index: 1000; box-shadow: 0 4px 12px rgba(0,0,0,0.3);"></div>
      </div>
    </div>
  </div>

  <!-- SheetJS library for Excel support -->
  <script src="https://cdn.sheetjs.com/xlsx-0.20.3/package/dist/xlsx.full.min.js"></script>
  
  <script>
    (function() {
      // Null markers
      const NULL_MARKERS = new Set(["", " ", "NA", "N/A", "NULL", "null", "NaN", "nan"]);
      
      // =====================================================================
      // Undo/Redo System
      // =====================================================================
      
      class UndoRedoManager {
        constructor() {
          this.history = [];
          this.currentIndex = -1;
          this.maxHistorySize = 50; // Limit memory usage
        }
        
        // Execute a command and add it to history
        execute(command) {
          // Remove any redo history when a new command is executed
          this.history = this.history.slice(0, this.currentIndex + 1);
          
          // Execute the command and store the result
          const result = command.execute();
          command.result = result;
          
          // Add to history
          this.history.push(command);
          this.currentIndex++;
          
          // Limit history size to prevent memory issues
          if (this.history.length > this.maxHistorySize) {
            this.history = this.history.slice(-this.maxHistorySize);
            this.currentIndex = this.maxHistorySize - 1;
          }
          
          // Clean up memory if needed
          this.cleanupMemory();
          
          this.updateUI();
          return result;
        }
        
        // Undo the last operation
        undo() {
          if (this.canUndo()) {
            const command = this.history[this.currentIndex];
            command.undo();
            this.currentIndex--;
            this.updateUI();
            return true;
          }
          return false;
        }
        
        // Redo the next operation
        redo() {
          if (this.canRedo()) {
            this.currentIndex++;
            const command = this.history[this.currentIndex];
            command.execute();
            this.updateUI();
            return true;
          }
          return false;
        }
        
        canUndo() {
          return this.currentIndex >= 0;
        }
        
        canRedo() {
          return this.currentIndex < this.history.length - 1;
        }
        
        // Get description of current state for UI
        getUndoDescription() {
          if (this.canUndo()) {
            return this.history[this.currentIndex].description;
          }
          return null;
        }
        
        getRedoDescription() {
          if (this.canRedo()) {
            return this.history[this.currentIndex + 1].description;
          }
          return null;
        }
        
        // Clear all history (e.g., when loading new file)
        clear() {
          this.history = [];
          this.currentIndex = -1;
          this.updateUI();
        }
        
        updateUI() {
          // Update undo/redo button states
          const undoBtn = el('#undoBtn');
          const redoBtn = el('#redoBtn');
          
          if (undoBtn) {
            undoBtn.disabled = !this.canUndo();
            undoBtn.title = this.canUndo() ? `Undo: ${this.getUndoDescription()}` : 'Nothing to undo';
          }
          
          if (redoBtn) {
            redoBtn.disabled = !this.canRedo();
            redoBtn.title = this.canRedo() ? `Redo: ${this.getRedoDescription()}` : 'Nothing to redo';
          }
        }
        
        // Memory management utilities
        getMemoryUsage() {
          const estimates = this.history.map(command => {
            // Rough estimate of memory usage per command
            const headerMem = (command.beforeState.headers.length + command.afterState.headers.length) * 50; // avg 50 chars per header
            const rowMem = (command.beforeState.rows.length + command.afterState.rows.length) * 
                          (command.beforeState.headers.length + command.afterState.headers.length) * 20; // avg 20 chars per cell
            return headerMem + rowMem;
          });
          return estimates.reduce((sum, mem) => sum + mem, 0);
        }
        
        // Clean up memory if usage is high
        cleanupMemory() {
          const usage = this.getMemoryUsage();
          const MAX_MEMORY = 100 * 1024 * 1024; // 100MB rough limit
          
          if (usage > MAX_MEMORY && this.history.length > 10) {
            // Remove older commands, but keep at least 10
            const toRemove = Math.floor(this.history.length * 0.3); // Remove 30%
            this.history = this.history.slice(toRemove);
            this.currentIndex = Math.max(-1, this.currentIndex - toRemove);
            this.updateUI();
            // Cleaned undo commands to free memory
          }
        }
      }
      
      // Base command class
      class Command {
        constructor(description) {
          this.description = description;
        }
        
        execute() {
          throw new Error('Execute method must be implemented');
        }
        
        undo() {
          throw new Error('Undo method must be implemented');
        }
      }
      
      // Data operation command that stores dataset snapshots
      class DataOperationCommand extends Command {
        constructor(description, newHeaders, newRows, newName) {
          super(description);
          
          // Store the current state before the operation
          this.beforeState = {
            headers: STATE.headers ? [...STATE.headers] : [],
            rows: STATE.rows ? STATE.rows.map(row => [...row]) : [],
            name: el('#datasetName')?.textContent || 'Dataset',
            headerSig: STATE.headerSig,
            profiles: STATE.profiles ? [...STATE.profiles] : [],
            dupes: STATE.dupes ? [...STATE.dupes] : [],
          };
          
          // Store the new state to apply
          this.afterState = {
            headers: newHeaders ? [...newHeaders] : [],
            rows: newRows ? newRows.map(row => [...row]) : [],
            name: newName || this.beforeState.name
          };
        }
        
        async execute() {
          // Apply the new state
          await this.applyState(this.afterState);
          return this.afterState;
        }
        
        async undo() {
          // Restore the previous state
          await this.applyState(this.beforeState);
        }
        
        async applyState(state) {
          // Update the global state
          STATE.headers = [...state.headers];
          STATE.rows = state.rows.map(row => [...row]);
          
          // Update UI
          el('#datasetName').textContent = state.name;
          
          // If we have pre-computed state, use it; otherwise recompute
          if (state.profiles && state.dupes !== undefined && state.headerSig) {
            STATE.headerSig = state.headerSig;
            STATE.profiles = [...state.profiles];
            STATE.dupes = [...state.dupes];
            
            // Update UI with cached state
            this.renderCachedState(state);
          } else {
            // Recompute everything (for after-states)
            await computeAndRender(state.headers, STATE.rows, state.name);
          }
          
          // Update snapshots for dataset switching
          snapshotActiveDataset(state.name);
          updateDatasetSwitchUI();
        }
        
        renderCachedState(state) {
          // Update KPIs
          const totalCells = STATE.rows.length * STATE.headers.length;
          const missingCells = STATE.rows.reduce((a,r) => a + r.reduce((c,v) => c + (isNullish(v) ? 1 : 0), 0), 0);
          
          el('#kpiRows').textContent = STATE.rows.length;
          el('#kpiCols').textContent = STATE.headers.length;
          el('#kpiMissing').textContent = `${missingCells} (${percent(missingCells,totalCells)})`;
          
          // Update new KPI cards
          const completenessPercent = totalCells > 0 ? (((totalCells - missingCells) / totalCells) * 100).toFixed(1) : '100.0';
          el('#kpiCompleteness').textContent = completenessPercent + '%';
          el('#kpiTotalCells').textContent = totalCells.toLocaleString();
          
          // Render visualizations  
          renderDuplicates(STATE.dupes, 8, STATE.fuzzyDuplicates);
          renderProfiles(STATE.headers, STATE.profiles, STATE.rules, STATE.ruleResults);
          
          // Initialize UI
          initFuzzyCrossUI();
          bindExportButtons();
        }
      }
      
      // Global undo/redo manager instance
      const undoRedoManager = new UndoRedoManager();
      
      // Debug mode flag - can be enabled from browser console: 
      // window.DATAPHREAK_DEBUG = true; // Enable detailed logging
      // window.DATAPHREAK_DEBUG = false; // Disable logging (default)
      window.DATAPHREAK_DEBUG = false;
      
      // Enhanced logging function
      function debugLog(category, message, data = null) {
        if (window.DATAPHREAK_DEBUG) {
          const timestamp = new Date().toISOString().substr(11, 12);
          console.log(`[${timestamp}] [${category}]`, message, data || '');
        }
      }
      
      // Error logging with context
      function debugError(category, error, context = null) {
        const timestamp = new Date().toISOString().substr(11, 12);
        console.error(`[${timestamp}] [${category}] ERROR:`, error.message || error, context || '');
        if (error.stack && window.DATAPHREAK_DEBUG) {
          console.error('Stack trace:', error.stack);
        }
      }
      // Helpers with null safety
      const el = s => {
        try {
          return document.querySelector(s);
        } catch (error) {
          console.error('Error selecting element:', s, error);
          return null;
        }
      };
      const els = s => {
        try {
          return Array.from(document.querySelectorAll(s));
        } catch (error) {
          console.error('Error selecting elements:', s, error);
          return [];
        }
      };
      const escapeHtml = s => String(s).replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;").replace(/"/g,"&quot;").replace(/'/g,"&#039;");
      const percent = (a,b) => b > 0 ? ((a/b)*100).toFixed(1) + "%" : "–";
      // Format numbers and use plain ASCII fallback for non-numeric values
      const fmtNum = n => {
        if (Number.isFinite(n)) {
          if (Math.abs(n) >= 1000) return n.toFixed(0);
          if (Math.abs(n) >= 100)  return n.toFixed(1);
          return n.toFixed(2);
        }
        return 'N/A';
      };
      const fmtDate = ts => isFinite(ts) ? new Date(ts).toISOString().slice(0,10) : "–";
      const download = (filename,text) => {
        const mime = filename.toLowerCase().endsWith('.json') ? 'application/json' : 'text/csv';
        const blob = new Blob([text], {type: `${mime};charset=utf-8;`});
        const url  = URL.createObjectURL(blob);
        const a    = document.createElement('a');
        a.href = url; a.download = filename; document.body.appendChild(a); a.click();
        setTimeout(() => { URL.revokeObjectURL(url); a.remove(); }, 0);
      };
      /**
       * Escape a value for inclusion in a CSV file.  In addition to doubling
       * internal quotes and wrapping values containing commas or newlines in
       * double quotes, this function also prefixes a single quote to any
       * value that begins with characters used to start formulas in
       * spreadsheet software (=, +, -, @).  Without this prefix a malicious
       * value like '=CMD(...)' could execute arbitrary commands when the
       * exported CSV is opened in Excel.  See OWASP guidance on CSV
       * injection【506416736222498†L28-L64】 for more details.
       *
       * @param {any} v The cell value to escape
       * @returns {string} The escaped value
       */
      const csvEscape = v => {
        if (v === null || v === undefined) return "";
        let s = String(v);
        // Prefix a single quote for values that look like formulas
        if (/^[=+\-@]/.test(s)) {
          s = "'" + s;
        }
        // Double internal quotes and wrap in quotes if it contains commas or newlines
        const needsQuote = /[",\n]/.test(s);
        if (needsQuote) {
          s = '"' + s.replace(/"/g, '""') + '"';
        }
        return s;
      };
      const toCSV = (rows, header) => {
        const out = [];
        if (header) out.push(header.map(csvEscape).join(','));
        for (const r of rows) out.push(r.map(csvEscape).join(','));
        return out.join("\r\n");
      };
      // Header signature for rules
      function headerSignature(headers) {
        const base = headers.join('|').toLowerCase();
        let hash = 5381;
        for (let i=0; i<base.length; i++) {
          hash = ((hash << 5) + hash) + base.charCodeAt(i);
          hash >>>= 0;
        }
        return 'h' + hash.toString(16);
      }
      // CSV parsing
      function parseCSV(text) {
        const firstLine = text.split(/\r?\n/)[0] || '';
        const candidates = [',',';','\t'];
        let delim = ',';
        let maxCols = -1;
        for (const d of candidates) {
          const cols = splitCSVLine(firstLine, d).length;
          if (cols > maxCols) { maxCols = cols; delim = d; }
        }
        const rows = [];
        let row = [];
        let cur = '';
        let inQuotes = false;
        for (let i=0; i<text.length; i++) {
          const c = text[i];
          if (inQuotes) {
            if (c === '"') {
              if (text[i+1] === '"') { cur += '"'; i++; }
              else { inQuotes = false; }
            } else {
              cur += c;
            }
          } else {
            if (c === '"') inQuotes = true;
            else if (c === delim) { row.push(cur); cur = ''; }
            else if (c === '\n') { row.push(cur); rows.push(row); row = []; cur = ''; }
            else if (c === '\r') {}
            else { cur += c; }
          }
        }
        if (cur.length > 0 || row.length > 0) { row.push(cur); rows.push(row); }
        while (rows.length && rows[rows.length-1].every(v => String(v).trim() === '')) rows.pop();
        let headers = rows.shift() || [];
        headers = headers.map((h,i) => String(h).trim() || `col_${i+1}`);
        const seen = new Map();
        headers = headers.map(h => {
          const n = (seen.get(h) || 0) + 1;
          seen.set(h,n);
          return n===1 ? h : `${h}__${n}`;
        });
        return { headers, rows };
      }
      
      // Optimized chunked CSV parser for large files
      function parseCSVChunked(text, onProgress) {
        const firstLine = text.split(/\r?\n/)[0] || '';
        const candidates = [',',';','\t'];
        let delim = ',';
        let maxCols = -1;
        for (const d of candidates) {
          const cols = splitCSVLine(firstLine, d).length;
          if (cols > maxCols) { maxCols = cols; delim = d; }
        }
        
        return new Promise((resolve) => {
          const rows = [];
          let row = [];
          let cur = '';
          let inQuotes = false;
          let processed = 0;
          const textLength = text.length;
          const CHUNK_SIZE = 50000; // Process 50K characters at a time
          
          const processChunk = (start) => {
            const end = Math.min(start + CHUNK_SIZE, textLength);
            
            for (let i = start; i < end; i++) {
              const c = text[i];
              if (inQuotes) {
                if (c === '"') {
                  if (text[i+1] === '"') { cur += '"'; i++; }
                  else { inQuotes = false; }
                } else {
                  cur += c;
                }
              } else {
                if (c === '"') inQuotes = true;
                else if (c === delim) { row.push(cur); cur = ''; }
                else if (c === '\n') { row.push(cur); rows.push(row); row = []; cur = ''; }
                else if (c === '\r') {}
                else { cur += c; }
              }
            }
            
            processed = end;
            if (onProgress) {
              onProgress(Math.round((processed / textLength) * 100));
            }
            
            if (processed < textLength) {
              requestAnimationFrame(() => processChunk(processed));
            } else {
              // Finalize parsing
              if (cur.length > 0 || row.length > 0) { row.push(cur); rows.push(row); }
              while (rows.length && rows[rows.length-1].every(v => String(v).trim() === '')) rows.pop();
              
              let headers = rows.shift() || [];
              headers = headers.map((h,i) => String(h).trim() || `col_${i+1}`);
              const seen = new Map();
              headers = headers.map(h => {
                const n = (seen.get(h) || 0) + 1;
                seen.set(h,n);
                return n===1 ? h : `${h}__${n}`;
              });
              
              resolve({ headers, rows });
            }
          };
          
          processChunk(0);
        });
      }
      
      // Helper to decide between regular and chunked parsing
      async function smartParseCSV(text, onProgress) {
        const FILE_SIZE_THRESHOLD = 5 * 1024 * 1024; // 5MB threshold
        
        if (text.length > FILE_SIZE_THRESHOLD) {
          return await parseCSVChunked(text, onProgress);
        } else {
          return parseCSV(text);
        }
      }
      
      // Memory management helpers
      function optimizeMemoryUsage() {
        // Force garbage collection hint for large datasets
        if (STATE.rows && STATE.rows.length > 100000) {
          // Clear unused arrays and trigger cleanup
          if (window.gc && typeof window.gc === 'function') {
            window.gc();
          }
          
          // Clear old snapshots if memory pressure is high
          const memoryPressure = STATE.rows.length * (STATE.headers?.length || 1) > 1000000;
          if (memoryPressure) {
            // High memory usage detected, optimizing
            
            // Clear undo/redo history to free memory
            if (window.undoRedoManager) {
              window.undoRedoManager.clearHistory();
            }
            
            // Clear cached DOM references that can be re-queried
            STATE.cachedElements = null;
            
            // Force browser garbage collection if available
            if (window.gc) window.gc();
          }
        }
      }
      
      // Excel file parser using SheetJS
      function parseExcel(arrayBuffer, onProgress) {
        return new Promise((resolve, reject) => {
          try {
            if (onProgress) onProgress(10);
            
            // Read the workbook
            const workbook = XLSX.read(arrayBuffer, { type: 'array' });
            
            if (onProgress) onProgress(30);
            
            // Get the first worksheet
            const sheetNames = workbook.SheetNames;
            if (sheetNames.length === 0) {
              throw new Error('No worksheets found in Excel file');
            }
            
            const firstSheet = workbook.Sheets[sheetNames[0]];
            if (onProgress) onProgress(50);
            
            // Convert to array of arrays (similar to CSV structure)
            const rawData = XLSX.utils.sheet_to_json(firstSheet, { 
              header: 1, // Return array of arrays instead of objects
              defval: '', // Default value for empty cells
              raw: false // Return formatted strings (not raw values)
            });
            
            if (onProgress) onProgress(70);
            
            if (rawData.length === 0) {
              throw new Error('Excel file appears to be empty');
            }
            
            // Extract headers and rows (same structure as CSV parser)
            let headers = rawData.shift() || [];
            let rows = rawData;
            
            // Clean and validate headers (same logic as CSV parser)
            headers = headers.map((h, i) => String(h).trim() || `col_${i + 1}`);
            const seen = new Map();
            headers = headers.map(h => {
              const n = (seen.get(h) || 0) + 1;
              seen.set(h, n);
              return n === 1 ? h : `${h}__${n}`;
            });
            
            // Remove completely empty rows at the end
            while (rows.length && rows[rows.length - 1].every(v => String(v).trim() === '')) {
              rows.pop();
            }
            
            // Ensure all rows have the same number of columns as headers
            rows = rows.map(row => {
              const normalizedRow = [...row];
              while (normalizedRow.length < headers.length) {
                normalizedRow.push('');
              }
              return normalizedRow.slice(0, headers.length);
            });
            
            if (onProgress) onProgress(100);
            
            resolve({ headers, rows });
            
          } catch (error) {
            reject(new Error(`Excel parsing failed: ${error.message}`));
          }
        });
      }
      
      // Smart file parser that handles both CSV and Excel
      async function smartParseFile(file, onProgress) {
        const fileName = file.name.toLowerCase();
        const isExcel = fileName.endsWith('.xlsx') || fileName.endsWith('.xls');
        
        if (isExcel) {
          // Read as ArrayBuffer for Excel files
          return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = async () => {
              try {
                const result = await parseExcel(reader.result, onProgress);
                resolve(result);
              } catch (error) {
                reject(error);
              }
            };
            reader.onerror = () => reject(new Error('Failed to read Excel file'));
            reader.readAsArrayBuffer(file);
          });
        } else {
          // Read as text for CSV/TSV files
          return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = async () => {
              try {
                const result = await smartParseCSV(reader.result, onProgress);
                resolve(result);
              } catch (error) {
                reject(error);
              }
            };
            reader.onerror = () => reject(new Error('Failed to read CSV file'));
            reader.readAsText(file);
          });
        }
      }
      
      function splitCSVLine(line, delim) {
        const out = [];
        let cur = '';
        let inQ = false;
        for (let i=0; i<line.length; i++) {
          const c=line[i];
          if (inQ) {
            if (c === '"') {
              if (line[i+1] === '"') { cur += '"'; i++; }
              else inQ = false;
            } else cur += c;
          } else {
            if (c === '"') inQ=true;
            else if (c === delim) { out.push(cur); cur=''; }
            else cur+=c;
          }
        }
        out.push(cur);
        return out;
      }
      // Value helpers
      const isNullish = v => v == null || NULL_MARKERS.has(String(v).trim());
      function asNumberStrict(s) {
        const t = String(s).trim();
        return /^[-+]?\d+(\.\d+)?$/.test(t) ? Number(t) : NaN;
      }
      function asDateStrict(s) {
        const t = String(s).trim();
        if (!/^(\d{4}-\d{2}-\d{2})([ tT]\d{2}:\d{2}(:\d{2})?)?$/.test(t)) return NaN;
        const ms = Date.parse(t);
        return isNaN(ms) ? NaN : ms;
      }
      function asBoolStrict(s) {
        const t = String(s).trim().toLowerCase();
        return ["true","false","t","f","yes","no","y","n","1","0"].includes(t) ? t : null;
      }
      function inferType(values) {
        let count=0,num=0,dat=0,bool=0;
        for (const v of values) {
          if (isNullish(v)) continue;
          count++;
          if (Number.isFinite(asNumberStrict(v))) num++;
          if (Number.isFinite(asDateStrict(v))) dat++;
          if (asBoolStrict(v) != null) bool++;
        }
        if (count === 0) return {type:'unknown'};
        if (num / count >= 0.9) return {type:'number'};
        if (dat / count >= 0.9) return {type:'date'};
        if (bool / count >= 0.9) return {type:'boolean'};
        return {type:'string'};
      }
      
      // =============================================================================
      // SMART DETECTION ENGINE - Phase 1
      // =============================================================================
      
      // Configuration for AI pattern detection and processing
      const DATAPHREAK_CONFIG = {
        PATTERN_SAMPLE_SIZE: 100,
        PATTERN_CONFIDENCE_THRESHOLD: 0.3,
        PATTERN_FIXABLE_THRESHOLD: 0.2,
        TOP_PATTERNS_COUNT: 3,
        DUPLICATE_CHUNK_SIZE: 10000,
        FUZZY_CHUNK_SIZE: 5000,
        MAX_FUZZY_ROWS: 25000, // Reasonable limit for UI responsiveness
        PROGRESS_UPDATE_THRESHOLD: 1000,
        MEMORY_PRESSURE_THRESHOLD: 1000000
      };
      
      // Simplified Pattern Detection System - Core Business Patterns Only
      const PATTERN_LIBRARY = {
        email: {
          name: 'Email Address',
          regex: /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/,
          specificity: 10,
          validate: (value) => {
            const str = String(value).trim().toLowerCase();
            return /@/.test(str) && PATTERN_LIBRARY.email.regex.test(str);
          },
          fix: (value) => String(value).trim().toLowerCase(),
          icon: '📧'
        },
        
        phone: {
          name: 'Phone Number',
          regex: /^(\+\d{1,4}[\s\-\.]?)?\(?[\d\s\-\(\)\.]{7,18}\)?$/,
          specificity: 8,
          validate: (value) => {
            const str = String(value).trim();
            const cleaned = str.replace(/[\s\-\(\)\.]/g, '');
            
            // Must be 7-15 digits
            if (!/^\+?\d{7,15}$/.test(cleaned)) return false;
            
            // EXCLUDE date patterns only
            if (/^\d{4}[-\/]\d{1,2}[-\/]\d{1,2}$/.test(str)) return false;
            if (/^\d{1,2}[-\/]\d{1,2}[-\/]\d{4}$/.test(str)) return false;
            
            // Must have phone indicators OR be 10+ digits
            const hasPhoneIndicators = /[\(\)\+\.]/.test(str) || cleaned.length >= 10;
            
            return hasPhoneIndicators;
          },
          fix: (value) => {
            const cleaned = String(value).replace(/[\s\-\(\)\.]/g, '');
            
            // International numbers (keep as-is with + prefix)
            if (cleaned.startsWith('+') || cleaned.length > 10) {
              return cleaned.startsWith('+') ? cleaned : `+${cleaned}`;
            }
            
            // US numbers (10 digits)
            if (cleaned.length === 10) {
              return `(${cleaned.slice(0,3)}) ${cleaned.slice(3,6)}-${cleaned.slice(6)}`;
            }
            
            return cleaned;
          },
          icon: '📞'
        },
        
        date: {
          name: 'Date',
          regex: /^(\d{4}[\/\-]\d{1,2}[\/\-]\d{1,2}|\d{1,2}[\/\-]\d{1,2}[\/\-]\d{2,4})$/,
          specificity: 9,
          validate: (value) => {
            const str = String(value).trim();
            return PATTERN_LIBRARY.date.parseInternationalDate(str) !== null;
          },
          parseInternationalDate: (str) => {
            const cleaned = str.replace(/\s+/g, ' ').trim();
            
            // ISO format: YYYY-MM-DD or YYYY/MM/DD (unambiguous)
            const isoMatch = cleaned.match(/^(\d{4})[\/\-](\d{1,2})[\/\-](\d{1,2})$/);
            if (isoMatch) {
              const [, year, month, day] = isoMatch.map(Number);
              if (year >= 1900 && year <= 2100 && month >= 1 && month <= 12 && day >= 1 && day <= 31) {
                return new Date(year, month - 1, day);
              }
            }
            
            // Ambiguous DD/MM/YYYY vs MM/DD/YYYY - use smart heuristics
            const ambiguousMatch = cleaned.match(/^(\d{1,2})[\/\-](\d{1,2})[\/\-](\d{4})$/);
            if (ambiguousMatch) {
              const [, first, second, year] = ambiguousMatch.map(Number);
              
              if (first > 12) {
                const day = first, month = second;
                if (year >= 1900 && year <= 2100 && month >= 1 && month <= 12 && day >= 1 && day <= 31) {
                  return new Date(year, month - 1, day);
                }
              }
              
              if (second > 12) {
                const month = first, day = second;
                if (year >= 1900 && year <= 2100 && month >= 1 && month <= 12 && day >= 1 && day <= 31) {
                  return new Date(year, month - 1, day);
                }
              }
              
              // Both <= 12 - try European first
              if (first >= 1 && first <= 31 && second >= 1 && second <= 12) {
                const euroDate = new Date(year, second - 1, first);
                if (!isNaN(euroDate.getTime())) return euroDate;
              }
              
              if (first >= 1 && first <= 12 && second >= 1 && second <= 31) {
                const usDate = new Date(year, first - 1, second);
                if (!isNaN(usDate.getTime())) return usDate;
              }
            }
            
            // No fallback - only accept explicit date formats to prevent false positives
            return null;
          },
          fix: (value) => {
            const str = String(value).trim();
            const date = PATTERN_LIBRARY.date.parseInternationalDate(str);
            if (date && !isNaN(date.getTime())) {
              return date.toISOString().split('T')[0];
            }
            return value;
          },
          icon: '📅'
        }
      };

      // Pattern detection for column data with smart ordering and column hints
      function detectPatterns(values, columnName) {
        const sampleSize = Math.min(DATAPHREAK_CONFIG.PATTERN_SAMPLE_SIZE, values.length);
        const sample = values.filter(v => !isNullish(v)).slice(0, sampleSize);
        
        if (sample.length === 0) return { patterns: [], confidence: 0 };

        const patterns = [];
        
        // Use column name to prioritize certain patterns
        const columnLower = columnName.toLowerCase();
        let patternOrder = Object.keys(PATTERN_LIBRARY);
        
        // Prioritize specific patterns based on column name (simplified)
        if (columnLower.includes('email') || columnLower.includes('mail')) {
          patternOrder = ['email', ...patternOrder.filter(p => p !== 'email')];
        } else if (columnLower.includes('phone') || columnLower.includes('tel')) {
          patternOrder = ['phone', ...patternOrder.filter(p => p !== 'phone')];
        } else if (columnLower.includes('date') || columnLower.includes('birth') || columnLower.includes('dob')) {
          patternOrder = ['date', ...patternOrder.filter(p => p !== 'date')];
        }
        
        // Test each pattern against the sample in priority order
        for (const patternId of patternOrder) {
          const pattern = PATTERN_LIBRARY[patternId];
          let matches = 0;
          let fixes = 0;
          
          for (const value of sample) {
            if (pattern.validate(value)) {
              matches++;
            } else {
              // Check if fixable
              try {
                const fixed = pattern.fix(value);
                if (fixed !== value && pattern.validate(fixed)) {
                  fixes++;
                }
              } catch (e) {
                // Ignore fix errors
              }
            }
          }
          
          const confidence = matches / sample.length;
          const fixable = fixes / sample.length;
          
          // Calculate weighted confidence using specificity
          const specificityWeight = (pattern.specificity || 5) / 10; // Normalize to 0-1
          const weightedConfidence = confidence * specificityWeight;
          
          if (confidence > 0.1 || fixable > 0.1) { // Minimum threshold for pattern consideration
            patterns.push({
              id: patternId,
              name: pattern.name,
              icon: pattern.icon,
              confidence: confidence,
              fixable: fixable,
              weightedConfidence: weightedConfidence,
              specificity: pattern.specificity || 5,
              matches: matches,
              total: sample.length
            });
          }
        }
        
        // Sort by enterprise-grade specificity and confidence
        patterns.sort((a, b) => {
          // 1. Highest specificity wins (more specific patterns beat broader ones)
          if (a.specificity !== b.specificity) {
            return b.specificity - a.specificity;
          }
          
          // 2. Perfect confidence (1.0) patterns go next
          if (a.confidence === 1.0 && b.confidence !== 1.0) return -1;
          if (b.confidence === 1.0 && a.confidence !== 1.0) return 1;
          
          // 3. Then by weighted confidence (specificity * confidence)
          return b.weightedConfidence - a.weightedConfidence;
        });
        
        return {
          patterns: patterns.slice(0, DATAPHREAK_CONFIG.TOP_PATTERNS_COUNT),
          totalSampled: sample.length
        };
      }

      // Fuzzy Matching System
      function calculateLevenshteinDistance(str1, str2) {
        const len1 = str1.length;
        const len2 = str2.length;
        
        // Early termination for identical strings
        if (str1 === str2) return 0;
        if (len1 === 0) return len2;
        if (len2 === 0) return len1;
        
        // Space-optimized: use only two rows instead of full matrix (90% memory reduction)
        let prev = new Array(len1 + 1);
        let curr = new Array(len1 + 1);
        
        // Initialize first row
        for (let j = 0; j <= len1; j++) prev[j] = j;
        
        for (let i = 1; i <= len2; i++) {
          curr[0] = i;
          for (let j = 1; j <= len1; j++) {
            const cost = str2.charAt(i - 1) === str1.charAt(j - 1) ? 0 : 1;
            curr[j] = Math.min(
              prev[j] + 1,     // deletion
              curr[j - 1] + 1, // insertion
              prev[j - 1] + cost // substitution
            );
          }
          // Swap arrays (reuse memory) - optimized for performance
          const temp = prev;
          prev = curr;
          curr = temp;
        }
        
        return prev[len1];
      }

      function calculateSimilarity(str1, str2) {
        if (str1 === str2) return 1.0;
        
        const s1 = String(str1).toLowerCase().trim();
        const s2 = String(str2).toLowerCase().trim();
        
        if (s1 === s2) return 0.95; // Case-insensitive match
        
        const maxLen = Math.max(s1.length, s2.length);
        if (maxLen === 0) return 1.0;
        
        const distance = calculateLevenshteinDistance(s1, s2);
        return 1 - (distance / maxLen);
      }

      // Data Quality Scoring System
      function calculateDataQualityScore(headers, rows) {
        const totalCells = headers.length * rows.length;
        if (totalCells === 0) return { score: 0, breakdown: {} };

        let completenessScore = 0;
        let consistencyScore = 0;
        let validityScore = 0;

        const breakdown = {
          completeness: 0,
          consistency: 0,
          validity: 0,
          details: {
            totalCells,
            nonEmptyCells: 0,
            duplicateRows: 0,
            patternViolations: 0
          }
        };

        // Calculate completeness
        let nonEmptyCells = 0;
        for (const row of rows) {
          for (const cell of row) {
            if (!isNullish(cell)) {
              nonEmptyCells++;
            }
          }
        }
        
        completenessScore = nonEmptyCells / totalCells;
        breakdown.details.nonEmptyCells = nonEmptyCells;
        breakdown.completeness = Math.round(completenessScore * 100);

        // Calculate consistency (based on both exact and fuzzy duplicates)
        // Use efficient key generation instead of expensive JSON.stringify
        const uniqueKeys = new Set();
        for (const row of rows) {
          let key = '';
          for (let i = 0; i < row.length; i++) {
            if (i > 0) key += '\u001f';
            const val = row[i];
            key += val == null ? '' : typeof val === 'string' ? val.trim() : val;
          }
          uniqueKeys.add(key);
        }
        const exactDuplicateRows = rows.length - uniqueKeys.size;
        
        // Add fuzzy duplicates to the count if available
        let totalDuplicateRows = exactDuplicateRows;
        if (STATE.fuzzyDuplicates && STATE.fuzzyDuplicates.fuzzy) {
          const fuzzyDuplicateRows = STATE.fuzzyDuplicates.fuzzy.reduce((acc, group) => acc + group.length - 1, 0);
          totalDuplicateRows += fuzzyDuplicateRows;
        }
        
        consistencyScore = (rows.length - totalDuplicateRows) / rows.length;
        breakdown.details.duplicateRows = totalDuplicateRows;
        breakdown.consistency = Math.round(consistencyScore * 100);

        // Calculate validity (pattern compliance)
        let totalPatternChecks = 0;
        let validPatternChecks = 0;

        for (let colIndex = 0; colIndex < headers.length; colIndex++) {
          const columnData = rows.map(row => row[colIndex]);
          const patterns = detectPatterns(columnData, headers[colIndex]);
          
          if (patterns.patterns.length > 0) {
            const topPattern = patterns.patterns[0];
            const pattern = PATTERN_LIBRARY[topPattern.id];
            
            for (const value of columnData) {
              if (!isNullish(value)) {
                totalPatternChecks++;
                if (pattern.validate(value)) {
                  validPatternChecks++;
                }
              }
            }
          }
        }

        if (totalPatternChecks > 0) {
          validityScore = validPatternChecks / totalPatternChecks;
          breakdown.details.patternViolations = totalPatternChecks - validPatternChecks;
        } else {
          validityScore = 1.0; // No patterns detected, assume valid
        }
        breakdown.validity = Math.round(validityScore * 100);

        // Overall score (weighted average)
        const overallScore = (
          completenessScore * 0.4 +
          consistencyScore * 0.3 +
          validityScore * 0.3
        );

        return {
          score: Math.round(overallScore * 100),
          breakdown,
          grade: overallScore >= 0.9 ? 'A' : 
                 overallScore >= 0.8 ? 'B' : 
                 overallScore >= 0.7 ? 'C' : 
                 overallScore >= 0.6 ? 'D' : 'F'
        };
      }

      // Profile dataset
      function profileDataset(headers, rows) {
        const profiles = [];
        const colData = Array.from({length: headers.length}, (_,j) => rows.map(r => r[j] ?? ''));
        for (let j=0; j<headers.length; j++) {
          const vals = colData[j];
          const nonNull = vals.filter(v => !isNullish(v));
          const nullCount = vals.length - nonNull.length;
          const uniqSet = new Set(nonNull.map(v => String(v)));
          const {type} = inferType(vals);
          // Use plain ASCII values for N/A to avoid encoding issues in CSV exports
          let minVal='N/A', maxVal='N/A', mean='N/A', sd='N/A', outliers=0;
          let examples = Array.from(uniqSet).slice(0,3);
          if (type === 'number') {
            const nums = nonNull.map(asNumberStrict).filter(Number.isFinite);
            if (nums.length) {
              let sum = 0;
              let minN = Infinity;
              let maxN = -Infinity;
              for (const x of nums) {
                sum += x;
                if (x < minN) minN = x;
                if (x > maxN) maxN = x;
              }
              const mu = sum / nums.length;
              let varSum = 0;
              for (const x of nums) varSum += (x - mu) * (x - mu);
              const st = Math.sqrt(varSum / nums.length);
              minVal = fmtNum(minN);
              maxVal = fmtNum(maxN);
              mean   = fmtNum(mu);
              sd     = fmtNum(st);
              if (st > 0) {
                for (const x of nums) {
                  if (Math.abs((x - mu) / st) > 3) outliers++;
                }
              }
            }
          } else if (type === 'date') {
            const dates = nonNull.map(asDateStrict).filter(Number.isFinite);
            if (dates.length) {
              minVal = fmtDate(Math.min(...dates));
              maxVal = fmtDate(Math.max(...dates));
            }
          } else if (type === 'string') {
            const lengths = nonNull.map(v => String(v).length);
            if (lengths.length) {
              minVal = `${Math.min(...lengths)} chars`;
              maxVal = `${Math.max(...lengths)} chars`;
            }
          }
          
          // Add pattern detection for this column
          const patterns = detectPatterns(vals, headers[j]);
          
          profiles.push({ 
            name: headers[j], 
            type, 
            nonNull: nonNull.length, 
            nulls: nullCount, 
            unique: uniqSet.size,
            min: minVal, 
            max: maxVal, 
            mean, 
            sd, 
            outliers, 
            examples,
            patterns: patterns.patterns,
            totalSampled: patterns.totalSampled
          });
        }
        return { profiles, nrows: rows.length };
      }
      // Optimized duplicate finder with chunked processing
      function findDuplicates(rows) {
        return new Promise((resolve) => {
          const map = new Map();
          let processed = 0;
          const CHUNK_SIZE = DATAPHREAK_CONFIG.DUPLICATE_CHUNK_SIZE;
          
          // Cache DOM element for progress updates (performance optimization)
          const progressEl = el('#dupeSummary');
          
          const processChunk = () => {
            const end = Math.min(processed + CHUNK_SIZE, rows.length);
            
            for (let idx = processed; idx < end; idx++) {
              const row = rows[idx];
              // Optimized key generation using array join (faster than string concatenation)
              const keyParts = new Array(row.length);
              for (let i = 0; i < row.length; i++) {
                const val = row[i];
                keyParts[i] = val == null ? '' : typeof val === 'string' ? val.trim() : val;
              }
              const key = keyParts.join('\u001f');
              
              const existing = map.get(key);
              if (existing) {
                existing.push(idx);
              } else {
                map.set(key, [idx]);
              }
            }
            
            processed = end;
            
            if (processed < rows.length) {
              // Show progress for all datasets
              if (rows.length > DATAPHREAK_CONFIG.PROGRESS_UPDATE_THRESHOLD) {
                const progress = Math.round((processed / rows.length) * 100);
                if (progress % 10 === 0) { // Update every 10%
                  requestAnimationFrame(() => {
                    if (progressEl) progressEl.textContent = `Finding duplicates: ${progress}%`;
                    processChunk();
                  });
                } else {
                  requestAnimationFrame(processChunk);
                }
              } else {
                requestAnimationFrame(processChunk);
              }
            } else {
              // Finalize: extract groups and sort
              const groups = [];
              for (const list of map.values()) {
                if (list.length > 1) groups.push(list);
              }
              groups.sort((a,b) => b.length - a.length);
              
              // Clear progress indicator
              if (progressEl) progressEl.textContent = '';
              
              // Memory cleanup for large datasets
              map.clear();
              
              resolve(groups);
            }
          };
          
          processChunk();
        });
      }
      
      // Enhanced fuzzy duplicate finder
      function findFuzzyDuplicates(rows, headers, similarityThreshold = 0.85) {
        return new Promise((resolve) => {
          if (rows.length === 0) {
            resolve({ exact: [], fuzzy: [], stats: { totalRows: 0, exactDuplicates: 0, fuzzyDuplicates: 0, processed: 0 } });
            return;
          }

          const CHUNK_SIZE = DATAPHREAK_CONFIG.FUZZY_CHUNK_SIZE;
          
          let processed = 0;
          const exactMap = new Map();
          const fuzzyGroups = [];
          // Add memory safety for large datasets
          const processedRows = Math.min(rows.length, DATAPHREAK_CONFIG.MAX_FUZZY_ROWS);
          
          // Warn user if dataset is too large for full fuzzy analysis
          if (rows.length > DATAPHREAK_CONFIG.MAX_FUZZY_ROWS) {
            console.info(`Large dataset detected (${rows.length.toLocaleString()} rows). Fuzzy analysis limited to ${DATAPHREAK_CONFIG.MAX_FUZZY_ROWS.toLocaleString()} rows for performance.`);
          }
          
          // Cache DOM element for progress updates (performance optimization)
          const progressEl = el('#dupeSummary');
          
          const processChunk = () => {
            const end = Math.min(processed + CHUNK_SIZE, processedRows);
            
            // First pass: find exact duplicates
            for (let idx = processed; idx < end; idx++) {
              const row = rows[idx];
              let key = '';
              for (let i = 0; i < row.length; i++) {
                if (i > 0) key += '\u001f';
                const val = row[i];
                key += val == null ? '' : typeof val === 'string' ? val.trim() : val;
              }
              
              const existing = exactMap.get(key);
              if (existing) {
                existing.push(idx);
              } else {
                exactMap.set(key, [idx]);
              }
            }
            
            // Second pass: find fuzzy duplicates in current chunk
            // Note: This is O(n²) so we process in chunks to maintain UI responsiveness
            const processedIndices = new Set();
            
            for (let i = processed; i < end; i++) {
                if (processedIndices.has(i)) continue;
                
                const fuzzyGroup = [i];
                processedIndices.add(i);
                
                for (let j = i + 1; j < processedRows; j++) {
                  if (processedIndices.has(j)) continue;
                  
                  let totalSimilarity = 0;
                  let comparisons = 0;
                  
                  // Compare each field with early termination optimization
                  const maxFields = Math.min(rows[i].length, rows[j].length);
                  for (let k = 0; k < maxFields; k++) {
                    const val1 = rows[i][k];
                    const val2 = rows[j][k];
                    
                    if (isNullish(val1) && isNullish(val2)) {
                      totalSimilarity += 1.0;
                    } else if (isNullish(val1) || isNullish(val2)) {
                      totalSimilarity += 0.0;
                    } else {
                      totalSimilarity += calculateSimilarity(val1, val2);
                    }
                    comparisons++;
                    
                    // Early termination: skip if impossible to reach threshold with remaining fields
                    const remainingFields = maxFields - k - 1;
                    if (remainingFields > 0 && comparisons >= 2) {
                      // Calculate max possible final average assuming perfect remaining matches
                      const maxPossibleTotal = totalSimilarity + remainingFields;
                      const maxPossibleFinalAvg = maxPossibleTotal / maxFields; // Use maxFields to match final calculation intent
                      
                      if (maxPossibleFinalAvg < similarityThreshold) {
                        break; // Impossible to reach threshold
                      }
                    }
                  }
                  
                  const avgSimilarity = comparisons > 0 ? totalSimilarity / comparisons : 0;
                  
                  if (avgSimilarity >= similarityThreshold) {
                    fuzzyGroup.push(j);
                    processedIndices.add(j);
                  }
                }
                
                if (fuzzyGroup.length > 1) {
                  fuzzyGroups.push(fuzzyGroup);
                }
            }
            
            processed = end;
            
            if (processed < processedRows) {
              // Show progress
              const progress = Math.round((processed / processedRows) * 100);
              requestAnimationFrame(() => {
                if (progressEl) progressEl.textContent = `Analyzing duplicates: ${progress}%`;
                processChunk();
              });
            } else {
              // Finalize results
              const exactGroups = [];
              for (const list of exactMap.values()) {
                if (list.length > 1) exactGroups.push(list);
              }
              exactGroups.sort((a,b) => b.length - a.length);
              fuzzyGroups.sort((a,b) => b.length - a.length);
              
              const stats = {
                totalRows: rows.length,
                processed: processedRows,
                exactDuplicates: exactGroups.reduce((sum, group) => sum + group.length - 1, 0),
                fuzzyDuplicates: fuzzyGroups.reduce((sum, group) => sum + group.length - 1, 0),
                limitReached: rows.length > DATAPHREAK_CONFIG.MAX_FUZZY_ROWS
              };
              
              // Clear progress indicator
              if (progressEl) progressEl.textContent = '';
              
              // Memory cleanup for large datasets
              exactMap.clear();
              
              resolve({ 
                exact: exactGroups, 
                fuzzy: fuzzyGroups,
                stats
              });
            }
          };
          
          processChunk();
        });
      }
      
      // Rule checking
      function runRuleChecks(headers, rows, rules) {
        const invalidRows = [];
        const rowViolations = [];
        const violations = Array(headers.length).fill(0);
        for (let i=0; i < rows.length; i++) {
          const row = rows[i];
          const violObjs = [];
          for (let j=0; j < headers.length; j++) {
            const v = row[j];
            if (isNullish(v)) continue;
            const strVal = String(v);
            let reason = '';
            // 1) User rules: regex and allowed list
            const rx    = rules.regex[j];
            const allow = rules.allowed[j];
            if (rx && !rx.test(strVal)) {
              reason = 'Does not match regex pattern';
            } else if (allow && !allow.has(strVal)) {
              reason = 'Value not in allowed set';
            } else {
            }
            if (reason) {
              violations[j]++;
              violObjs.push({ col: j, reason });
            }
          }
          if (violObjs.length > 0) {
            invalidRows.push([i + 2, ...row]);
            rowViolations.push(violObjs);
          }
        }
        return { invalidRows, violations, rowViolations };
      }
      
      // Helper function to render pattern information
      function renderPatternInfo(patterns) {
        if (!patterns || patterns.length === 0) {
          return '<span class="muted">No patterns detected</span>';
        }
        
        const topPattern = patterns[0];
        if (topPattern.confidence >= 0.8) {
          return `<span style="color: var(--ok)" title="High confidence: ${Math.round(topPattern.confidence * 100)}% match">${topPattern.icon} ${topPattern.name}</span>`;
        } else if (topPattern.confidence >= 0.5 || topPattern.fixable >= 0.3) {
          return `<span style="color: var(--warn)" title="Partial match: ${Math.round(topPattern.confidence * 100)}% valid, ${Math.round(topPattern.fixable * 100)}% fixable">${topPattern.icon} ${topPattern.name}?</span>`;
        } else {
          return `<span style="color: var(--muted)" title="Low confidence: ${Math.round((topPattern.confidence + topPattern.fixable) * 100)}% potential">${topPattern.icon} ${topPattern.name.toLowerCase()}</span>`;
        }
      }
      
      // Render profiles table
      function renderProfiles(headers, profiles, rulesState, ruleResults) {
        const tbody = el('#profileTable tbody');
        tbody.innerHTML = '';
        for (let i=0; i<headers.length; i++) {
          const p = profiles[i];
          const cov = percent(p.nonNull, p.nonNull + p.nulls);
          const allowVal = rulesState.allowedStr[i] || '';
          const viol = ruleResults ? ruleResults.violations[i] : 0;
          const tr = document.createElement('tr');
        tr.innerHTML = `
            <td><strong>${escapeHtml(p.name)}</strong></td>
            <td><span class="tag">${p.type}</span></td>
            <td class="nowrap">${p.nonNull}</td>
            <td class="nowrap">${p.nulls}</td>
            <td style="min-width:140px">
              <div class="bar"><span style="width:${parseFloat(cov)||0}%"></span></div>
              <div class="small muted">${cov}</div>
            </td>
            <td>${p.unique}</td>
            <td>${p.min}</td>
            <td>${p.max}</td>
            <td>${p.mean}</td>
            <td>${p.outliers}</td>
            <td class="small">${p.examples.map(escapeHtml).join(', ')}</td>
            <td class="small">${renderPatternInfo(p.patterns)}</td>
            <td><input class="rule-input allow" data-col="${i}" placeholder="Comma‑separated allowed values" value="${escapeHtml(allowVal)}"></td>
            <td class="nowrap">${ruleResults ? (viol > 0 ? `<span class="tag" style="color:#fff;border-color:#7f1d1d;background:#7f1d1d">${viol}</span>` : `<span class="tag" style="color:#fff;border-color:#065f46;background:#065f46">0</span>`) : '–'}</td>
          `;
          tbody.appendChild(tr);
        }
      }
      // Render duplicates summary with fuzzy matching
      function renderDuplicates(groups, limit=8, fuzzyResults=null) {
        const totalExactDupes = groups.reduce((acc,g) => acc + g.length - 1, 0);
        const totalFuzzyDupes = fuzzyResults && fuzzyResults.fuzzy ? 
          fuzzyResults.fuzzy.reduce((acc,g) => acc + g.length - 1, 0) : 0;
        
        // Update KPI with total duplicates (exact + fuzzy)
        const totalDuplicates = totalExactDupes + totalFuzzyDupes;
        el('#kpiDupes').textContent = totalDuplicates;
        
        // Update summary text
        let summaryText = '';
        if (totalExactDupes === 0 && totalFuzzyDupes === 0) {
          summaryText = 'No duplicates found.';
        } else {
          const parts = [];
          if (totalExactDupes > 0) parts.push(`${groups.length} exact duplicate groups`);
          if (totalFuzzyDupes > 0 && fuzzyResults.fuzzy.length > 0) parts.push(`${fuzzyResults.fuzzy.length} fuzzy duplicate groups`);
          summaryText = `Found ${parts.join(' and ')}.`;
        }
        
        if (fuzzyResults && fuzzyResults.stats && fuzzyResults.stats.limitReached) {
          summaryText += ` (Fuzzy analysis limited to ${fuzzyResults.stats.processed.toLocaleString()} rows for performance)`;
        }
        
        el('#dupeSummary').textContent = summaryText;
        
        // Render duplicate list
        const list = el('#dupeList');
        list.innerHTML = '';
        
        // Show exact duplicates first
        if (groups.length > 0) {
          const exactHeader = document.createElement('div');
          exactHeader.innerHTML = '<strong style="color: var(--accent)">📋 Exact Matches</strong>';
          list.appendChild(exactHeader);
          
          groups.slice(0, limit).forEach((g, idx) => {
            const div = document.createElement('div');
            div.innerHTML = `<div class="muted small">Group ${idx+1}: ${g.length} rows (1 original + ${g.length-1} dupes) • row numbers: ${g.map(i => i+2).join(', ')}</div>`;
            list.appendChild(div);
          });
        }
        
        // Show fuzzy duplicates
        if (fuzzyResults && fuzzyResults.fuzzy && fuzzyResults.fuzzy.length > 0) {
          if (groups.length > 0) {
            const spacer = document.createElement('div');
            spacer.style.height = '12px';
            list.appendChild(spacer);
          }
          
          const fuzzyHeader = document.createElement('div');
          fuzzyHeader.innerHTML = '<strong style="color: var(--accent2)">🔍 Fuzzy Duplicates (Similar Records)</strong>';
          list.appendChild(fuzzyHeader);
          
          // Always show at least some fuzzy groups, don't let exact groups crowd them out
          const maxFuzzyGroups = Math.max(3, Math.floor(limit / 2)); // Show at least 3, or half the limit
          fuzzyResults.fuzzy.slice(0, maxFuzzyGroups).forEach((g, idx) => {
            const div = document.createElement('div');
            div.innerHTML = `<div class="muted small">Similar Group ${idx+1}: ${g.length} rows • row numbers: ${g.map(i => i+2).join(', ')}</div>`;
            list.appendChild(div);
          });
        }
      }
      // Invalid rows table
      function renderInvalidTable(headers, ruleResults) {
        const wrap = el('#invalidTableWrap');
        if (!ruleResults || !ruleResults.invalidRows || ruleResults.invalidRows.length === 0) {
          wrap.innerHTML = '';
          el('#invalidSummary').textContent = 'No rule violations detected.';
          return;
        }
        const invalidRows = ruleResults.invalidRows;
        const rowViolObjs = ruleResults.rowViolations || [];
        const headerRow = ['Row#', ...headers];
        const displayCount = Math.min(200, invalidRows.length);
        const table = document.createElement('table');
        const thead = document.createElement('thead');
        const trh   = document.createElement('tr');
        headerRow.forEach(h => {
          const th = document.createElement('th'); th.textContent = h; trh.appendChild(th);
        });
        thead.appendChild(trh);
        const tbody = document.createElement('tbody');
        for (let rIdx=0; rIdx < displayCount; rIdx++) {
          const row = invalidRows[rIdx];
          const violObjs = rowViolObjs[rIdx] || [];
          const reasonMap = new Map();
          violObjs.forEach(o => { reasonMap.set(o.col, o.reason); });
          const tr = document.createElement('tr');
          for (let i=0; i<row.length; i++) {
            const td = document.createElement('td');
            const val = row[i];
            td.textContent = i === 0 ? val : (val == null ? '' : String(val));
            if (i > 0) {
              const colIdx = i - 1;
              if (reasonMap.has(colIdx)) {
                td.style.background = 'rgba(239,68,68,0.3)';
                td.title = reasonMap.get(colIdx);
              }
            }
            tr.appendChild(td);
          }
          tbody.appendChild(tr);
        }
        table.appendChild(thead);
        table.appendChild(tbody);
        wrap.innerHTML = '';
        wrap.appendChild(table);
        el('#invalidSummary').textContent = `${invalidRows.length} rows violate at least one rule. Showing first ${displayCount}.`;
      }
      // Data dictionary export
      function exportDataDict(headers, profiles, rulesState, ruleResults) {
        const rows = [];
        for (let i=0; i < headers.length; i++) {
          const p = profiles[i];
          const allow = rulesState.allowedStr[i] || '';
          const viol = ruleResults ? ruleResults.violations[i] : 0;
          rows.push([
            p.name,
            p.type,
            p.nonNull,
            p.nulls,
            p.unique,
            p.min,
            p.max,
            p.mean,
            p.outliers,
            (p.examples || []).join('; '),
            allow,
            viol
          ]);
        }
        const header = ['column','type','non_null','nulls','unique','min','max','mean','outliers','examples','allowed_set','violations'];
        download('Data_Dictionary.csv', toCSV(rows, header));
      }
      // LocalStorage helpers
      const LS_PREFIX = 'dataphreak_rules_v1::';
      function rulesKey(sig) { return LS_PREFIX + sig; }
      function saveRules(sig, headers, rxStr, allowStr) {
        const payload = {
          signature: sig,
          savedAt: new Date().toISOString(),
          headers: [...headers],
          columns: headers.map((name,i) => ({ name, regex: rxStr[i] || '', allowed: allowStr[i] || '' }))
        };
        try { localStorage.setItem(rulesKey(sig), JSON.stringify(payload)); return { ok:true, payload }; }
        catch (e) { return { ok:false, error:e }; }
      }
      function loadRules(sig) {
        try { const raw = localStorage.getItem(rulesKey(sig)); return raw ? JSON.parse(raw) : null; }
        catch(e){ return null; }
      }
      function clearRulesLS(sig) {
        try { localStorage.removeItem(rulesKey(sig)); return true; } catch(e){ return false; }
      }
      function showRulesStatus(msg, tone='info') {
        const badge = el('#rulesStatus');
        badge.style.display = 'inline-block';
        badge.textContent = msg;
        if (tone === 'error') badge.style.background = '#7f1d1d';
        else if (tone === 'ok') badge.style.background = '#065f46';
        else badge.style.background = 'var(--chip)';
        badge.style.color = '#e5e7eb';
        clearTimeout(showRulesStatus._t);
        showRulesStatus._t = setTimeout(() => { badge.style.display = 'none'; }, 3500);
      }
      // Global state
      const STATE = {
        // Primary dataset state
        headers: [],
        fileInfo: null, // Store file information
        rows: [],
        profiles: [],
        dupes: [],
        fuzzyDuplicates: null,
        // Rules for the primary dataset
        rules: {
          regex: [],
          allowed: [],
          regexStr: [],
          allowedStr: []
        },
        ruleResults: null,
        headerSig: null,
        suggestions: null,
        // Secondary dataset state – used for merging and future cross‑file operations
        secondaryHeaders: [],
        secondaryRows: [],
        secondaryName: '',
        // Primary dataset snapshots.  When a new file is loaded, we capture
        // the headers, rows and name in these properties so they can be
        // restored later when switching datasets.  The active dataset
        // (primary or secondary) is tracked separately below.
        primaryHeaders: [],
        primaryRows: [],
        primaryName: '',
        // The currently active dataset ('primary' or 'secondary').  When
        // users switch using the dataset selector, this flag updates
        // accordingly.  Operations and render functions always act on
        // STATE.headers/rows, which are set from the active dataset when
        // switching.
        activeDataset: 'primary'
      };

      // =====================================================================
      // Error handling and file size guard
      // ---------------------------------------------------------------------
      // No file size limit - let users decide what their system can handle

      /**
       * Display a small toast message in the bottom right corner.  The tone
       * argument controls the colour scheme: use 'error' for problems,
       * 'ok' for success, and 'info' for neutral messages.  Messages
       * disappear automatically after a few seconds.
       */
      function toast(msg, tone = 'info') {
        const toastContainer = document.getElementById('toast');
        if (!toastContainer) return;
        const div = document.createElement('div');
        div.textContent = String(msg);
        // Base styling
        div.style.marginTop = '8px';
        div.style.padding = '8px 12px';
        div.style.border = '1px solid var(--border)';
        div.style.borderRadius = '8px';
        div.style.wordBreak = 'break-word';
        // Tone colours
        if (tone === 'error') div.style.background = 'rgba(239,68,68,0.25)';
        else if (tone === 'ok') div.style.background = 'rgba(16,185,129,0.2)';
        else div.style.background = 'var(--card-bg)';
        toastContainer.appendChild(div);
        setTimeout(() => {
          div.remove();
        }, 4500);
      }
      
      // Enhanced progress indicators
      let progressOverlay = null;
      
      function showProgressOverlay(message) {
        hideProgressOverlay(); // Clear any existing overlay
        
        progressOverlay = document.createElement('div');
        progressOverlay.style.cssText = `
          position: fixed;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          background: rgba(0,0,0,0.7);
          display: flex;
          align-items: center;
          justify-content: center;
          z-index: 10000;
          color: white;
          font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
        `;
        
        const content = document.createElement('div');
        content.style.cssText = `
          background: var(--panel);
          padding: 24px;
          border-radius: 8px;
          text-align: center;
          box-shadow: 0 8px 32px rgba(0,0,0,0.5);
        `;
        content.innerHTML = `
          <div style="margin-bottom: 16px; font-size: 18px;">${message}</div>
          <div style="width: 200px; height: 4px; background: rgba(255,255,255,0.2); border-radius: 2px; overflow: hidden;">
            <div id="progressBar" style="width: 0%; height: 100%; background: var(--accent); transition: width 0.3s ease;"></div>
          </div>
        `;
        
        progressOverlay.appendChild(content);
        document.body.appendChild(progressOverlay);
      }
      
      function updateProgressOverlay(percent) {
        if (progressOverlay) {
          const bar = progressOverlay.querySelector('#progressBar');
          if (bar) {
            bar.style.width = percent + '%';
          }
        }
      }
      
      function hideProgressOverlay() {
        if (progressOverlay) {
          progressOverlay.remove();
          progressOverlay = null;
        }
      }

      /**
       * Check if the given file exceeds the size cap.  If it does, show a
       * friendly error toast and return true.  Otherwise return false to
       * indicate the file is acceptable.
       */
      function rejectIfTooBig(file) {
        // No size limit - let users handle what their system can support
        return false;
      }
      
      function validateFileType(file) {
        if (!file) return false;
        
        const fileName = file.name.toLowerCase();
        const validExtensions = ['.csv', '.tsv', '.xlsx', '.xls'];
        const validMimeTypes = [
          'text/csv',
          'text/tab-separated-values', 
          'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
          'application/vnd.ms-excel',
          'text/plain' // Some systems report CSV as text/plain
        ];
        
        const hasValidExtension = validExtensions.some(ext => fileName.endsWith(ext));
        const hasValidMimeType = validMimeTypes.includes(file.type) || file.type === '';
        
        if (!hasValidExtension) {
          toast('Unsupported file type. Please select a CSV, TSV, or Excel file.', 'error');
          return false;
        }
        
        return true;
      }

      // =====================================================================
      // Dataset snapshotting and switching
      // ---------------------------------------------------------------------
      /**
       * Capture the current dataset state into the appropriate snapshot based
       * on the active dataset flag.  This function should be invoked after
       * a file load or after operations that modify the data so that
       * switching back to the dataset later restores the modified version.
       * If a dataset name is provided it will update the stored name
       * associated with the snapshot; otherwise the previous name is kept.
       *
       * @param {string} name Optional dataset name to associate with the snapshot
       */
      function snapshotActiveDataset(name) {
        if (STATE.activeDataset === 'primary') {
          STATE.primaryHeaders = STATE.headers.slice();
          STATE.primaryRows = STATE.rows.map(r => r.slice());
          if (name !== undefined) STATE.primaryName = name;
        } else {
          STATE.secondaryHeaders = STATE.headers.slice();
          STATE.secondaryRows = STATE.rows.map(r => r.slice());
          if (name !== undefined) STATE.secondaryName = name;
        }
      }

      /**
       * Update the dataset switcher UI based on whether a secondary dataset
       * exists.  The secondary option is enabled only when secondaryHeaders
       * has length > 0.  The option text reflects the name of the loaded
       * secondary file when available.
       */
      function updateDatasetSwitchUI() {
        const select = el('#datasetSwitch');
        if (!select) return;
        const optSecondary = select.querySelector('option[value="secondary"]');
        if (!optSecondary) return;
        const hasSecondary = Array.isArray(STATE.secondaryHeaders) && STATE.secondaryHeaders.length > 0;
        optSecondary.disabled = !hasSecondary;
        optSecondary.textContent = hasSecondary ? `Secondary: ${STATE.secondaryName || 'Loaded File'}` : 'Secondary (none)';
        // Reflect the current active dataset selection in the select value
        select.value = STATE.activeDataset || 'primary';
      }

      /**
       * Decide how to handle a newly loaded file.  If no primary dataset has
       * been loaded yet, the file becomes the primary dataset.  If a primary
       * dataset exists but no secondary dataset exists, the file becomes the
       * secondary dataset.  If both primary and secondary datasets exist,
       * loading another file will replace whichever dataset is currently
       * active (primary or secondary).  After assigning the dataset, it
       * renders the data and updates the relevant snapshot and UI.
       *
       * @param {Array<string>} headers The parsed header row
       * @param {Array<Array>} rows The parsed data rows
       * @param {string} fileName The file name to display
       */
      function handleFileLoad(headers, rows, fileName) {
        // Clear undo/redo history when loading new files
        undoRedoManager.clear();
        
        // Determine where to store the dataset
        const hasPrimary = Array.isArray(STATE.primaryHeaders) && STATE.primaryHeaders.length > 0;
        const hasSecondary = Array.isArray(STATE.secondaryHeaders) && STATE.secondaryHeaders.length > 0;
        let target;
        if (!hasPrimary) {
          target = 'primary';
        } else if (!hasSecondary) {
          target = 'secondary';
        } else {
          // Both datasets exist: replace whichever is currently active
          target = STATE.activeDataset || 'primary';
        }
        // Update active dataset flag
        STATE.activeDataset = target;
        // Assign headers/rows to the appropriate snapshot *before* rendering so that
        // computeAndRender() can populate the cross‑file UI with the latest
        // primary/secondary headers.  Without this, initFuzzyCrossUI() would
        // see stale snapshots and fail to list the new dataset's columns.
        if (target === 'primary') {
          STATE.primaryHeaders = headers.slice();
          STATE.primaryRows    = rows.map(r => r.slice());
          STATE.primaryName    = fileName;
        } else {
          STATE.secondaryHeaders = headers.slice();
          STATE.secondaryRows    = rows.map(r => r.slice());
          STATE.secondaryName    = fileName;
        }
        // Render the dataset.  computeAndRender() will update STATE.headers
        // and STATE.rows, and call initFuzzyCrossUI() among other initialisers.
        computeAndRender(headers, rows, fileName).then(() => {
          // After rendering, snapshot the active dataset so modifications persist
          // when switching.  Doing this after computeAndRender() ensures that
          // STATE.headers/rows correspond to the just-loaded dataset.
          snapshotActiveDataset(fileName);
          
          // Refresh dataset switcher UI
          updateDatasetSwitchUI();
        });
        // Inform the user what happened via toast
        const msg = (!hasPrimary) ? 'Primary dataset loaded' : (!hasSecondary) ? 'Secondary dataset loaded' : 'Dataset replaced';
        toast(msg + ` (target: ${target})`, 'ok');
      }

      // =====================================================================
      // User preferences and settings
      // ---------------------------------------------------------------------
      // Define a key and default values for persisted preferences.  Users can
      // adjust these values via the Settings modal.  Preferences include
      // theme (dark/light/high-tech), default cleaning operations, interface
      // language, whether to persist settings across sessions, and a flag
      // indicating whether data should be encrypted (encryption not yet
      // implemented).
      const PREFS_KEY = 'dp_prefs_v1';
      const DEFAULT_PREFS = {
        theme: 'dark',
        // Default cleaning operations: enable trimming, accent removal and
        // Salesforce ID conversion by default. Case normalization is disabled by default
        // to preserve original data formatting.  Users can customise these in the
        // Settings panel.  Converting SF IDs to 18‑char form helps ensure IDs
        // match across files by default.
        defaultOps: { trim: true, normalize: false, clean: true, sf: true },
        language: 'en',
        persist: true,
        encrypt: false
      };
      /**
       * Load user preferences from localStorage.  If no saved prefs exist,
       * return a fresh copy of DEFAULT_PREFS.  If parsing fails, return
       * defaults as a fallback.  Default operations are merged to ensure
       * missing flags get sensible values.
       */
      function loadPrefs() {
        const raw = localStorage.getItem(PREFS_KEY);
        if (!raw) return { ...DEFAULT_PREFS };
        try {
          const obj = JSON.parse(raw);
          const merged = {
            ...DEFAULT_PREFS,
            ...obj,
            defaultOps: { ...DEFAULT_PREFS.defaultOps, ...(obj.defaultOps || {}) }
          };
          // Override old preferences with new defaults for better user experience
          // SF conversion enabled by default for better ID matching
          merged.defaultOps.sf = DEFAULT_PREFS.defaultOps.sf;
          // Case normalization disabled by default to preserve original formatting
          merged.defaultOps.normalize = DEFAULT_PREFS.defaultOps.normalize;
          return merged;
        } catch {
          return { ...DEFAULT_PREFS };
        }
      }
      /**
       * Save preferences to localStorage.  If persistence is disabled,
       * remove the key entirely.
       */
      function savePrefs(prefs) {
        if (!prefs.persist) {
          localStorage.removeItem(PREFS_KEY);
          return;
        }
        localStorage.setItem(PREFS_KEY, JSON.stringify(prefs));
      }
      /**
       * Apply preferences to the current UI.  This sets the theme and
       * initial checkbox states for the default cleaning operations.  When
       * we add language support, this function will also trigger
       * translation loading.
       */
      function applyPrefsToUI(prefs) {
        // Theme: rely on existing setTheme() helper to toggle classes and
        // update the theme toggle button text.
        setTheme(prefs.theme || 'dark');
        // Default operations: reflect stored choices in the Data Cleaning panel.
        const ops = prefs.defaultOps || {};
        const trm = el('#opTrim'); if (trm) trm.checked = !!ops.trim;
        const nm = el('#opNormalize'); if (nm) nm.checked = !!ops.normalize;
        const cl = el('#opClean'); if (cl) cl.checked = !!ops.clean;
        const sf = el('#opSfConvert'); if (sf) sf.checked = !!ops.sf;
        // Language preference will be handled when localisation is added.
      }
      // Holder for preferences (loaded on startup below).
      let PREFS;
      // Compute and render
      async function computeAndRender(headers, rows, datasetName='Loaded CSV') {
        STATE.headers = headers;
        STATE.rows = rows;
        STATE.headerSig = headerSignature(headers);
        // profiles
        STATE.profiles = profileDataset(headers, rows).profiles;
        // duplicates (now async with fuzzy matching)
        STATE.dupes = await findDuplicates(rows);
        STATE.fuzzyDuplicates = await findFuzzyDuplicates(rows, headers);
        
        // Optimize memory for large datasets
        optimizeMemoryUsage();
        
        // KPIs
        const totalCells = rows.length * headers.length;
        const missingCells = rows.reduce((a,r) => a + r.reduce((c,v) => c + (isNullish(v) ? 1 : 0), 0), 0);
        el('#kpiRows').textContent = rows.length;
        el('#kpiCols').textContent = headers.length;
        el('#kpiMissing').textContent = `${missingCells} (${percent(missingCells,totalCells)})`;
        
        // Update new KPI cards
        const completenessPercent = totalCells > 0 ? (((totalCells - missingCells) / totalCells) * 100).toFixed(1) : '100.0';
        el('#kpiCompleteness').textContent = completenessPercent + '%';
        el('#kpiTotalCells').textContent = totalCells.toLocaleString();
        
        // Calculate and display data quality score
        const qualityScore = calculateDataQualityScore(headers, rows);
        el('#kpiQuality').textContent = qualityScore.score + '%';
        const qualityStatus = el('#kpiQualityStatus');
        qualityStatus.textContent = `Grade: ${qualityScore.grade}`;
        qualityStatus.title = `Completeness: ${qualityScore.breakdown.completeness}%, Consistency: ${qualityScore.breakdown.consistency}%, Validity: ${qualityScore.breakdown.validity}%`;
        
        // Color-code the quality score
        const qualityCard = el('#kpiQualityCard');
        if (qualityCard && qualityStatus) {
          if (qualityScore.score >= 90) {
            qualityCard.style.borderColor = 'var(--ok)';
            qualityStatus.style.color = 'var(--ok)';
          } else if (qualityScore.score >= 70) {
            qualityCard.style.borderColor = 'var(--warn)';
            qualityStatus.style.color = 'var(--warn)';
          } else {
            qualityCard.style.borderColor = 'var(--err)';
            qualityStatus.style.color = 'var(--err)';
          }
        }
        
        // heatmap & duplicates
        renderDuplicates(STATE.dupes, 8, STATE.fuzzyDuplicates);
        // suggestions for rules
        const rxS = new Array(headers.length).fill('');
        const allowS = new Array(headers.length).fill('');
        for (let j=0; j<headers.length; j++) {
          const p = STATE.profiles[j];
          if (p.type === 'string' && p.unique > 0 && p.unique <= 20) {
            const uniqVals = [...new Set(rows.map(r => r[j]).filter(v => !isNullish(v)).map(v => String(v)))];
            allowS[j] = uniqVals.join(', ');
          }
          if (/email/i.test(headers[j])) rxS[j] = '^[^@\\s]+@[^@\\s]+\\.[^@\\s]+$';
          if (/date/i.test(headers[j]))  rxS[j] = '^\\d{4}-\\d{2}-\\d{2}$';
        }
        STATE.suggestions = { regexStr: [...rxS], allowedStr: [...allowS] };
        // load saved rules
        const saved = loadRules(STATE.headerSig);
        if (saved && Array.isArray(saved.columns) && saved.columns.length === headers.length) {
          for (let i=0; i<headers.length; i++) {
            rxS[i] = saved.columns[i].regex || '';
            allowS[i] = saved.columns[i].allowed || '';
          }
          showRulesStatus('Rules restored','ok');
        } else {
          showRulesStatus('Using suggested defaults','info');
        }
        STATE.rules.regexStr = rxS;
        STATE.rules.allowedStr = allowS;
        STATE.rules.regex = new Array(headers.length).fill(null);
        STATE.rules.allowed = new Array(headers.length).fill(null);
        STATE.ruleResults = null;
        // render profiles & invalid table
        renderProfiles(headers, STATE.profiles, STATE.rules, STATE.ruleResults);
        renderInvalidTable(headers, null);
        // update dataset name
        el('#datasetName').textContent = datasetName;
        
        // Update Dataset Overview info panel
        const fileName = el('#infoFileName');
        const fileSize = el('#infoFileSize');
        const loadTime = el('#infoLoadTime');
        const status = el('#infoStatus');
        const datasetSubtitle = el('#datasetFileName');
        
        if (fileName) fileName.textContent = datasetName || 'Dataset';
        if (fileSize) {
          if (STATE.fileInfo && STATE.fileInfo.size) {
            const size = STATE.fileInfo.size;
            let sizeStr;
            if (size < 1024) sizeStr = size + ' B';
            else if (size < 1024 * 1024) sizeStr = (size / 1024).toFixed(1) + ' KB';
            else sizeStr = (size / (1024 * 1024)).toFixed(1) + ' MB';
            fileSize.textContent = `${sizeStr} • ${rows.length}×${headers.length}`;
          } else {
            fileSize.textContent = `${rows.length} rows × ${headers.length} cols`;
          }
        }
        if (loadTime) loadTime.textContent = new Date().toLocaleTimeString();
        if (status) {
          const missingPercent = parseFloat(((missingCells / totalCells) * 100).toFixed(1));
          const dupePercent = parseFloat(((STATE.dupes.length / rows.length) * 100).toFixed(1));
          
          // Use the same comprehensive quality score for consistency
          const comprehensiveQuality = calculateDataQualityScore(headers, rows);
          const qualityScoreValue = comprehensiveQuality.score;
          
          // Determine status based on comprehensive quality score (consistent with KPI)
          if (qualityScoreValue >= 90) {
            status.innerHTML = '<span style="color: #10b981">💎 Excellent quality</span>';
          } else if (qualityScoreValue >= 80) {
            status.innerHTML = '<span style="color: #10b981">✨ Very good quality</span>';
          } else if (qualityScoreValue >= 70) {
            status.innerHTML = '<span style="color: #9333ea">📊 Good quality</span>';
          } else if (qualityScoreValue >= 60) {
            status.innerHTML = '<span style="color: #f59e0b">⚠️ Fair quality - review recommended</span>';
          } else {
            status.innerHTML = '<span style="color: #ef4444">🚨 Poor quality - needs cleaning</span>';
          }
          
          // Add quality score as a tooltip with detailed breakdown
          status.title = `Quality Score: ${qualityScoreValue}/100 | Grade: ${comprehensiveQuality.grade} | Completeness: ${comprehensiveQuality.breakdown.completeness}% | Consistency: ${comprehensiveQuality.breakdown.consistency}% | Validity: ${comprehensiveQuality.breakdown.validity}%`;
        }
        if (datasetSubtitle) datasetSubtitle.textContent = `${datasetName} loaded`;
        
        // enable buttons
        ['exportDict','runRules','saveRules','clearRules','downloadRules'].forEach(id => {
          el(`#${id}`).disabled = false;
        });

        // Initialise fuzzy duplicate UI after loading data
        // Initialise cross‑file fuzzy UI (populate primary/secondary column selectors)
        initFuzzyCrossUI();
        // Initialise Data Operations UI (populate column selector)
        initOperationsUI();
        // Refresh dataset switcher selection (ensures option text reflects current names)
        updateDatasetSwitchUI();

        // Rebind export buttons in case the DOM has been re-rendered.  Without
        // this call, event listeners attached during initialisation may be
        // lost when sections of the UI are updated or replaced.
        bindExportButtons();
      }
      // Sorting for profiles table
      (function() {
        const table = el('#profileTable');
        let sortIdx = 0, sortAsc = true;
        table.querySelectorAll('thead th').forEach((th, idx) => {
          th.style.cursor='pointer';
          th.addEventListener('click', () => {
            const tbody = table.querySelector('tbody');
            const rows = Array.from(tbody.querySelectorAll('tr'));
            sortAsc = (sortIdx===idx) ? !sortAsc : true; sortIdx = idx;
            rows.sort((a,b) => {
              const va = a.children[idx].innerText;
              const vb = b.children[idx].innerText;
              const na = parseFloat(va.replace(/[^\d.-]/g,""));
              const nb = parseFloat(vb.replace(/[^\d.-]/g,""));
              const cmp = (Number.isFinite(na) && Number.isFinite(nb)) ? (na-nb) : va.localeCompare(vb);
              return sortAsc ? cmp : -cmp;
            });
            rows.forEach(r => tbody.appendChild(r));
          });
        });
      })();
      
      // Analysis view mode switcher
      document.querySelectorAll('.view-mode').forEach(button => {
        button.addEventListener('click', () => {
          const mode = button.dataset.mode;
          
          // Update active button
          document.querySelectorAll('.view-mode').forEach(btn => btn.classList.remove('active'));
          button.classList.add('active');
          
          const listView = el('#listView');
          const statsView = el('#statsView');
          
          if (mode === 'list') {
            if (listView) listView.style.display = 'block';
            if (statsView) statsView.style.display = 'none';
            generateMissingValuesList();
          } else if (mode === 'stats') {
            if (listView) listView.style.display = 'none';
            if (statsView) statsView.style.display = 'block';
            generateMissingValuesStats();
          }
        });
      });
      
      // Initialize with list view
      setTimeout(() => {
        if (STATE.headers.length > 0) {
          generateMissingValuesList();
        }
      }, 100);
      
      // Generate missing values list view
      function generateMissingValuesList() {
        var listContainer = el('#missingValuesList');
        if (!listContainer || !STATE.headers.length) return;
        
        var missingData = [];
        STATE.headers.forEach(function(header, colIndex) {
          var missingCount = 0;
          var totalCount = STATE.rows.length;
          
          STATE.rows.forEach(function(row) {
            if (isNullish(row[colIndex])) {
              missingCount++;
            }
          });
          
          var percentage = totalCount > 0 ? ((missingCount / totalCount) * 100).toFixed(1) : '0.0';
          var severity = 'low';
          if (parseFloat(percentage) > 50) severity = 'high';
          else if (parseFloat(percentage) > 20) severity = 'medium';
          
          missingData.push({
            column: header,
            missing: missingCount,
            total: totalCount,
            percentage: percentage,
            severity: severity
          });
        });
        
        // Sort by percentage descending
        missingData.sort(function(a, b) { return parseFloat(b.percentage) - parseFloat(a.percentage); });
        
        if (missingData.every(function(item) { return item.missing === 0; })) {
          listContainer.innerHTML = '<div class="no-data">✅ No missing values detected in any column</div>';
          return;
        }
        
        var html = '';
        missingData.forEach(function(item) {
          var statusClass = item.missing === 0 ? 'success' : item.severity;
          var statusText = item.missing === 0 ? 'Complete' : item.percentage + '% missing';
          
          html += '<div class="missing-item ' + item.severity + '">' +
            '<div class="missing-item-content">' +
              '<div class="missing-item-header">' +
                '<strong>' + item.column + '</strong>' +
                '<span class="status-' + statusClass + '">' + statusText + '</span>' +
              '</div>' +
              '<div class="missing-item-details">' +
                item.missing + ' missing of ' + item.total + ' total rows' +
                (item.missing > 0 ? ' • ' + (item.total - item.missing) + ' complete values' : '') +
              '</div>' +
            '</div>' +
          '</div>';
        });
        
        listContainer.innerHTML = html;
      }
      
      // Generate missing values stats view
      function generateMissingValuesStats() {
        var statsContainer = el('#missingValuesStats');
        if (!statsContainer || !STATE.headers.length) return;
        
        var totalCells = STATE.headers.length * STATE.rows.length;
        var totalMissing = 0;
        var columnsWithMissing = 0;
        var rowsWithMissing = 0;
        var completeRows = 0;
        
        // Calculate row-level stats first
        STATE.rows.forEach(function(row) {
          var rowMissing = 0;
          row.forEach(function(cell) {
            if (isNullish(cell)) {
              totalMissing++;
              rowMissing++;
            }
          });
          if (rowMissing > 0) rowsWithMissing++;
          else completeRows++;
        });
        
        // Calculate column-level stats
        var columnStats = [];
        STATE.headers.forEach(function(header, colIndex) {
          var missingCount = 0;
          var uniqueValues = [];
          
          STATE.rows.forEach(function(row) {
            var value = row[colIndex];
            if (isNullish(value)) {
              missingCount++;
            } else {
              if (uniqueValues.indexOf(value) === -1) {
                uniqueValues.push(value);
              }
            }
          });
          
          if (missingCount > 0) columnsWithMissing++;
          
          var completeness = STATE.rows.length > 0 ? 
            (((STATE.rows.length - missingCount) / STATE.rows.length) * 100).toFixed(1) : '100.0';
          
          columnStats.push({
            column: header,
            missing: missingCount,
            complete: STATE.rows.length - missingCount,
            completeness: parseFloat(completeness),
            uniqueValues: uniqueValues.length
          });
        });
        
        // Generate comprehensive stats display
        var overallCompleteness = totalCells > 0 ? 
          (((totalCells - totalMissing) / totalCells) * 100).toFixed(1) : '100.0';
        
        var avgCompleteness = columnStats.length > 0 ?
          (columnStats.reduce(function(sum, col) { return sum + col.completeness; }, 0) / columnStats.length).toFixed(1) : '100.0';
        
        var html = '<div class="stats-breakdown">' +
            '<h4>🔍 Detailed Breakdown</h4>' +
            '<div class="breakdown-grid">' +
              '<div class="breakdown-section">' +
                '<h5>Row Analysis</h5>' +
                '<div class="breakdown-item">' +
                  '<span class="breakdown-label">Complete Rows:</span>' +
                  '<span class="breakdown-value">' + completeRows + ' (' + (STATE.rows.length > 0 ? ((completeRows/STATE.rows.length)*100).toFixed(1) : '0') + '%)</span>' +
                '</div>' +
                '<div class="breakdown-item">' +
                  '<span class="breakdown-label">Rows with Missing:</span>' +
                  '<span class="breakdown-value">' + rowsWithMissing + ' (' + (STATE.rows.length > 0 ? ((rowsWithMissing/STATE.rows.length)*100).toFixed(1) : '0') + '%)</span>' +
                '</div>' +
                '<div class="breakdown-item">' +
                  '<span class="breakdown-label">Total Rows:</span>' +
                  '<span class="breakdown-value">' + STATE.rows.length.toLocaleString() + '</span>' +
                '</div>' +
              '</div>' +
              '<div class="breakdown-section">' +
                '<h5>Column Analysis</h5>' +
                '<div class="breakdown-item">' +
                  '<span class="breakdown-label">Complete Columns:</span>' +
                  '<span class="breakdown-value">' + (STATE.headers.length - columnsWithMissing) + '</span>' +
                '</div>' +
                '<div class="breakdown-item">' +
                  '<span class="breakdown-label">Columns with Missing:</span>' +
                  '<span class="breakdown-value">' + columnsWithMissing + '</span>' +
                '</div>' +
                '<div class="breakdown-item">' +
                  '<span class="breakdown-label">Total Columns:</span>' +
                  '<span class="breakdown-value">' + STATE.headers.length + '</span>' +
                '</div>' +
              '</div>' +
            '</div>' +
          '</div>';
        
        // Add top/bottom columns by quality
        var sortedColumns = columnStats.slice().sort(function(a, b) { return a.completeness - b.completeness; });
        var worstColumns = sortedColumns.slice(0, 5);
        
        var hasProblems = false;
        for (var i = 0; i < worstColumns.length; i++) {
          if (worstColumns[i].completeness < 100) {
            hasProblems = true;
            break;
          }
        }
        
        if (hasProblems) {
          html += '<div class="stats-breakdown">' +
            '<h4>⚠️ Columns Needing Attention</h4>';
          
          worstColumns.forEach(function(col) {
            if (col.completeness < 100) {
              html += '<div class="breakdown-item">' +
                '<span class="breakdown-column">' + col.column + '</span>' +
                '<span class="breakdown-value">' + col.completeness + '% complete (' + col.missing + ' missing)</span>' +
              '</div>';
            }
          });
          
          html += '</div>';
        }
        
        statsContainer.innerHTML = html;
      }
      
      
      // File & drag-drop with enhanced visual feedback
      const dz = el('#dropzone');
      dz.addEventListener('dragenter', e => {
        e.preventDefault();
        dz.classList.add('drag-active');
      });
      dz.addEventListener('dragover', e => { 
        e.preventDefault(); 
        dz.classList.add('drag-active');
      });
      dz.addEventListener('dragleave', e => {
        // Only remove if we're leaving the dropzone entirely
        if (!dz.contains(e.relatedTarget)) {
          dz.classList.remove('drag-active');
        }
      });
      dz.addEventListener('drop', e => {
        e.preventDefault();
        dz.classList.remove('drag-active');
        dz.classList.add('drop-success');
        setTimeout(() => dz.classList.remove('drop-success'), 600);
        
        const file = e.dataTransfer.files[0];
        if (!file || !validateFileType(file) || rejectIfTooBig(file)) return;
        
        // Store file info
        STATE.fileInfo = {
          name: file.name,
          size: file.size,
          type: file.type,
          lastModified: new Date(file.lastModified)
        };
        
        (async () => {
          try {
            // Show progress for large files
            const showProgress = file.size > 5 * 1024 * 1024;
            const showOverlay = file.size > 20 * 1024 * 1024; // Show overlay for very large files
            
            if (showOverlay) {
              showProgressOverlay('Processing file...');
            } else if (showProgress) {
              toast('Processing file...', 'info');
            }
            
            const { headers, rows } = await smartParseFile(file, (progress) => {
              if (showOverlay) {
                updateProgressOverlay(progress);
              } else if (showProgress) {
                toast(`Processing: ${progress}%`, 'info');
              }
            });
            
            if (showOverlay) {
              hideProgressOverlay();
            }
            
            // Delegate dataset assignment to handleFileLoad() so that drag
            // and drop behaves consistently with file selection.  This call
            // decides whether the dataset becomes primary, secondary, or
            // replaces the active dataset, then updates snapshots and the
            // dataset switcher UI.
            handleFileLoad(headers, rows, file.name);
            
            if (showProgress) {
              toast('File loaded successfully!', 'ok');
            }
          } catch (err) {
            hideProgressOverlay();
            // Use toast for friendly error messages
            const fileType = file.name.toLowerCase().endsWith('.xlsx') || file.name.toLowerCase().endsWith('.xls') ? 'Excel' : 'CSV/TSV';
            toast('Error reading file: ' + (err.message || `Invalid ${fileType} format.`), 'error');
          }
        })();
      });
      el('#fileInput')?.addEventListener('change', e => {
        const file = e.target.files[0];
        if (!file || !validateFileType(file) || rejectIfTooBig(file)) return;
        
        // Store file info
        STATE.fileInfo = {
          name: file.name,
          size: file.size,
          type: file.type,
          lastModified: new Date(file.lastModified)
        };
        
        (async () => {
          try {
            // Show progress for large files
            const showProgress = file.size > 5 * 1024 * 1024;
            const showOverlay = file.size > 20 * 1024 * 1024; // Show overlay for very large files
            
            if (showOverlay) {
              showProgressOverlay('Processing file...');
            } else if (showProgress) {
              toast('Processing file...', 'info');
            }
            
            const { headers, rows } = await smartParseFile(file, (progress) => {
              if (showOverlay) {
                updateProgressOverlay(progress);
              } else if (showProgress) {
                toast(`Processing: ${progress}%`, 'info');
              }
            });
            
            if (showOverlay) {
              hideProgressOverlay();
            }
            
            // Delegate dataset assignment to handleFileLoad().  This function
            // decides whether the file becomes the primary dataset, the
            // secondary dataset or replaces the currently active dataset when
            // both slots are already filled.  It also updates snapshots and
            // UI accordingly.
            handleFileLoad(headers, rows, file.name);
            
            if (showProgress) {
              toast('File loaded successfully!', 'ok');
            }
          } catch (err) {
            hideProgressOverlay();
            const fileType = file.name.toLowerCase().endsWith('.xlsx') || file.name.toLowerCase().endsWith('.xls') ? 'Excel' : 'CSV/TSV';
            toast('Error reading file: ' + (err.message || `Invalid ${fileType} format.`), 'error');
          }
        })();
      });
      // Sample data
      const SAMPLE_CSV =
`id,name,email,age,signup_date,plan,region,score
1,Alice Smith,alice@example.com,29,2024-01-05,Pro,NA,62
2,Bob Jones,bobjones@example,41,2023-12-11,Free,EU,48
3,Charlie Day,charlie@example.com,,2025-03-20,Pro,APAC,55
4,Dana Li,dana.li@example.com,35,2024-05-02,Enterprise,NA,77
5,Eric Zhao,eric@example.com,27,2024-06-21,Pro,EU,52
6,Fatima Noor,fatima.noor@example.com,31,2024-07-01,Free,APAC,45
7,Gary Kim,gary.kim@example.com,29,2024-07-10,Free,NA,999
8,Hiro Tanaka,hiro@example.com,38,2023-11-29,Pro,APAC,50
9,Iris Patel,iris@example.com,29,2025-02-14,Pro,NA,61
10,Juan Gomez,juan@example.com,29,2024-04-18,Free,EU,44
11,Kai Chen,kai@example.com,41,2024-02-07,Enterprise,NA,78
12,Lena Müller,lena.mueller@example.com,33,2024-05-30,Pro,EU,51
13,Mohammed Ali,mo.ali@example.com,28,2024-06-11,Pro,ME,49
14,Nina Rossi,nina.rossi@example.com,36,2025-01-03,Pro,EU,
15,Oscar Diaz,oscar@example.com,29,2024-02-25,Free,NA,47
16,Pat Quinn,pat.quinn@example.com,NaN,2023-12-12,Free,NA,46
17,Quinn Lee,quinn.lee@example.com,28,2024-08-01,Basic,EU,50
18,Ravi Singh,ravi@example.com,39,2024-03-15,Enterprise,APAC,80
19,Sara O'Neil,sara.oneil@example.com,27,2024-04-01,Pro,NA,58
20,Tae Park,tae.park@example.com,31,2024-02-02,Pro,APAC,53
21,Juan Gomez,juan@example.com,29,2024-04-18,Free,EU,44
22,Vincent Zhou,vincent@example.com,34,2024-07-15,Pro,NA,51
23,Wei Zhang,wei@example.com,,2024-06-20,Free,APAC,43
24,Xia Li,xia.li@example.com,28,2024-07-22,Pro,EU,52
25,Yara Haddad,yara@example,33,2024-05-05,Pro,ME,54
26,Zoe Brown,zoe.brown@example.com,27,2024-08-01,Enterprise,NA,75`;
      // Undo/Redo button handlers
      el('#undoBtn')?.addEventListener('click', () => {
        if (undoRedoManager.undo()) {
          toast('Undone: ' + undoRedoManager.getRedoDescription(), 'ok');
        }
      });
      
      el('#redoBtn')?.addEventListener('click', () => {
        if (undoRedoManager.redo()) {
          toast('Redone: ' + undoRedoManager.getUndoDescription(), 'ok');
        }
      });
      
      // Keyboard shortcuts for undo/redo
      document.addEventListener('keydown', (e) => {
        // Ctrl+Z or Cmd+Z for undo
        if ((e.ctrlKey || e.metaKey) && e.key === 'z' && !e.shiftKey) {
          e.preventDefault();
          if (undoRedoManager.undo()) {
            toast('Undone: ' + undoRedoManager.getRedoDescription(), 'ok');
          }
        }
        // Ctrl+Y or Ctrl+Shift+Z or Cmd+Shift+Z for redo
        else if (((e.ctrlKey || e.metaKey) && e.key === 'y') || 
                 ((e.ctrlKey || e.metaKey) && e.shiftKey && e.key === 'Z')) {
          e.preventDefault();
          if (undoRedoManager.redo()) {
            toast('Redone: ' + undoRedoManager.getUndoDescription(), 'ok');
          }
        }
      });
      
      el('#loadSample')?.addEventListener('click', () => {
        const { headers, rows } = parseCSV(SAMPLE_CSV);
        
        // Set file info for sample data
        STATE.fileInfo = {
          name: 'Sample Dataset',
          size: SAMPLE_CSV.length,
          type: 'text/csv',
          lastModified: new Date()
        };
        
        // Build a larger sample by repeating the base rows until we have a good dataset.
        const replicated = [];
        const targetSize = Math.max(400, rows.length * 20); // Scale based on original sample size
        while (replicated.length < targetSize) {
          for (const r of rows) {
            replicated.push(r.slice());
            if (replicated.length >= targetSize) break;
          }
        }
        // Introduce small errors across the dataset for demonstration purposes.
        replicated.forEach((row, idx) => {
          // Every 10th row: corrupt the email address
          if (idx % 10 === 0) row[2] = 'invalid_email';
          // Every 15th row: blank out the age field
          if (idx % 15 === 0) row[3] = '';
          // Every 20th row: provide an invalid date string
          if (idx % 20 === 0) row[4] = '2024-13-32';
          // Every 25th row: assign an unknown plan value
          if (idx % 25 === 0) row[5] = 'Unknown';
        });
        // Use handleFileLoad() to assign the sample dataset as either the
        // primary or secondary dataset (or replace the active one if both
        // slots are already filled).  This ensures that loading the sample
        // integrates with dataset switching logic.
        handleFileLoad(headers, replicated, '\uD83D\uDCCE sample_customers_400.csv');
      });
      // Run rules
      el('#runRules')?.addEventListener('click', () => {
        if (!STATE.headers.length) return;
        const allowInputs = els('.rule-input.allow');
        const allowArr = [];
        const allowStrArr = [];
        for (let i=0; i<STATE.headers.length; i++) {
          const allowStr = (allowInputs[i]?.value || '').trim();
          allowStrArr.push(allowStr);
          allowArr.push(allowStr ? new Set(allowStr.split(',').map(s => s.trim())) : null);
        }
        STATE.rules.allowed = allowArr;
        STATE.rules.allowedStr = allowStrArr;
        STATE.ruleResults = runRuleChecks(STATE.headers, STATE.rows, STATE.rules);
        renderProfiles(STATE.headers, STATE.profiles, STATE.rules, STATE.ruleResults);
        renderInvalidTable(STATE.headers, STATE.ruleResults);
      });
      // Save rules
      el('#saveRules')?.addEventListener('click', () => {
        if (!STATE.headers.length) return;
        const allowInputs = els('.rule-input.allow');
        const allowStrs = STATE.headers.map((_,i) => (allowInputs[i]?.value || '').trim());
        const rxStrs    = STATE.headers.map(() => '');
        const res = saveRules(STATE.headerSig, STATE.headers, rxStrs, allowStrs);
        if (res.ok) showRulesStatus('Rules saved','ok');
        else showRulesStatus('Failed to save rules','error');
      });
      // Clear rules
      el('#clearRules')?.addEventListener('click', () => {
        if (!STATE.headers.length) return;
        const ok = clearRulesLS(STATE.headerSig);
        // Reset to suggestions
        STATE.rules.allowedStr = [...STATE.suggestions.allowedStr];
        STATE.rules.allowed = new Array(STATE.headers.length).fill(null);
        STATE.ruleResults = null;
        renderProfiles(STATE.headers, STATE.profiles, STATE.rules, STATE.ruleResults);
        renderInvalidTable(STATE.headers, null);
        showRulesStatus(ok ? 'Rules cleared' : 'Could not clear rules', ok ? 'ok' : 'error');
      });
      // Download rules
      el('#downloadRules')?.addEventListener('click', () => {
        if (!STATE.headers.length) return;
        const allowInputs = els('.rule-input.allow');
        const allowStrs = STATE.headers.map((_,i) => (allowInputs[i]?.value || '').trim());
        const payload = {
          signature: STATE.headerSig,
          exportedAt: new Date().toISOString(),
          headers: [...STATE.headers],
          columns: STATE.headers.map((name,i) => ({ name, regex: '', allowed: allowStrs[i] || '' }))
        };
        const safeName = (el('#datasetName').textContent || 'rules').replace(/[^\w\-\.]+/g,'_');
        download(`Rules_${safeName}.json`, JSON.stringify(payload, null, 2));
      });
      // Export data dictionary
      el('#exportDict')?.addEventListener('click', () => {
        exportDataDict(STATE.headers, STATE.profiles, STATE.rules, STATE.ruleResults);
      });
      // Nav button proxies: trigger underlying buttons.  The "Load File" button opens the
      // hidden file input so the user can choose a CSV/TSV.  Previously this triggered the
      // built‑in sample dataset (via #loadSample), but the nav label now refers to loading
      // a file, so clicking the button clicks #fileInput instead.
      el('#navLoadSample')?.addEventListener('click', () => {
        const inp = el('#fileInput');
        if (inp) {
          inp.value = '';
          inp.click();
        }
      });
      // Connect Field Overview panel buttons to main rule functions
      el('#navSaveRules')?.addEventListener('click', () => {
        const target = el('#saveRules');
        if (target) target.click();
      });
      el('#navDownloadRules')?.addEventListener('click', () => {
        const target = el('#downloadRules');
        if (target) target.click();
      });
      el('#navClearRules')?.addEventListener('click', () => {
        const target = el('#clearRules');
        if (target) target.click();
      });
      el('#navRunRules')?.addEventListener('click', () => {
        const target = el('#runRules');
        if (target) target.click();
      });

      // Salesforce ID conversion utilities
      function isValidSalesforceId15(id) {
        const base = String(id || '').trim();
        // Must be exactly 15 characters
        if (base.length !== 15) return false;
        // Must contain only alphanumeric characters
        if (!/^[a-zA-Z0-9]{15}$/.test(base)) return false;
        // Salesforce IDs typically start with 3 characters that identify the object type
        // Common patterns include: 001 (Account), 003 (Contact), 006 (Opportunity), etc.
        // The first 3 chars are usually consistent format
        return true;
      }

      function to18CharId(id15) {
        const base = String(id15 || '').trim();
        
        // Only convert if it's a valid 15-digit Salesforce ID
        if (!isValidSalesforceId15(base)) {
          return base; // Return unchanged if not a valid 15-digit ID
        }
        
        const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ012345';
        let suffix = '';
        
        // Process each group of 5 characters
        for (let i = 0; i < 3; i++) {
          let flags = 0;
          const group = base.substring(i * 5, (i + 1) * 5);
          
          // Check each character in the group (from right to left for correct bit position)
          for (let j = 0; j < 5; j++) {
            const c = group.charAt(j);
            // If character is uppercase (A-Z), set the corresponding bit
            if (c >= 'A' && c <= 'Z') {
              flags |= (1 << j);
            }
          }
          
          // Use the flags value as index into the character array
          suffix += chars.charAt(flags);
        }
        
        // Return the original base (preserving case) plus the calculated suffix
        return base + suffix;
      }

      // Merge modal interactions
      el('#navMerge')?.addEventListener('click', () => {
        showMergeModal();
      });

      // Help modal: show/hide
      el('#navHelp')?.addEventListener('click', () => {
        const modal = el('#helpModal');
        if (modal) modal.classList.remove('hidden');
      });
      el('#helpClose')?.addEventListener('click', () => {
        const modal = el('#helpModal');
        if (modal) modal.classList.add('hidden');
      });
      
      // Dev Log modal: show/hide
      el('#devLogOpen')?.addEventListener('click', () => {
        const modal = el('#devLogModal');
        if (modal) modal.classList.remove('hidden');
      });
      el('#devLogClose')?.addEventListener('click', () => {
        const modal = el('#devLogModal');
        if (modal) modal.classList.add('hidden');
      });

      // Histograms modal: show/hide and functions
      el('#navHistograms')?.addEventListener('click', () => {
        if (!STATE.headers.length || !STATE.rows.length) {
          toast('Please load a dataset first', 'error');
          return;
        }
        generateHistograms();
        const modal = el('#histogramsModal');
        if (modal) modal.classList.remove('hidden');
      });
      el('#histogramsClose')?.addEventListener('click', () => {
        const modal = el('#histogramsModal');
        if (modal) modal.classList.add('hidden');
      });
      el('#printHistograms')?.addEventListener('click', () => {
        printHistogramsPage();
      });

      // Settings modal interactions: open, save and cancel
      el('#navSettings')?.addEventListener('click', () => {
        const modal = el('#settingsModal');
        if (!modal) return;
        // Populate fields from current preferences
        const p = PREFS || loadPrefs();
        const dops = p.defaultOps || {};
        const setVal = (sel, val) => { const e = el(sel); if (e) e.value = val; };
        const setChecked = (sel, val) => { const e = el(sel); if (e) e.checked = !!val; };
        setVal('#prefTheme', p.theme || 'dark');
        setChecked('#prefTrim', dops.trim);
        setChecked('#prefNormalize', dops.normalize);
        setChecked('#prefClean', dops.clean);
        setChecked('#prefSf', dops.sf);
        setVal('#prefLang', p.language || 'en');
        setChecked('#prefPersist', p.persist);
        setChecked('#prefEncrypt', p.encrypt);
        const pass = el('#prefPass'); if (pass) pass.value = '';
        modal.classList.remove('hidden');
      });
      el('#settingsCancel')?.addEventListener('click', () => {
        const m = el('#settingsModal');
        if (m) m.classList.add('hidden');
      });
      el('#settingsSave')?.addEventListener('click', () => {
        // Update PREFS with form values
        PREFS.theme = el('#prefTheme').value;
        PREFS.defaultOps = {
          trim: el('#prefTrim').checked,
          normalize: el('#prefNormalize').checked,
          clean: el('#prefClean').checked,
          sf: el('#prefSf').checked
        };
        PREFS.language = el('#prefLang').value;
        PREFS.persist = el('#prefPersist').checked;
        PREFS.encrypt = el('#prefEncrypt').checked;
        // Save and apply preferences
        savePrefs(PREFS);
        applyPrefsToUI(PREFS);
        toast('Settings saved','ok');
        const m = el('#settingsModal');
        if (m) m.classList.add('hidden');
      });
      el('#mergeFileInput')?.addEventListener('change', () => {
        onMergeFileSelected();
      });
      el('#mergeCancel')?.addEventListener('click', () => {
        hideMergeModal();
      });
      el('#mergeDo')?.addEventListener('click', () => {
        mergeDatasets();
      });

      // Wire up the export buttons.  Because sections of the UI are
      // sometimes re-rendered or replaced, event listeners can be lost.
      // We centralise the binding logic in a helper and call it both on
      // initial page load and after each computeAndRender.
      function bindExportButtons() {
        const dupBtn = el('#exportExactDupCsv');
        if (dupBtn) {
          // Remove duplicate binding - handled by global click handler
          dupBtn.onclick = null;
        }
        const fuzzyBtn = el('#exportFuzzyCrossCsv');
        if (fuzzyBtn) {
          fuzzyBtn.onclick = () => {
            exportFuzzyCrossCsv();
          };
        }
      }
      // Perform the initial binding.  computeAndRender() will call
      // bindExportButtons again after each render.
      bindExportButtons();

      // Use event delegation to ensure that export buttons work even if
      // they are replaced or re-rendered.  Delegation listens on the
      // document and dispatches based on element IDs.  This complements
      // the explicit bindings provided by bindExportButtons().
      document.addEventListener('click', (evt) => {
        const t = evt.target;
        if (!t || !(t instanceof HTMLElement)) return;
        const id = t.id;
        if (id === 'exportExactDupCsv') {
          exportExactDupCsv();
        } else if (id === 'exportFuzzyCrossCsv') {
          exportFuzzyCrossCsv();
        }
      });

      /*
        =====================================================================
        Cross‑File Merging & ID Matching
        ---------------------------------------------------------------------
        Provides a modal interface for merging the currently loaded dataset
        with a second CSV/TSV file. Users select the key columns from
        each dataset, choose a join type (left or inner), and opt to
        convert 15‑character Salesforce IDs to 18‑character IDs for
        matching. The merged result is downloaded as a CSV with all
        columns from both datasets. Columns from the second dataset
        that duplicate names in the primary dataset are suffixed with
        "__2" (or increasing numbers) to prevent collisions.
      */
      const MERGE = { headers: null, rows: null, fileName: '' };
      function showMergeModal() {
        if (!STATE.headers.length) {
          showRulesStatus('Please load a dataset first','error');
          return;
        }
        // Reset stored second file
        MERGE.headers = null;
        MERGE.rows = null;
        MERGE.fileName = '';
        // Reset UI elements
        el('#mergeFileInput').value = '';
        el('#mergeStepFile').style.display = 'block';
        el('#mergeStepOptions').style.display = 'none';
        el('#mergeDo').disabled = true;
        // Populate primary key select
        const primSel = el('#mergePrimaryCol');
        primSel.innerHTML = '';
        STATE.headers.forEach((name, idx) => {
          const opt = document.createElement('option');
          opt.value = String(idx);
          opt.textContent = name;
          primSel.appendChild(opt);
        });
        // Clear secondary select
        const secSel = el('#mergeSecondaryCol');
        secSel.innerHTML = '';
        // Show modal
        el('#mergeModal').classList.remove('hidden');
      }
      function hideMergeModal() {
        el('#mergeModal').classList.add('hidden');
      }
      async function parseMergeFile(file, callback) {
        try {
          const { headers, rows } = await smartParseFile(file);
          callback(null, { headers, rows });
        } catch (err) {
          callback(err);
        }
      }
      function onMergeFileSelected() {
        const fileInput = el('#mergeFileInput');
        const file = fileInput.files[0];
        if (!file) return;
        parseMergeFile(file, (err, data) => {
          if (err || !data) {
            showRulesStatus('Failed to parse merge file','error');
            return;
          }
          MERGE.headers = data.headers;
          MERGE.rows = data.rows;
          MERGE.fileName = file.name;
          // Persist the secondary dataset into global STATE.  This allows the app
          // to retain a second dataset in memory for future cross‑file operations
          // such as fuzzy matching.  We store both headers and rows along with
          // the uploaded file name.  Primary dataset state remains untouched.
          STATE.secondaryHeaders = data.headers.slice();
          STATE.secondaryRows = data.rows.map(row => row.slice());
          STATE.secondaryName = file.name;
          // Populate secondary key select
          const secSel = el('#mergeSecondaryCol');
          secSel.innerHTML = '';
          MERGE.headers.forEach((name, idx) => {
            const opt = document.createElement('option');
            opt.value = String(idx);
            opt.textContent = name;
            secSel.appendChild(opt);
          });
          // Show options step
          el('#mergeStepFile').style.display = 'none';
          el('#mergeStepOptions').style.display = 'block';
          el('#mergeDo').disabled = false;

        // Enable the secondary option in the dataset switcher since a
        // secondary dataset is now available.  The UI text will reflect the
        // uploaded file name.
        updateDatasetSwitchUI();
        });
      }
      
      function mergeDatasets() {
        if (!MERGE.headers || !MERGE.rows) {
          hideMergeModal();
          return;
        }
        const primIdx = parseInt(el('#mergePrimaryCol').value, 10);
        const secIdx = parseInt(el('#mergeSecondaryCol').value, 10);
        if (isNaN(primIdx) || isNaN(secIdx)) {
          hideMergeModal();
          return;
        }
        const convert = el('#mergeConvertIds').checked;
        const joinType = el('#mergeJoinType').value || 'left';

        const getKey = (v) => {
          let key = String(v ?? '').trim();
          if (convert) key = to18CharId(key);
          return key;
        };

        const secMap = new Map();
        for (const row of MERGE.rows) {
          const k = getKey(row[secIdx]);
          if (!k) continue;
          if (!secMap.has(k)) secMap.set(k, row);
        }
        const primMap = new Map();
        for (const row of STATE.rows) {
          const k = getKey(row[primIdx]);
          if (!k) continue;
          if (!primMap.has(k)) primMap.set(k, row);
        }

        const primaryHeaders = STATE.headers;
        const secondaryHeaders = MERGE.headers;
        const newHeaders = [...primaryHeaders];
        secondaryHeaders.forEach((h) => {
          if (newHeaders.includes(h)) {
            let suffix = 2;
            let candidate = `${h}__${suffix}`;
            while (newHeaders.includes(candidate)) {
              suffix++;
              candidate = `${h}__${suffix}`;
            }
            newHeaders.push(candidate);
          } else {
            newHeaders.push(h);
          }
        });

        const newRows = [];

        if (joinType === 'inner') {
          for (const prow of STATE.rows) {
            const k = getKey(prow[primIdx]);
            if (!k) continue;
            const srow = secMap.get(k);
            if (!srow) continue;
            const combined = [...prow];
            srow.forEach(v => combined.push(v));
            newRows.push(combined);
          }
        } else if (joinType === 'left') {
          for (const prow of STATE.rows) {
            const k = getKey(prow[primIdx]);
            const srow = k ? secMap.get(k) : null;
            const combined = [...prow];
            if (srow) srow.forEach(v => combined.push(v));
            else for (let i=0; i<MERGE.headers.length; i++) combined.push('');
            newRows.push(combined);
          }
        } else if (joinType === 'right') {
          for (const srow of MERGE.rows) {
            const k = getKey(srow[secIdx]);
            const prow = k ? primMap.get(k) : null;
            const combined = [];
            if (prow) {
              for (let i=0; i<primaryHeaders.length; i++) combined.push(prow[i] ?? '');
            } else {
              for (let i=0; i<primaryHeaders.length; i++) combined.push('');
            }
            srow.forEach(v => combined.push(v));
            newRows.push(combined);
          }
        } else if (joinType === 'full') {
          const primaryKeySet = new Set();
          for (const prow of STATE.rows) {
            const k = getKey(prow[primIdx]);
            if (k) primaryKeySet.add(k);
            const srow = k ? secMap.get(k) : null;
            const combined = [...prow];
            if (srow) srow.forEach(v => combined.push(v));
            else for (let i=0; i<MERGE.headers.length; i++) combined.push('');
            newRows.push(combined);
          }
          for (const srow of MERGE.rows) {
            const k = getKey(srow[secIdx]);
            if (k && primaryKeySet.has(k)) continue;
            const combined = [];
            for (let i=0; i<primaryHeaders.length; i++) combined.push('');
            srow.forEach(v => combined.push(v));
            newRows.push(combined);
          }
        } else {
          for (const prow of STATE.rows) {
            const k = getKey(prow[primIdx]);
            const srow = k ? secMap.get(k) : null;
            const combined = [...prow];
            if (srow) srow.forEach(v => combined.push(v));
            else for (let i=0; i<MERGE.headers.length; i++) combined.push('');
            newRows.push(combined);
          }
        }

        const primName = (el('#datasetName').textContent || 'primary').replace(/[^\w\-.]+/g,'_');
        const secName = (MERGE.fileName || 'secondary').replace(/[^\w\-.]+/g,'_');
        download(`merged_${primName}_${secName}.csv`, toCSV(newRows, newHeaders));
        hideMergeModal();
        showRulesStatus('Merged file downloaded','ok');
      }



      // Theme toggle: cycles between dark, light and high‑tech modes.  Theme
      // selection is stored in the PREFS object and persisted via
      // savePrefs().
      const themeBtn = el('#themeToggle');
      function setTheme(mode) {
        // Remove both optional theme classes first
        document.body.classList.remove('theme-light','theme-matrix');
        
        // Remove any existing ASCII title
        const existingAscii = document.querySelector('.matrix-ascii');
        if (existingAscii) {
          existingAscii.remove();
        }
        
        if (mode === 'light') {
          document.body.classList.add('theme-light');
          // Next mode label: after light comes matrix
          themeBtn.textContent = 'Matrix Mode';
          // Start gentle sparkle effect
          startLightSparkles();
          // Clean up other theme effects
          stopDarkCosmic();
        } else if (mode === 'matrix') {
          document.body.classList.add('theme-matrix');
          // Next mode label: after matrix comes dark
          themeBtn.textContent = 'Dark Mode';
          // Start subtle Matrix digital rain effect
          startMatrixRain();
          // Clean up Light effects when leaving Light mode
          stopLightSparkles();
          // Clean up Dark effects when leaving Dark mode
          stopDarkCosmic();
        } else {
          // Dark mode: no theme class on body
          themeBtn.textContent = 'Light Mode';
          // Clean up Matrix effects when leaving Matrix mode
          stopMatrixRain();
          // Clean up Light effects when leaving Light mode
          stopLightSparkles();
          // Start cosmic dust effect for Dark mode
          startDarkCosmic();
        }
      }
      
      // Matrix digital rain effect
      let matrixRainInterval = null;
      const matrixChars = '01アイウエオカキクケコサシスセソタチツテトナニヌネノハヒフヘホマミムメモヤユヨラリルレロワヲン';
      
      function startMatrixRain() {
        // Clean up any existing rain
        stopMatrixRain();
        
        // Create subtle falling characters
        matrixRainInterval = setInterval(() => {
          if (!document.body.classList.contains('theme-matrix')) {
            stopMatrixRain();
            return;
          }
          
          // Create very dense rain effect (200% more particles)
          if (Math.random() > 0.6) {
            createMatrixParticle();
            createMatrixParticle(); // 2nd particle
            createMatrixParticle(); // 3rd particle (200% increase = 3x total)
          }
        }, 80);
      }
      
      function stopMatrixRain() {
        if (matrixRainInterval) {
          clearInterval(matrixRainInterval);
          matrixRainInterval = null;
        }
        
        // Remove existing particles
        document.querySelectorAll('.matrix-particle').forEach(p => p.remove());
      }
      
      function createMatrixParticle() {
        const particle = document.createElement('div');
        particle.className = 'matrix-particle';
        particle.textContent = matrixChars[Math.floor(Math.random() * matrixChars.length)];
        particle.style.left = Math.random() * 100 + 'vw';
        particle.style.animationDuration = (Math.random() * 6.75 + 4.5) + 's'; // 4.5-11.25 seconds (50% slower again)
        particle.style.opacity = Math.random() * 0.4 + 0.3; // 0.3-0.7 opacity
        
        document.body.appendChild(particle);
        
        // Remove particle after animation
        setTimeout(() => {
          if (particle.parentNode) {
            particle.remove();
          }
        }, 5000);
      }
      
      // Particle systems for all themes
      let lightSparkleInterval = null;
      let darkCosmicInterval = null;
      const sparkleSymbols = '✨⭐💫🌟⚡';
      const cosmicSymbols = '·•◦○●◯⋅∘';
      
      function startLightSparkles() {
        // Clean up any existing sparkles
        stopLightSparkles();
        
        // Create gentle floating sparkles
        lightSparkleInterval = setInterval(() => {
          if (!document.body.classList.contains('theme-light')) {
            stopLightSparkles();
            return;
          }
          
          // Create sparkles frequently for better visibility (200% more - doubled again)
          if (Math.random() > 0.3) {
            createLightSparkle();
            // Add second sparkle
            if (Math.random() > 0.5) {
              createLightSparkle();
            }
            // Add third sparkle for double density
            if (Math.random() > 0.6) {
              createLightSparkle();
            }
            // Add fourth sparkle for maximum density
            if (Math.random() > 0.8) {
              createLightSparkle();
            }
          }
        }, 100);
      }
      
      function stopLightSparkles() {
        if (lightSparkleInterval) {
          clearInterval(lightSparkleInterval);
          lightSparkleInterval = null;
        }
        
        // Remove existing sparkles
        document.querySelectorAll('.light-sparkle').forEach(s => s.remove());
      }
      
      function createLightSparkle() {
        const sparkle = document.createElement('div');
        sparkle.className = 'light-sparkle';
        // No text content needed - using pure CSS particle
        sparkle.style.left = Math.random() * 100 + 'vw';
        sparkle.style.animationDuration = (Math.random() * 7 + 5.25) + 's'; // 5.25-12.25 seconds (75% slower)
        sparkle.style.opacity = Math.random() * 0.6 + 0.4; // 0.4-1.0 opacity for better visibility
        
        document.body.appendChild(sparkle);
        
        // Remove sparkle after animation
        setTimeout(() => {
          if (sparkle.parentNode) {
            sparkle.remove();
          }
        }, 13000); // Extended cleanup time to match slower animation
      }
      
      // Dark theme cosmic dust particle system
      function startDarkCosmic() {
        // Clean up any existing cosmic dust
        stopDarkCosmic();
        
        // Create gentle cosmic dust particles
        darkCosmicInterval = setInterval(() => {
          if (document.body.classList.contains('theme-light') || document.body.classList.contains('theme-matrix')) {
            stopDarkCosmic();
            return;
          }
          
          // Create cosmic dust particles (doubled density)
          if (Math.random() > 0.3) {
            createCosmicDust();
            // Add second particle for doubling
            if (Math.random() > 0.5) {
              createCosmicDust();
            }
            // Add third particle for extra density
            if (Math.random() > 0.7) {
              createCosmicDust();
            }
          }
        }, 200);
      }
      
      function stopDarkCosmic() {
        if (darkCosmicInterval) {
          clearInterval(darkCosmicInterval);
          darkCosmicInterval = null;
        }
        
        // Remove existing cosmic dust
        document.querySelectorAll('.cosmic-dust').forEach(d => d.remove());
      }
      
      function createCosmicDust() {
        const dust = document.createElement('div');
        dust.className = 'cosmic-dust';
        // No text content needed - using pure CSS particle
        
        // Use Matrix-style falling spawn pattern
        dust.style.left = Math.random() * 100 + 'vw';
        dust.style.animationDuration = (Math.random() * 6.75 + 4.5) + 's'; // 4.5-11.25 seconds (same as Matrix)
        dust.style.opacity = Math.random() * 0.4 + 0.3; // 0.3-0.7 opacity
        
        document.body.appendChild(dust);
        
        // Remove particle after animation (same timing as Matrix)
        setTimeout(() => {
          if (dust.parentNode) {
            dust.remove();
          }
        }, 12000);
      }
      
      // Load preferences and apply them (theme & default operations) once the DOM is ready.
      PREFS = loadPrefs();
      applyPrefsToUI(PREFS);
      // Attach theme cycle handler: update PREFS.theme and persist
      themeBtn?.addEventListener('click', () => {
        const current = PREFS.theme || 'dark';
        let next;
        if (current === 'dark') next = 'light';
        else if (current === 'light') next = 'matrix';
        else next = 'dark';
        PREFS.theme = next;
        setTheme(next);
        savePrefs(PREFS);
      });

      // Initialise dataset switcher UI.  The select element allows the user
      // to switch between the primary dataset and a secondary dataset that
      // may have been loaded via the merge dialog.  When the page first
      // loads, secondary data does not exist, so the option is disabled.
      const dsSwitch = el('#datasetSwitch');
      if (dsSwitch) {
        // Populate initial UI state
        updateDatasetSwitchUI();
        // Also initialise cross‑file fuzzy selectors on first load
        initFuzzyCrossUI();
        dsSwitch.addEventListener('change', (e) => {
          const val = e.target.value;
          // Switch active dataset and load the appropriate data into STATE
          if (val === 'primary') {
            STATE.activeDataset = 'primary';
            if (STATE.primaryHeaders && STATE.primaryHeaders.length) {
              const hdrs = STATE.primaryHeaders.map(h => h);
              const rows = STATE.primaryRows.map(r => r.slice());
              computeAndRender(hdrs, rows, STATE.primaryName || 'Primary');
            }
          } else if (val === 'secondary') {
            STATE.activeDataset = 'secondary';
            if (STATE.secondaryHeaders && STATE.secondaryHeaders.length) {
              const hdrs = STATE.secondaryHeaders.map(h => h);
              const rows = STATE.secondaryRows.map(r => r.slice());
              computeAndRender(hdrs, rows, STATE.secondaryName || 'Secondary');
            }
          }
          // Update UI after switching
          updateDatasetSwitchUI();
        });
      }

      /*
        =====================================================================
        Fuzzy Duplicate Detection
        ---------------------------------------------------------------------
        Provides an interface to detect near‑duplicate values in a chosen
        column using the Levenshtein similarity ratio. Users select a column
        and specify a threshold (between 0.50 and 1.00); the app searches
        through non‑null values in that column and groups rows whose values
        are similar above the threshold. Results are displayed in the Fuzzy
        Duplicates section. Note: fuzzy matching on very large columns may
        take significant time.
      */
      // Compute Levenshtein distance between two strings
      function levenshtein(a, b) {
        if (a === b) return 0;
        const n = a.length, m = b.length;
        if (n === 0) return m;
        if (m === 0) return n;
        // Initialize matrix
        const v0 = new Array(m+1);
        const v1 = new Array(m+1);
        for (let j=0; j<=m; j++) v0[j] = j;
        for (let i=0; i<n; i++) {
          v1[0] = i+1;
          const chA = a.charCodeAt(i);
          for (let j=0; j<m; j++) {
            const cost = (chA === b.charCodeAt(j)) ? 0 : 1;
            v1[j+1] = Math.min(
              v1[j] + 1,
              v0[j+1] + 1,
              v0[j] + cost
            );
          }
          for (let j=0; j<=m; j++) v0[j] = v1[j];
        }
        return v1[m];
      }
      // Similarity ratio based on Levenshtein distance
      function similarity(a, b) {
        if (!a || !b) return 0;
        if (a === b) return 1;
        const maxLen = Math.max(a.length, b.length);
        if (maxLen === 0) return 1;
        const dist = levenshtein(a, b);
        return 1 - (dist / maxLen);
      }
      // Initialise fuzzy duplicates UI: populate column dropdown

      /**
       * Export the currently loaded dataset to a CSV with exact duplicates
       * highlighted.  A new column called "duplicate_group" is appended to
       * the dataset.  Duplicate rows are labelled with group numbers
       * (Group 1, Group 2, ...).  Original rows in each group remain
       * unlabelled.  This helper is triggered by the "Export duplicates CSV"
       * button in the Exact Duplicates section.
       */
      function exportExactDupCsv() {
        // Ensure there is a dataset loaded
        if (!STATE.headers || !STATE.headers.length || !STATE.rows || !STATE.rows.length) {
          toast('No dataset loaded', 'error');
          return;
        }
        // Create new headers and rows with columns for both exact and fuzzy duplicates
        const newHeaders = [...STATE.headers, 'exact_duplicate_group', 'fuzzy_duplicate_group'];
        const newRows = STATE.rows.map(r => [...r, '', '']);
        
        // Assign exact duplicate group labels
        if (Array.isArray(STATE.dupes) && STATE.dupes.length) {
          STATE.dupes.forEach((grp, grpIdx) => {
            grp.forEach((rowIdx, idxInGroup) => {
              // Skip the first index (treat original as not a duplicate)
              if (idxInGroup > 0 && newRows[rowIdx]) {
                newRows[rowIdx][newHeaders.length - 2] = `Exact-${grpIdx + 1}`;
              }
            });
          });
        }
        
        // Assign fuzzy duplicate group labels
        if (STATE.fuzzyDuplicates && STATE.fuzzyDuplicates.fuzzy && STATE.fuzzyDuplicates.fuzzy.length) {
          STATE.fuzzyDuplicates.fuzzy.forEach((grp, grpIdx) => {
            grp.forEach((rowIdx, idxInGroup) => {
              // Skip the first index (treat original as not a duplicate)
              if (idxInGroup > 0 && newRows[rowIdx]) {
                newRows[rowIdx][newHeaders.length - 1] = `Fuzzy-${grpIdx + 1}`;
              }
            });
          });
        }
        // Generate CSV and trigger download
        const csv = toCSV(newRows, newHeaders);
        // Build a safe file name based on the dataset name
        const datasetLabel = (el('#datasetName') && el('#datasetName').textContent) ? el('#datasetName').textContent : 'data';
        const safeName = datasetLabel.replace(/[\\/:*?"<>|]+/g, '_');
        download(`duplicates_${safeName}.csv`, csv);
        toast('Duplicates exported', 'ok');
      }

      /**
       * Export merged primary and secondary datasets with cross‑file fuzzy
       * duplicates highlighted.  A new column called "duplicate_group" is
       * appended to the combined dataset.  Each matched pair is assigned
       * a group number; rows that are part of a cross‑file match will share
       * the same group label.  Original rows without a match remain blank.
       * This helper is triggered by the "Export cross‑file duplicates" button
       * in the Approximate Duplicates section.
       */
      function exportFuzzyCrossCsv() {
        // Validate that a secondary dataset is loaded
        if (!Array.isArray(STATE.secondaryHeaders) || !STATE.secondaryHeaders.length ||
            !Array.isArray(STATE.primaryHeaders) || !STATE.primaryHeaders.length) {
          toast('Load a secondary dataset first', 'error');
          return;
        }
        // Determine the selected columns and threshold
        const aSel = el('#fuzzyACol');
        const bSel = el('#fuzzyBCol');
        if (!aSel || !bSel) {
          toast('Cross‑file selectors missing', 'error');
          return;
        }
        const colA = aSel.value;
        const colB = bSel.value;
        if (!colA || !colB) {
          toast('Pick columns to compare', 'error');
          return;
        }
        // Parse threshold
        const thrInput = el('#fuzzyThreshold');
        let threshold = 0.85;
        if (thrInput && thrInput.value) {
          const t = parseFloat(thrInput.value);
          if (!isNaN(t)) threshold = t;
        }
        // Run cross‑file fuzzy matching to retrieve pairs
        const res = findFuzzyCross(colA, colB, threshold);
        if (res.error) {
          toast(res.error, 'error');
          return;
        }
        // Build group mappings for primary and secondary row indices
        const groupMapPrimary = {};
        const groupMapSecondary = {};
        let nextGroup = 1;
        if (Array.isArray(res.pairs)) {
          res.pairs.forEach(pair => {
            // Determine existing group assignment
            let g = groupMapPrimary[pair.a] || groupMapSecondary[pair.b];
            if (!g) {
              g = nextGroup++;
            }
            groupMapPrimary[pair.a] = g;
            groupMapSecondary[pair.b] = g;
          });
        }
        // Construct combined headers: prefix primary and secondary headers to
        // distinguish between columns, then add a duplicate_group column
        const pHeaders = STATE.primaryHeaders || [];
        const sHeaders = STATE.secondaryHeaders || [];
        const combinedHeaders = [];
        pHeaders.forEach(h => combinedHeaders.push('primary_' + h));
        sHeaders.forEach(h => combinedHeaders.push('secondary_' + h));
        combinedHeaders.push('duplicate_group');
        // Combine rows: all primary rows first, then all secondary rows
        const combinedRows = [];
        if (Array.isArray(STATE.primaryRows)) {
          STATE.primaryRows.forEach((row, idx) => {
            const r = [];
            // Primary columns
            pHeaders.forEach((_, j) => r.push(row[j] ?? ''));
            // Fill secondary columns with blanks
            sHeaders.forEach(() => r.push(''));
            // Append group label if exists
            const g = groupMapPrimary[idx];
            r.push(g ? `Group ${g}` : '');
            combinedRows.push(r);
          });
        }
        if (Array.isArray(STATE.secondaryRows)) {
          STATE.secondaryRows.forEach((row, idx) => {
            const r = [];
            // Fill primary columns with blanks
            pHeaders.forEach(() => r.push(''));
            // Secondary columns
            sHeaders.forEach((_, j) => r.push(row[j] ?? ''));
            // Append group label if exists
            const g = groupMapSecondary[idx];
            r.push(g ? `Group ${g}` : '');
            combinedRows.push(r);
          });
        }
        // Generate CSV and trigger download
        const csv = toCSV(combinedRows, combinedHeaders);
        // Build a safe file name
        const nameA = (STATE.primaryName || 'primary').replace(/[\\/:*?"<>|]+/g, '_');
        const nameB = (STATE.secondaryName || 'secondary').replace(/[\\/:*?"<>|]+/g, '_');
        download(`fuzzy_duplicates_${nameA}_vs_${nameB}.csv`, csv);
        toast('Cross‑file duplicates exported', 'ok');
      }
      /*
        ====================================================================
        Cross‑file Fuzzy Duplicate Detection
        ---------------------------------------------------------------------
        Provides an interface to compare values from a column in the primary
        dataset against values from a column in a secondary dataset.  Uses
        simple blocking on the first character and approximate length to
        dramatically reduce comparisons, and caps comparisons at
        200,000 to avoid freezing the UI.  Results are displayed in
        #fuzzyCrossResults.  UI controls are populated via
        initFuzzyCrossUI().
      */

      /**
       * Initialise the cross‑file fuzzy UI.  Populate the two selects with
       * columns from the primary and secondary datasets.  The secondary
       * select is disabled if no secondary dataset is available.  Should
       * be called whenever primary or secondary datasets are updated.
       */
      function initFuzzyCrossUI() {
        const aSel = el('#fuzzyACol');
        const bSel = el('#fuzzyBCol');
        if (!aSel || !bSel) return;
        // Clear existing options
        aSel.innerHTML = '';
        bSel.innerHTML = '';
        // Determine primary dataset headers.  Use snapshots when available
        const pHeaders = (Array.isArray(STATE.primaryHeaders) && STATE.primaryHeaders.length) ? STATE.primaryHeaders : STATE.headers;
        const sHeaders = (Array.isArray(STATE.secondaryHeaders) && STATE.secondaryHeaders.length) ? STATE.secondaryHeaders : [];
        // Populate primary column selector.  Use header names both as the
        // visible label and as the option value.  Using names instead of
        // numeric indices avoids situations where the first option appears
        // as “0” (the index) in some browsers.  Later, when comparing
        // values across datasets, we map these names back to indices.
        if (!pHeaders || !pHeaders.length) {
          const opt = document.createElement('option');
          opt.value = '';
          opt.textContent = 'No primary dataset';
          aSel.appendChild(opt);
        } else {
          pHeaders.forEach((h) => {
            const opt = document.createElement('option');
            opt.value = h;
            opt.textContent = h;
            // Readable styling
            opt.style.color = '#000';
            opt.style.backgroundColor = '#fff';
            aSel.appendChild(opt);
          });
        }
        // Populate secondary column selector.  Similarly, use names as
        // both label and value.  Disable the select if no secondary
        // dataset exists.
        if (!sHeaders || !sHeaders.length) {
          const opt = document.createElement('option');
          opt.value = '';
          opt.textContent = 'Secondary (none)';
          bSel.appendChild(opt);
          bSel.disabled = true;
        } else {
          bSel.disabled = false;
          sHeaders.forEach((h) => {
            const opt = document.createElement('option');
            opt.value = h;
            opt.textContent = h;
            opt.style.color = '#000';
            opt.style.backgroundColor = '#fff';
            bSel.appendChild(opt);
          });
        }
        // Apply styling to selects themselves
        aSel.style.color = '#000';
        aSel.style.backgroundColor = '#fff';
        bSel.style.color = '#000';
        bSel.style.backgroundColor = '#fff';
        // Reset results area
        const res = el('#fuzzyCrossResults');
        if (res) res.innerHTML = '';
      }

      /**
       * Return the headers and rows representing the primary dataset.  If
       * primary snapshots exist, use them; otherwise fall back to current
       * STATE.headers and STATE.rows.  This helper ensures cross‑file fuzzy
       * always compares against the original primary dataset even when the
       * user is viewing the secondary dataset.
       */
      function getActivePrimaryArrays() {
        const headers = (Array.isArray(STATE.primaryHeaders) && STATE.primaryHeaders.length) ? STATE.primaryHeaders : STATE.headers;
        const rows    = (Array.isArray(STATE.primaryRows)    && STATE.primaryRows.length)    ? STATE.primaryRows    : STATE.rows;
        return { headers, rows };
      }

      /**
       * Find approximate matches between values from a column in the primary
       * dataset and a column in the secondary dataset.  Performs simple
       * blocking to reduce comparisons and caps the number of comparisons
       * to FUZZY_CROSS_MAX_COMP.  Returns an object with match details
       * or error information.
       *
       * @param {string} colA Index of column in primary dataset (string number)
       * @param {string} colB Index of column in secondary dataset (string number)
       * @param {number} threshold Minimum similarity ratio [0,1]
       */
      function findFuzzyCross(colA, colB, threshold) {
        const { headers: pHdrs, rows: pRows } = getActivePrimaryArrays();
        const sHdrs = (Array.isArray(STATE.secondaryHeaders) && STATE.secondaryHeaders.length) ? STATE.secondaryHeaders : [];
        const sRows = (Array.isArray(STATE.secondaryRows)    && STATE.secondaryRows.length)    ? STATE.secondaryRows    : [];
        if (!pHdrs || !pHdrs.length || !sHdrs || !sHdrs.length) {
          return { error: 'Load both datasets first.' };
        }
        // Columns may be passed as header names (strings) or numeric indices.
        // Try to parse as integers; if NaN, look up the header name in the
        // appropriate header arrays.  If no valid index is found, signal
        // an error.
        let ia = parseInt(colA, 10);
        let ib = parseInt(colB, 10);
        if (isNaN(ia)) ia = pHdrs.indexOf(colA);
        if (isNaN(ib)) ib = sHdrs.indexOf(colB);
        if (ia < 0 || ia >= pHdrs.length || ib < 0 || ib >= sHdrs.length) {
          return { error: 'Pick valid columns.' };
        }
        // Extract non-null values with index
        const norm = s => String(s).trim().toLowerCase();
        const take = (rows, idx) => rows.map((r,i) => ({ idx: i, s: (r[idx] ?? '') })).filter(o => !isNullish(o.s) && o.s.trim());
        const A = take(pRows, ia);
        const B = take(sRows, ib);
        // Simple blocking by first char and length bucket
        const bucket = s => `${s[0] || '#'}:${Math.round(s.length / 3)}`;
        const mapB = new Map();
        for (const o of B) {
          const key = bucket(norm(o.s));
          if (!mapB.has(key)) mapB.set(key, []);
          mapB.get(key).push(o);
        }
        // No arbitrary comparison limit - process all cross-file matches
        const pairs = [];
        let comps = 0;
        // Check if we're comparing the same dataset with itself
        const isSelfComparison = A.length === B.length && A.every((a, idx) => B[idx] && a.s === B[idx].s);
        
        // Warn about self-comparison which can produce excessive results
        if (isSelfComparison && A.length > 1000) {
          console.warn(`Cross-file comparison: Comparing file with itself (${A.length} rows). Consider using Single-File Duplicates instead for better performance.`);
        }
        
        for (const a of A) {
          const s = norm(a.s);
          const bcands = mapB.get(bucket(s)) || [];
          for (const b of bcands) {
            comps++;
            
            // Skip self-matches when comparing file with itself
            if (isSelfComparison && a.idx === b.idx) {
              continue;
            }
            
            if (similarity(s, norm(b.s)) >= threshold) {
              pairs.push({ a: a.idx, b: b.idx, aval: a.s, bval: b.s });
            }
          }
        }
        // Sort by value then row index
        pairs.sort((x, y) => {
          if (x.aval === y.aval) return x.a - y.a;
          return x.aval.localeCompare(y.aval);
        });
        return { pairs, compared: comps, aRows: A.length, bRows: B.length };
      }

      /**
       * Render the results of a cross‑file fuzzy match.  Displays a summary
       * and up to the first 50 matches with row indices and values.
       *
       * @param {object} res The result object from findFuzzyCross()
       * @param {string|number} colA Selected column index in primary dataset
       * @param {string|number} colB Selected column index in secondary dataset
       * @param {string|number} thr Display threshold for label
       */
      function renderFuzzyCross(res, colA, colB, thr) {
        const out = el('#fuzzyCrossResults');
        if (!out) return;
        out.innerHTML = '';
        if (res.error) {
          out.textContent = res.error;
          return;
        }
        if (res.tooMany) {
          out.textContent = `Too many comparisons (${res.tooMany.toLocaleString()}). Narrow your columns or raise the threshold.`;
          return;
        }
        if (!res.pairs || res.pairs.length === 0) {
          out.textContent = 'No cross‑file approximate matches found.';
          return;
        }
        const max = 50;
        const header = document.createElement('div');
        header.className = 'small muted';
        header.textContent = `Matches: ${res.pairs.length} (threshold ${thr}, compared ~${res.compared.toLocaleString()} pairs). Showing first ${Math.min(max, res.pairs.length)}.`;
        out.appendChild(header);
        res.pairs.slice(0, max).forEach((p, i) => {
          const div = document.createElement('div');
          div.style.marginTop = '8px';
          const label = `#${i + 1} A(row ${p.a + 2}) "${p.aval}" ↔ B(row ${p.b + 2}) "${p.bval}"`;
          div.textContent = label;
          out.appendChild(div);
        });
      }


      // Render fuzzy duplicate results

      // Update threshold label on change
      const fuzzyThresholdInput = el('#fuzzyThreshold');
      if (fuzzyThresholdInput) {
        fuzzyThresholdInput.addEventListener('input', e => {
          const val = e.target.value;
          const label = el('#fuzzyThresholdLabel');
          if (label) label.textContent = val;
        });
      }
      // Run fuzzy duplicates detection
      /* single-file fuzzy removed for MVP */

      // Run cross-file fuzzy matching.  Compares a column from the primary
      // dataset against a column from the secondary dataset using the
      // threshold slider.  Requires a secondary dataset to be loaded.
      
      const fuzzyRunCrossBtn = el('#fuzzyRunCross');
      if (fuzzyRunCrossBtn) {
        fuzzyRunCrossBtn.addEventListener('click', () => {
          if (!STATE.secondaryHeaders || !STATE.secondaryHeaders.length) {
            const out = el('#fuzzyCrossResults');
            if (out) out.textContent = 'Load a secondary dataset (Merge Files) first.';
            toast('Load a secondary dataset first', 'error');
            return;
          }
          const aSel = el('#fuzzyACol');
          const bSel = el('#fuzzyBCol');
          const colA = aSel ? aSel.value : '';
          const colB = bSel ? bSel.value : '';
          if (!colA || !colB) {
            const out = el('#fuzzyCrossResults');
            if (out) out.textContent = 'Pick columns to compare.';
            toast('Pick columns to compare', 'info');
            return;
          }
          const thrVal = el('#fuzzyThreshold') ? el('#fuzzyThreshold').value : '0.85';
          const thr = parseFloat(thrVal);
          const result = findFuzzyCross(colA, colB, thr);
          if (result.error) {
            toast(result.error, 'error');
          } else if (result.tooMany) {
            toast(`Too many comparisons (${result.tooMany.toLocaleString()}). Raise the threshold or narrow your columns.`, 'error');
          } else if (!result.pairs || result.pairs.length === 0) {
            toast('No cross‑file matches at this threshold', 'info');
          }
          renderFuzzyCross(result, colA, colB, thr.toFixed(2));
        });
      }


      /*
        =====================================================================
        Data Operations
        ---------------------------------------------------------------------
        Provides simple, bulk operations to clean data and assist with key
        analysis. Users can trim and collapse whitespace, normalize the case
        of textual fields (title‑case names, uppercase IDs, lower‑case
        emails), and remove accents or non‑printable characters. A unique
        key assistant scans the dataset for columns that uniquely identify
        each row, suggesting candidates for External IDs, and can append
        a surrogate ID column when none exists. After applying operations,
        the dataset is reprofiled and the cleaned data can be downloaded.
      */
      // Populate the operations column selector
      function initOperationsUI() {
        const sel = el('#opColumns');
        if (!sel) return;
        sel.innerHTML = '';
        if (!STATE.headers.length) {
          const opt = document.createElement('option');
          opt.value = '';
          opt.textContent = 'No dataset';
          sel.appendChild(opt);
          el('#opApply').disabled = true;
          el('#quickDownloadCSV').disabled = true;
          el('#quickDownloadJSON').disabled = true;
          el('#quickAnalyzeKeys').disabled = true;
          el('#quickAddId').disabled = true;
          return;
        }
        // Populate options for all headers; preselect string columns by default
        STATE.headers.forEach((name, idx) => {
          const opt = document.createElement('option');
          opt.value = String(idx);
          opt.textContent = name;
          // Ensure readability (white background, black text)
          opt.style.color = '#000';
          opt.style.backgroundColor = '#fff';
          // Auto-select string columns
          const type = STATE.profiles && STATE.profiles[idx] ? STATE.profiles[idx].type : 'string';
          if (type === 'string') opt.selected = true;
          sel.appendChild(opt);
        });
        // Apply legible colours to select itself
        sel.style.color = '#000';
        sel.style.backgroundColor = '#fff';
        // Enable operation buttons
        el('#opApply').disabled = false;
        el('#quickAnalyzeKeys').disabled = false;
        el('#quickAddId').disabled = false;
        // Enable download buttons when data is loaded
        el('#quickDownloadCSV').disabled = false;
        el('#quickDownloadJSON').disabled = false;
        // Clear previous key results
        const res = el('#opKeyResults');
        if (res) res.textContent = '';
      }

      // Helper: Normalize case based on column name heuristics
      function normalizeCaseByColumn(name, val) {
        if (val == null) return val;
        const str = String(val);
        const lowerName = String(name || '').toLowerCase();
        // ID or key fields: uppercase everything
        if (/(id|key)/.test(lowerName)) {
          return str.toUpperCase();
        }
        // Email fields: lowercase
        if (/email/.test(lowerName)) {
          return str.toLowerCase();
        }
        // Name fields: title case (capitalize first letter of each word)
        if (/name/.test(lowerName)) {
          return str.split(/\s+/).map(w => w.charAt(0).toUpperCase() + w.slice(1).toLowerCase()).join(' ');
        }
        // Default: leave unchanged
        return str;
      }

      // Apply selected data operations to chosen columns
      function applyDataOperations() {
        let indices, doTrim, doNorm, doClean, doSf; // Declare variables in outer scope
        
        try {
          // Validate state first
          if (!STATE.headers || STATE.headers.length === 0) {
            showRulesStatus('Please load a dataset first','error');
            return;
          }
          
          if (!STATE.rows || STATE.rows.length === 0) {
            showRulesStatus('No data rows to process','error');
            return;
          }
          
          const sel = el('#opColumns');
          if (!sel) {
            showRulesStatus('Column selector not found','error');
            return;
          }
          
          indices = Array.from(sel.selectedOptions || []).map(opt => parseInt(opt.value, 10)).filter(i => !isNaN(i));
          if (!indices.length) {
            showRulesStatus('No columns selected','error');
            return;
          }
          
          // Validate selected indices are within bounds
          const invalidIndices = indices.filter(i => i < 0 || i >= STATE.headers.length);
          if (invalidIndices.length > 0) {
            showRulesStatus('Invalid column selection detected','error');
            return;
          }
          
          // Get operation flags with null checks
          const trimEl = el('#opTrim');
          const normEl = el('#opNormalize');
          const cleanEl = el('#opClean');
          const sfEl = el('#opSfConvert');
          
          doTrim = trimEl ? trimEl.checked : false;
          doNorm = normEl ? normEl.checked : false;
          doClean = cleanEl ? cleanEl.checked : false;
          doSf = sfEl ? sfEl.checked : false;
          
          if (!doTrim && !doNorm && !doClean && !doSf) {
            showRulesStatus('No operations selected','error');
            return;
          }
          
          // Check for memory constraints with large datasets
          const totalCells = STATE.rows.length * STATE.headers.length;
          if (totalCells > 1000000) { // 1M cells threshold
            const proceed = confirm(`Large dataset detected (${totalCells.toLocaleString()} cells). This operation may take time. Continue?`);
            if (!proceed) {
              showRulesStatus('Operation cancelled by user', 'info');
              return;
            }
          }
        } catch (error) {
          console.error('Validation error in applyDataOperations:', error);
          showRulesStatus('Error validating operation: ' + error.message, 'error');
          return;
        }
        
        try {
          // Create description for undo/redo
          const operations = [];
          if (doTrim) operations.push('trim');
          if (doNorm) operations.push('normalize case');
          if (doClean) operations.push('remove accents');
          if (doSf) operations.push('convert SF IDs');
          const columnNames = indices.map(i => STATE.headers[i]).join(', ');
          const description = `Apply ${operations.join(', ')} to columns: ${columnNames}`;
          
          // Execute the operation using the undo/redo system
          const command = new DataOperationCommand(
            description,
            doSf ? [...STATE.headers, ...indices.map(i => `${STATE.headers[i]}_18char`)] : STATE.headers,
            null, // Will be computed in the operation
            el('#datasetName')?.textContent || 'Dataset'
          );
          
          // Override the execute method to perform the actual data operations
          command.execute = async function() {
            try {
              const result = await performDataOperations(indices, doTrim, doNorm, doClean, doSf);
              
              // Validate result before proceeding
              if (!result || !result.headers || !result.rows) {
                throw new Error('Invalid operation result');
              }
              
              // Update the after-state with the actual results
              this.afterState.headers = result.headers;
              this.afterState.rows = result.rows;
              this.afterState.name = result.name;
              
              // Apply the result to the UI
              await computeAndRender(result.headers, result.rows, result.name);
              snapshotActiveDataset(result.name);
              updateDatasetSwitchUI();
              
              // Show change summary
              showOperationSummary(result.changeCounts, indices, result.sfConversionStats, result.patternFixes);
              showRulesStatus('Operations applied','ok');
              
              // Add SF conversion toast if applicable
              if (result.sfConversionStats && result.sfConversionStats.totalValidIds > 0) {
                toast(`SF ID Conversion: ${result.sfConversionStats.totalValidIds} IDs converted in ${result.sfConversionStats.columnsWithValidIds} column(s)`, 'ok');
              } else if (result.sfConversionStats && result.sfConversionStats.totalColumns > 0) {
                toast('SF ID Conversion: No valid 15-digit Salesforce IDs found in selected columns', 'error');
              }
              
              return result;
            } catch (error) {
              console.error('Error executing data operation command:', error);
              showRulesStatus('Error during operation: ' + error.message, 'error');
              throw error; // Re-throw for undo/redo system handling
            }
          };
          
          undoRedoManager.execute(command);
          
        } catch (error) {
          console.error('Error setting up data operation:', error);
          showRulesStatus('Error preparing operation: ' + error.message, 'error');
        }
      }
      
      // Extracted the actual data operations logic
      async function performDataOperations(indices, doTrim, doNorm, doClean, doSf) {
        // Keep a copy of the current rows so we can measure what changes
        // actually occur.  Without saving the old state, we cannot report
        // how many values were altered by trimming, case normalisation or
        // accent removal.  Use a shallow clone for each row since we only
        // mutate cell values, not nested structures.
        const oldRows = STATE.rows.map(row => row.slice());
        // Copy rows and apply transformations.  We'll record how many
        // replacements happen per column after modifications are complete.
        let newRows = STATE.rows.map(row => row.slice());
        // Prepare change counters for each selected column.  We'll tally the
        // number of cells that actually changed value after cleaning.
        const changeCounts = {};
        const patternFixes = {}; // Track pattern-based fixes separately
        indices.forEach(j => {
          changeCounts[j] = 0;
          patternFixes[j] = 0;
        });
        for (let r=0; r<newRows.length; r++) {
          const row = newRows[r];
          indices.forEach(j => {
            let val = row[j];
            if (val == null) return;
            let s = String(val);
            // Apply trimming: remove leading/trailing whitespace and collapse
            // multiple whitespace characters into a single space.
            if (doTrim) {
              s = s.trim().replace(/\s+/g, ' ');
            }
            // Remove accents and diacritics and strip non-printable chars
            if (doClean) {
              s = s.normalize('NFD').replace(/[\u0300-\u036f]/g, '');
              s = s.replace(/[\x00-\x1F\x7F]/g, '');
            }
            // Normalise case according to heuristics (ID upper, email lower, names title case)
            if (doNorm) {
              s = normalizeCaseByColumn(STATE.headers[j], s);
            }
            
            // Apply smart pattern-based corrections
            if (STATE.profiles && STATE.profiles[j] && STATE.profiles[j].patterns) {
              const patterns = STATE.profiles[j].patterns;
              if (patterns.length > 0) {
                const topPattern = patterns[0];
                // Only auto-fix if we have reasonable confidence or fixability
                if (topPattern.confidence > DATAPHREAK_CONFIG.PATTERN_CONFIDENCE_THRESHOLD || topPattern.fixable > DATAPHREAK_CONFIG.PATTERN_FIXABLE_THRESHOLD) {
                  const pattern = PATTERN_LIBRARY[topPattern.id];
                  
                  // Apply standardization fix regardless of validation (for consistent formatting)
                  if (pattern) {
                    try {
                      const fixed = pattern.fix(s);
                      if (fixed !== s) {
                        s = fixed;
                        patternFixes[j]++; // Count this pattern fix
                      }
                    } catch (e) {
                      // Ignore pattern fix errors - keep original value
                    }
                  }
                }
              }
            }
            
            // Record a change if the cleaned value differs from the old one
            if (String(oldRows[r][j] ?? '') !== s) {
              changeCounts[j]++;
            }
            row[j] = s;
          });
        }
        // If Salesforce ID conversion is selected, append new columns with 18‑character IDs for each selected column.
        let newHeaders = STATE.headers.slice();
        let sfConversionStats = { totalColumns: 0, columnsWithValidIds: 0, totalValidIds: 0, totalRows: 0 };
        
        if (doSf) {
          sfConversionStats.totalColumns = indices.length;
          sfConversionStats.totalRows = newRows.length;
          
          indices.forEach(j => {
            const baseName = STATE.headers[j] || `Column${j}`;
            let validIdsInColumn = 0;
            let potentialIdsInColumn = 0;
            
            // First pass: count valid IDs and potential IDs in this column
            // Use ORIGINAL values (before case normalization) to properly detect Salesforce IDs
            for (let r = 0; r < newRows.length; r++) {
              const originalVal = oldRows[r][j]; // Use original value before any transformations
              if (originalVal) {
                const strVal = String(originalVal).trim();
                if (strVal.length === 15) {
                  potentialIdsInColumn++;
                  if (isValidSalesforceId15(strVal)) {
                    validIdsInColumn++;
                  }
                } else if (strVal.length === 18) {
                  // Check if this might already be an 18-digit ID
                  potentialIdsInColumn++;
                }
              }
            }
            
            // Only create a new column if we found valid 15-digit IDs
            if (validIdsInColumn > 0) {
              sfConversionStats.columnsWithValidIds++;
              sfConversionStats.totalValidIds += validIdsInColumn;
              
              // Determine a unique header name for the new ID column
              let newName = `${baseName}_18char`;
              let suffix = 2;
              while (newHeaders.includes(newName)) {
                newName = `${baseName}_18char_${suffix++}`;
              }
              newHeaders.push(newName);
              
              // Second pass: convert the IDs using ORIGINAL values
              for (let r = 0; r < newRows.length; r++) {
                const originalVal = oldRows[r][j]; // Use original value before transformations
                const id18 = originalVal ? to18CharId(String(originalVal)) : '';
                newRows[r].push(id18);
              }
            } else {
              // Warn about this column having no valid IDs
              if (potentialIdsInColumn > 0) {
                showRulesStatus(`Column "${baseName}": Found ${potentialIdsInColumn} potential IDs but none were valid 15-digit Salesforce IDs. May contain 18-digit IDs or invalid formats.`, 'error');
              } else {
                showRulesStatus(`Column "${baseName}": No Salesforce IDs found to convert.`, 'error');
              }
            }
          });
        }
        // Persist the cleaned rows back onto STATE.rows *before* re-profiling.
        // This ensures exports, merges and any subsequent operations always
        // operate on the updated data rather than the original input.  When
        // computeAndRender() runs it will overwrite STATE.rows again with
        // whatever is passed into it.  Assigning here guarantees that
        // STATE.rows and newRows remain in sync.
        STATE.rows = newRows;

        // Mark the dataset name as cleaned.  If it doesn’t already include
        // "(cleaned)", append it so users can easily see the data has been
        // transformed.  We derive the current name from the UI pill rather
        // than STATE to ensure we reflect the latest label displayed.
        const currentName = el('#datasetName').textContent || 'dataset';
        let newName = currentName;
        if (!/\(cleaned\)/.test(currentName)) {
          newName = `${currentName} (cleaned)`;
        }

        // Reprofile and rerender the dataset using the cleaned rows.  If Salesforce ID
        // conversion added extra columns, use the updated headers array; otherwise
        // reuse the existing headers.  computeAndRender will assign STATE.headers
        // and STATE.rows internally.  This effectively replaces the in-memory
        // dataset with its cleaned counterpart across the entire application.
        const finalHeaders = (doSf ? newHeaders : STATE.headers);
        // Return the cleaned data for the undo/redo system
        const result = {
          headers: finalHeaders,
          rows: newRows,
          name: newName,
          changeCounts: changeCounts,
          patternFixes: patternFixes,
          sfConversionStats: doSf ? sfConversionStats : null
        };
        
        // Enable the "Download Cleaned Data" buttons
        el('#quickDownloadCSV').disabled = false;
        el('#quickDownloadJSON').disabled = false;
        
        return result;
      }
      
      // Helper function to show operation summary
      function showOperationSummary(changeCounts, indices, sfConversionStats = null, patternFixes = null) {
        const summaryEl = el('#opChangeSummary');
        const resultsEl = el('#opResults');
        if (summaryEl && resultsEl) {
          resultsEl.style.display = 'block'; // Show results container
          const parts = [];
          let totalChanges = 0;
          let totalPatternFixes = 0;
          
          for (const j of indices) {
            const count = changeCounts[j] || 0;
            const patterns = patternFixes ? (patternFixes[j] || 0) : 0;
            totalChanges += count;
            totalPatternFixes += patterns;
            const colName = STATE.headers[j] || `Column ${j}`;
            
            if (count > 0 || patterns > 0) {
              let detail = `${colName}: ${count}`;
              if (patterns > 0) {
                detail += ` (${patterns} pattern fixes)`;
              }
              parts.push(detail);
            }
          }
          
          let summaryText = '';
          if (totalChanges > 0 || totalPatternFixes > 0) {
            summaryText = `Cleaned values – ${parts.join(', ')}`;
            if (totalPatternFixes > 0) {
              summaryText += ` | 🎯 Smart patterns applied: ${totalPatternFixes} auto-corrections`;
            }
          } else {
            summaryText = 'Selected columns were already clean; no changes made.';
          }
          
          // Add SF conversion summary if applicable
          if (sfConversionStats && sfConversionStats.totalColumns > 0) {
            if (sfConversionStats.totalValidIds > 0) {
              summaryText += ` | SF IDs: ${sfConversionStats.totalValidIds} converted in ${sfConversionStats.columnsWithValidIds}/${sfConversionStats.totalColumns} column(s)`;
            } else {
              summaryText += ` | SF IDs: No valid 15-digit IDs found in ${sfConversionStats.totalColumns} column(s)`;
            }
          }
          
          summaryEl.textContent = summaryText;
        }
      }

      // Download the cleaned dataset as CSV
      function downloadCleanedDataCSV() {
        if (!STATE.headers.length || !STATE.rows.length) return;
        const name = (el('#datasetName').textContent || 'dataset').replace(/[\s\uD83C-\uDBFF\uDC00-\uDFFF]+/g, '_');
        const csv = toCSV(STATE.rows, STATE.headers);
        download(`${name}.csv`, csv);
      }

      // Download the cleaned dataset as JSON
      function downloadCleanedDataJSON() {
        if (!STATE.headers.length || !STATE.rows.length) return;
        const name = (el('#datasetName').textContent || 'dataset').replace(/[\s\uD83C-\uDBFF\uDC00-\uDFFF]+/g, '_');
        
        // Convert rows to array of objects with headers as keys
        const jsonData = STATE.rows.map(row => {
          const obj = {};
          STATE.headers.forEach((header, index) => {
            obj[header] = row[index] || null;
          });
          return obj;
        });
        
        const json = JSON.stringify(jsonData, null, 2);
        download(`${name}.json`, json);
      }

      // Analyse columns for uniqueness to suggest keys/external IDs
      function analyseUniqueKeys() {
        if (!STATE.headers.length) {
          showRulesStatus('Please load a dataset first','error');
          return;
        }
        const nrows = STATE.rows.length;
        const suggestions = [];
        // Single column analysis
        STATE.headers.forEach((name, idx) => {
          let nonNull = 0;
          const uniq = new Set();
          for (let i=0; i<nrows; i++) {
            const v = STATE.rows[i][idx];
            if (!isNullish(v)) {
              nonNull++;
              uniq.add(String(v));
            }
          }
          if (nonNull === nrows && uniq.size === nrows) {
            suggestions.push({ cols: [name], type: 'single' });
          }
        });
        // If no single column qualifies, check pairs (only top few to avoid heavy computation)
        if (suggestions.length === 0) {
          const maxPairs = 3;
          outer: for (let i=0; i<STATE.headers.length; i++) {
            for (let j=i+1; j<STATE.headers.length; j++) {
              let nonNull = 0;
              const uniq = new Set();
              for (let r=0; r<nrows; r++) {
                const a = STATE.rows[r][i];
                const b = STATE.rows[r][j];
                if (!isNullish(a) && !isNullish(b)) {
                  nonNull++;
                  uniq.add(String(a) + '|' + String(b));
                }
              }
              if (nonNull === nrows && uniq.size === nrows) {
                suggestions.push({ cols: [STATE.headers[i], STATE.headers[j]], type: 'pair' });
                if (suggestions.length >= maxPairs) break outer;
              }
            }
          }
        }
        const out = el('#opKeyResults');
        const resultsEl = el('#opResults');
        if (resultsEl) resultsEl.style.display = 'block'; // Show results container
        out.innerHTML = '';
        if (suggestions.length === 0) {
          out.textContent = 'No unique single or two‑column keys were found in this dataset.';
        } else {
          const ul = document.createElement('ul');
          suggestions.forEach(sugg => {
            const li = document.createElement('li');
            if (sugg.type === 'single') {
              li.innerHTML = `<strong>${escapeHtml(sugg.cols[0])}</strong> uniquely identifies all rows.`;
            } else {
              li.innerHTML = `<strong>${escapeHtml(sugg.cols[0])}</strong> + <strong>${escapeHtml(sugg.cols[1])}</strong> together uniquely identify all rows.`;
            }
            ul.appendChild(li);
          });
          out.appendChild(ul);
        }
      }

      // Generate a surrogate ID column and download the dataset
      function generateSurrogateId() {
        if (!STATE.headers.length || !STATE.rows.length) {
          showRulesStatus('Please load a dataset first','error');
          return;
        }
        // Determine a unique column name for the surrogate ID
        const base = 'surrogate_id';
        let newName = base;
        let suffix = 1;
        while (STATE.headers.includes(newName)) {
          newName = `${base}_${suffix++}`;
        }
        // Build new headers and rows
        const newHeaders = [...STATE.headers, newName];
        const newRows = STATE.rows.map((row, i) => {
          const id = 'S' + String(i+1).padStart(6, '0');
          return [...row, id];
        });
        const filename = (el('#datasetName').textContent || 'dataset').replace(/[\s\uD83C-\uDBFF\uDC00-\uDFFF]+/g, '_');
        download(`${filename}_with_surrogate.csv`, toCSV(newRows, newHeaders));
        showRulesStatus('File with surrogate ID downloaded','ok');
      }

      // Generate histogram visualizations for all columns
      function generateHistograms() {
        const container = el('#histogramContainer');
        if (!container || !STATE.headers.length || !STATE.rows.length) return;

        // Show loading animation
        container.innerHTML = '<div class="histogram-loading" style="text-align: center; padding: 40px; color: var(--muted); font-size: 14px;">📊 Generating histograms...</div>';
        container.classList.add('histogram-loading');
        
        // Use setTimeout to show loading animation briefly
        setTimeout(() => {
          container.classList.remove('histogram-loading');
          container.innerHTML = ''; // Clear loading content
        
        STATE.headers.forEach((header, colIndex) => {
          const columnData = STATE.rows.map(row => row[colIndex]).filter(val => !isNullish(val));
          if (columnData.length === 0) return;

          const profile = STATE.profiles[colIndex];
          if (!profile) return;

          const histogramDiv = document.createElement('div');
          histogramDiv.className = 'histogram-item';
          histogramDiv.style.cssText = 'margin-bottom: 24px; padding: 16px; border: 1px solid var(--border); border-radius: 8px; background: var(--panel); max-width: 1300px; width: 95%; display: flex; flex-direction: column; align-items: center;';
          
          const title = document.createElement('h4');
          title.textContent = `${header} (${profile.type})`;
          title.style.cssText = 'margin: 0 0 12px 0; color: var(--accent); font-size: 16px;';
          
          const svg = createHistogramSVG(columnData, profile.type, header);
          
          histogramDiv.appendChild(title);
          histogramDiv.appendChild(svg);
          container.appendChild(histogramDiv);
        });
        
        }, 300); // 300ms loading delay for smooth UX
      }

      // Create SVG histogram for a column
      function createHistogramSVG(data, dataType, columnName) {
        // Responsive sizing: min 580px, max 1160px (2x), scale with container
        const baseWidth = 580;
        const maxWidth = 1160;
        const containerWidth = Math.min(maxWidth, Math.max(baseWidth, window.innerWidth * 0.8));
        const width = containerWidth;
        const height = Math.round(width * 0.31); // Maintain aspect ratio
        
        const margin = { top: 20, right: 20, bottom: 40, left: 50 };
        const chartWidth = width - margin.left - margin.right;
        const chartHeight = height - margin.top - margin.bottom;

        const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
        svg.setAttribute('width', '100%');
        svg.setAttribute('height', height);
        svg.setAttribute('viewBox', `0 0 ${width} ${height}`);
        svg.style.cssText = 'background: var(--card-bg); border-radius: 4px; max-width: 1160px; min-width: 580px;';

        // Create defs for gradients and patterns
        const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
        
        // Create multiple gradient definitions for different intensity levels
        const gradientId = Math.random().toString(36).substr(2, 9);
        
        // High frequency gradient (red)
        const highGradient = document.createElementNS('http://www.w3.org/2000/svg', 'linearGradient');
        highGradient.setAttribute('id', `highGrad_${gradientId}`);
        highGradient.setAttribute('x1', '0%');
        highGradient.setAttribute('y1', '100%');
        highGradient.setAttribute('x2', '0%');
        highGradient.setAttribute('y2', '0%');
        
        let stop1 = document.createElementNS('http://www.w3.org/2000/svg', 'stop');
        stop1.setAttribute('offset', '0%');
        stop1.setAttribute('stop-color', '#dc2626');
        stop1.setAttribute('stop-opacity', '0.7');
        
        let stop2 = document.createElementNS('http://www.w3.org/2000/svg', 'stop');
        stop2.setAttribute('offset', '100%');
        stop2.setAttribute('stop-color', '#f87171');
        stop2.setAttribute('stop-opacity', '0.9');
        
        highGradient.appendChild(stop1);
        highGradient.appendChild(stop2);
        defs.appendChild(highGradient);
        
        // Medium-high frequency gradient (orange)
        const medHighGradient = document.createElementNS('http://www.w3.org/2000/svg', 'linearGradient');
        medHighGradient.setAttribute('id', `medHighGrad_${gradientId}`);
        medHighGradient.setAttribute('x1', '0%');
        medHighGradient.setAttribute('y1', '100%');
        medHighGradient.setAttribute('x2', '0%');
        medHighGradient.setAttribute('y2', '0%');
        
        stop1 = document.createElementNS('http://www.w3.org/2000/svg', 'stop');
        stop1.setAttribute('offset', '0%');
        stop1.setAttribute('stop-color', '#ea580c');
        stop1.setAttribute('stop-opacity', '0.7');
        
        stop2 = document.createElementNS('http://www.w3.org/2000/svg', 'stop');
        stop2.setAttribute('offset', '100%');
        stop2.setAttribute('stop-color', '#fb923c');
        stop2.setAttribute('stop-opacity', '0.9');
        
        medHighGradient.appendChild(stop1);
        medHighGradient.appendChild(stop2);
        defs.appendChild(medHighGradient);
        
        // Medium frequency gradient (yellow)
        const medGradient = document.createElementNS('http://www.w3.org/2000/svg', 'linearGradient');
        medGradient.setAttribute('id', `medGrad_${gradientId}`);
        medGradient.setAttribute('x1', '0%');
        medGradient.setAttribute('y1', '100%');
        medGradient.setAttribute('x2', '0%');
        medGradient.setAttribute('y2', '0%');
        
        stop1 = document.createElementNS('http://www.w3.org/2000/svg', 'stop');
        stop1.setAttribute('offset', '0%');
        stop1.setAttribute('stop-color', '#ca8a04');
        stop1.setAttribute('stop-opacity', '0.7');
        
        stop2 = document.createElementNS('http://www.w3.org/2000/svg', 'stop');
        stop2.setAttribute('offset', '100%');
        stop2.setAttribute('stop-color', '#fbbf24');
        stop2.setAttribute('stop-opacity', '0.9');
        
        medGradient.appendChild(stop1);
        medGradient.appendChild(stop2);
        defs.appendChild(medGradient);
        
        // Low-medium frequency gradient (green)
        const lowMedGradient = document.createElementNS('http://www.w3.org/2000/svg', 'linearGradient');
        lowMedGradient.setAttribute('id', `lowMedGrad_${gradientId}`);
        lowMedGradient.setAttribute('x1', '0%');
        lowMedGradient.setAttribute('y1', '100%');
        lowMedGradient.setAttribute('x2', '0%');
        lowMedGradient.setAttribute('y2', '0%');
        
        stop1 = document.createElementNS('http://www.w3.org/2000/svg', 'stop');
        stop1.setAttribute('offset', '0%');
        stop1.setAttribute('stop-color', '#16a34a');
        stop1.setAttribute('stop-opacity', '0.7');
        
        stop2 = document.createElementNS('http://www.w3.org/2000/svg', 'stop');
        stop2.setAttribute('offset', '100%');
        stop2.setAttribute('stop-color', '#4ade80');
        stop2.setAttribute('stop-opacity', '0.9');
        
        lowMedGradient.appendChild(stop1);
        lowMedGradient.appendChild(stop2);
        defs.appendChild(lowMedGradient);
        
        // Low frequency gradient (blue)
        const lowGradient = document.createElementNS('http://www.w3.org/2000/svg', 'linearGradient');
        lowGradient.setAttribute('id', `lowGrad_${gradientId}`);
        lowGradient.setAttribute('x1', '0%');
        lowGradient.setAttribute('y1', '100%');
        lowGradient.setAttribute('x2', '0%');
        lowGradient.setAttribute('y2', '0%');
        
        stop1 = document.createElementNS('http://www.w3.org/2000/svg', 'stop');
        stop1.setAttribute('offset', '0%');
        stop1.setAttribute('stop-color', '#0891b2');
        stop1.setAttribute('stop-opacity', '0.7');
        
        stop2 = document.createElementNS('http://www.w3.org/2000/svg', 'stop');
        stop2.setAttribute('offset', '100%');
        stop2.setAttribute('stop-color', '#38bdf8');
        stop2.setAttribute('stop-opacity', '0.9');
        
        lowGradient.appendChild(stop1);
        lowGradient.appendChild(stop2);
        defs.appendChild(lowGradient);
        
        // Horizontal gradients for categorical data
        const highHGradient = document.createElementNS('http://www.w3.org/2000/svg', 'linearGradient');
        highHGradient.setAttribute('id', `highHGrad_${gradientId}`);
        highHGradient.setAttribute('x1', '0%');
        highHGradient.setAttribute('y1', '0%');
        highHGradient.setAttribute('x2', '100%');
        highHGradient.setAttribute('y2', '0%');
        
        stop1 = document.createElementNS('http://www.w3.org/2000/svg', 'stop');
        stop1.setAttribute('offset', '0%');
        stop1.setAttribute('stop-color', '#dc2626');
        stop1.setAttribute('stop-opacity', '0.8');
        
        stop2 = document.createElementNS('http://www.w3.org/2000/svg', 'stop');
        stop2.setAttribute('offset', '100%');
        stop2.setAttribute('stop-color', '#f87171');
        stop2.setAttribute('stop-opacity', '0.9');
        
        highHGradient.appendChild(stop1);
        highHGradient.appendChild(stop2);
        defs.appendChild(highHGradient);
        
        const medHGradient = document.createElementNS('http://www.w3.org/2000/svg', 'linearGradient');
        medHGradient.setAttribute('id', `medHGrad_${gradientId}`);
        medHGradient.setAttribute('x1', '0%');
        medHGradient.setAttribute('y1', '0%');
        medHGradient.setAttribute('x2', '100%');
        medHGradient.setAttribute('y2', '0%');
        
        stop1 = document.createElementNS('http://www.w3.org/2000/svg', 'stop');
        stop1.setAttribute('offset', '0%');
        stop1.setAttribute('stop-color', '#ea580c');
        stop1.setAttribute('stop-opacity', '0.8');
        
        stop2 = document.createElementNS('http://www.w3.org/2000/svg', 'stop');
        stop2.setAttribute('offset', '100%');
        stop2.setAttribute('stop-color', '#fb923c');
        stop2.setAttribute('stop-opacity', '0.9');
        
        medHGradient.appendChild(stop1);
        medHGradient.appendChild(stop2);
        defs.appendChild(medHGradient);
        
        const lowHGradient = document.createElementNS('http://www.w3.org/2000/svg', 'linearGradient');
        lowHGradient.setAttribute('id', `lowHGrad_${gradientId}`);
        lowHGradient.setAttribute('x1', '0%');
        lowHGradient.setAttribute('y1', '0%');
        lowHGradient.setAttribute('x2', '100%');
        lowHGradient.setAttribute('y2', '0%');
        
        stop1 = document.createElementNS('http://www.w3.org/2000/svg', 'stop');
        stop1.setAttribute('offset', '0%');
        stop1.setAttribute('stop-color', '#0891b2');
        stop1.setAttribute('stop-opacity', '0.8');
        
        stop2 = document.createElementNS('http://www.w3.org/2000/svg', 'stop');
        stop2.setAttribute('offset', '100%');
        stop2.setAttribute('stop-color', '#38bdf8');
        stop2.setAttribute('stop-opacity', '0.9');
        
        lowHGradient.appendChild(stop1);
        lowHGradient.appendChild(stop2);
        defs.appendChild(lowHGradient);
        
        svg.appendChild(defs);

        if (dataType === 'number') {
          const numericData = data.map(d => asNumberStrict(d)).filter(Number.isFinite);
          if (numericData.length === 0) return svg;

          const min = Math.min(...numericData);
          const max = Math.max(...numericData);
          
          // Better binning for age data - use reasonable age ranges
          let binCount, binWidth, bins;
          
          if (max - min <= 100 && min >= 0 && max <= 150) {
            // Likely age data - use 5-year age groups
            binCount = Math.max(5, Math.min(20, Math.ceil((max - min) / 5)));
            binWidth = (max - min) / binCount;
            
            bins = Array.from({length: binCount}, (_, i) => {
              const binMin = min + i * binWidth;
              const binMax = i === binCount - 1 ? max : min + (i + 1) * binWidth;
              return {
                min: binMin,
                max: binMax,
                count: 0,
                label: `${Math.round(binMin)}-${Math.round(binMax)}`
              };
            });
          } else {
            // General numeric data
            binCount = Math.min(20, Math.ceil(Math.sqrt(numericData.length)));
            binWidth = (max - min) / binCount;
            
            bins = Array.from({length: binCount}, (_, i) => {
              const binMin = min + i * binWidth;
              const binMax = i === binCount - 1 ? max : min + (i + 1) * binWidth;
              return {
                min: binMin,
                max: binMax,
                count: 0,
                label: `${fmtNum(binMin)}-${fmtNum(binMax)}`
              };
            });
          }

          numericData.forEach(value => {
            // Handle edge case where value equals max
            let binIndex = Math.floor((value - min) / binWidth);
            binIndex = Math.min(binIndex, binCount - 1);
            binIndex = Math.max(0, binIndex);
            bins[binIndex].count++;
          });

          const maxCount = Math.max(...bins.map(b => b.count));
          const xScale = chartWidth / binCount;
          const yScale = chartHeight / maxCount;

          // Add Y-axis grid lines and labels
          const yAxisTicks = 5;
          const yStep = maxCount / yAxisTicks;
          for (let i = 0; i <= yAxisTicks; i++) {
            const yValue = Math.round(i * yStep);
            const yPos = margin.top + chartHeight - (yValue * yScale);
            
            // Grid line
            const gridLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            gridLine.setAttribute('x1', margin.left);
            gridLine.setAttribute('y1', yPos);
            gridLine.setAttribute('x2', margin.left + chartWidth);
            gridLine.setAttribute('y2', yPos);
            gridLine.setAttribute('stroke', 'var(--border)');
            gridLine.setAttribute('stroke-width', i === 0 ? '1.5' : '0.5');
            gridLine.setAttribute('opacity', '0.6');
            svg.appendChild(gridLine);
            
            // Y-axis label
            if (yValue > 0 || i === 0) {
              const yLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
              yLabel.setAttribute('x', margin.left - 8);
              yLabel.setAttribute('y', yPos + 4);
              yLabel.setAttribute('text-anchor', 'end');
              yLabel.setAttribute('fill', 'var(--muted)');
              yLabel.setAttribute('font-size', '10');
              yLabel.textContent = yValue;
              svg.appendChild(yLabel);
            }
          }

          // Y-axis line
          const yAxis = document.createElementNS('http://www.w3.org/2000/svg', 'line');
          yAxis.setAttribute('x1', margin.left);
          yAxis.setAttribute('y1', margin.top);
          yAxis.setAttribute('x2', margin.left);
          yAxis.setAttribute('y2', margin.top + chartHeight);
          yAxis.setAttribute('stroke', 'var(--text)');
          yAxis.setAttribute('stroke-width', '1');
          svg.appendChild(yAxis);

          // Draw bars
          bins.forEach((bin, i) => {
            if (bin.count === 0) return;
            
            const barX = margin.left + i * xScale;
            const barY = margin.top + chartHeight - bin.count * yScale;
            const barWidth = Math.max(1, xScale - 1);
            const barHeight = bin.count * yScale;
            
            const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            rect.setAttribute('x', barX);
            rect.setAttribute('y', barY);
            rect.setAttribute('width', barWidth);
            rect.setAttribute('height', barHeight);
            // Gradient color coding based on frequency
            const intensity = bin.count / maxCount;
            let gradientUrl;
            if (intensity > 0.8) {
              gradientUrl = `url(#highGrad_${gradientId})`;
            } else if (intensity > 0.6) {
              gradientUrl = `url(#medHighGrad_${gradientId})`;
            } else if (intensity > 0.4) {
              gradientUrl = `url(#medGrad_${gradientId})`;
            } else if (intensity > 0.2) {
              gradientUrl = `url(#lowMedGrad_${gradientId})`;
            } else {
              gradientUrl = `url(#lowGrad_${gradientId})`;
            }
            rect.setAttribute('fill', gradientUrl);
            rect.setAttribute('opacity', '1');
            rect.setAttribute('cursor', 'pointer');
            
            // Add smooth slide-up animation to bars
            const animateHeight = document.createElementNS('http://www.w3.org/2000/svg', 'animate');
            animateHeight.setAttribute('attributeName', 'height');
            animateHeight.setAttribute('from', '0');
            animateHeight.setAttribute('to', barHeight);
            animateHeight.setAttribute('dur', `${0.8 + i * 0.05}s`);
            animateHeight.setAttribute('fill', 'freeze');
            animateHeight.setAttribute('begin', `${i * 0.1}s`);
            rect.appendChild(animateHeight);
            
            const animateY = document.createElementNS('http://www.w3.org/2000/svg', 'animate');
            animateY.setAttribute('attributeName', 'y');
            animateY.setAttribute('from', margin.top + chartHeight);
            animateY.setAttribute('to', barY);
            animateY.setAttribute('dur', `${0.8 + i * 0.05}s`);
            animateY.setAttribute('fill', 'freeze');
            animateY.setAttribute('begin', `${i * 0.1}s`);
            rect.appendChild(animateY);
            
            rect.setAttribute('data-count', bin.count);
            rect.setAttribute('data-range-min', fmtNum(bin.min));
            rect.setAttribute('data-range-max', fmtNum(bin.max));
            
            // Add hover effects
            rect.addEventListener('mouseenter', (e) => showTooltip(e, {
              type: 'numeric',
              count: bin.count,
              rangeLabel: bin.label || `${fmtNum(bin.min)}-${fmtNum(bin.max)}`,
              rangeMin: fmtNum(bin.min),
              rangeMax: fmtNum(bin.max),
              percentage: ((bin.count / numericData.length) * 100).toFixed(1)
            }));
            rect.addEventListener('mouseleave', hideTooltip);
            rect.addEventListener('mouseover', (e) => rect.setAttribute('opacity', '0.9'));
            rect.addEventListener('mouseout', (e) => rect.setAttribute('opacity', '0.7'));
            
            svg.appendChild(rect);

            // Add count label on top of bar
            if (barHeight > 15) { // Only show label if bar is tall enough
              const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
              label.setAttribute('x', barX + barWidth / 2);
              label.setAttribute('y', barY - 5);
              label.setAttribute('text-anchor', 'middle');
              label.setAttribute('fill', 'var(--text)');
              label.setAttribute('font-size', Math.min(12, Math.max(8, barWidth / 4)));
              label.setAttribute('font-weight', '600');
              label.textContent = bin.count;
              svg.appendChild(label);
            }
          });

          // Add statistical overlay lines (mean, median)
          const mean = numericData.reduce((sum, val) => sum + val, 0) / numericData.length;
          const sortedData = [...numericData].sort((a, b) => a - b);
          const median = sortedData.length % 2 === 0 
            ? (sortedData[sortedData.length / 2 - 1] + sortedData[sortedData.length / 2]) / 2
            : sortedData[Math.floor(sortedData.length / 2)];

          // Mean line (green)
          const meanX = margin.left + ((mean - min) / (max - min)) * chartWidth;
          if (meanX >= margin.left && meanX <= margin.left + chartWidth) {
            const meanLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            meanLine.setAttribute('x1', meanX);
            meanLine.setAttribute('y1', margin.top);
            meanLine.setAttribute('x2', meanX);
            meanLine.setAttribute('y2', margin.top + chartHeight);
            meanLine.setAttribute('stroke', '#10b981');
            meanLine.setAttribute('stroke-width', '2');
            meanLine.setAttribute('stroke-dasharray', '5,3');
            meanLine.setAttribute('opacity', '0.8');
            svg.appendChild(meanLine);
            
            // Mean label
            const meanLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            meanLabel.setAttribute('x', meanX + 5);
            meanLabel.setAttribute('y', margin.top + 15);
            meanLabel.setAttribute('fill', '#10b981');
            meanLabel.setAttribute('font-size', '10');
            meanLabel.setAttribute('font-weight', '600');
            meanLabel.textContent = `μ=${fmtNum(mean)}`;
            svg.appendChild(meanLabel);
          }

          // Median line (blue)
          const medianX = margin.left + ((median - min) / (max - min)) * chartWidth;
          if (medianX >= margin.left && medianX <= margin.left + chartWidth) {
            const medianLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            medianLine.setAttribute('x1', medianX);
            medianLine.setAttribute('y1', margin.top);
            medianLine.setAttribute('x2', medianX);
            medianLine.setAttribute('y2', margin.top + chartHeight);
            medianLine.setAttribute('stroke', '#3b82f6');
            medianLine.setAttribute('stroke-width', '2');
            medianLine.setAttribute('stroke-dasharray', '3,2');
            medianLine.setAttribute('opacity', '0.8');
            svg.appendChild(medianLine);
            
            // Median label
            const medianLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            medianLabel.setAttribute('x', medianX + 5);
            medianLabel.setAttribute('y', margin.top + 30);
            medianLabel.setAttribute('fill', '#3b82f6');
            medianLabel.setAttribute('font-size', '10');
            medianLabel.setAttribute('font-weight', '600');
            medianLabel.textContent = `M=${fmtNum(median)}`;
            svg.appendChild(medianLabel);
          }

          // Add X-axis labels for bins  
          const showXLabels = binCount <= 15; // Only show if not too crowded
          if (showXLabels) {
            bins.forEach((bin, i) => {
              if (i % Math.ceil(binCount / 8) === 0 || i === binCount - 1) { // Show every nth label
                const xPos = margin.left + (i + 0.5) * xScale;
                const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                label.setAttribute('x', xPos);
                label.setAttribute('y', height - 20);
                label.setAttribute('text-anchor', 'middle');
                label.setAttribute('fill', 'var(--muted)');
                label.setAttribute('font-size', '9');
                label.textContent = bin.label || `${Math.round(bin.min)}`;
                svg.appendChild(label);
              }
            });
          }

          // Add overall range label
          const xAxis = document.createElementNS('http://www.w3.org/2000/svg', 'text');
          xAxis.setAttribute('x', width / 2);
          xAxis.setAttribute('y', height - 5);
          xAxis.setAttribute('text-anchor', 'middle');
          xAxis.setAttribute('fill', 'var(--muted)');
          xAxis.setAttribute('font-size', '12');
          xAxis.textContent = `Range: ${fmtNum(min)} to ${fmtNum(max)}`;
          svg.appendChild(xAxis);

        } else if (dataType === 'string') {
          // For categorical data, show top values
          const valueCounts = {};
          data.forEach(val => {
            const str = String(val);
            valueCounts[str] = (valueCounts[str] || 0) + 1;
          });

          const sortedEntries = Object.entries(valueCounts)
            .sort(([,a], [,b]) => b - a)
            .slice(0, 10); // Top 10 values

          const maxCount = sortedEntries.length > 0 ? sortedEntries[0][1] : 1;
          const barHeight = chartHeight / Math.max(1, sortedEntries.length);
          const xScale = chartWidth / maxCount;

          // Add X-axis grid lines for categorical data
          const xAxisTicks = Math.min(5, maxCount);
          const xStep = maxCount / xAxisTicks;
          for (let i = 0; i <= xAxisTicks; i++) {
            const xValue = Math.round(i * xStep);
            const xPos = margin.left + (xValue * xScale);
            
            // Vertical grid line
            const gridLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            gridLine.setAttribute('x1', xPos);
            gridLine.setAttribute('y1', margin.top);
            gridLine.setAttribute('x2', xPos);
            gridLine.setAttribute('y2', margin.top + chartHeight);
            gridLine.setAttribute('stroke', 'var(--border)');
            gridLine.setAttribute('stroke-width', i === 0 ? '1.5' : '0.5');
            gridLine.setAttribute('opacity', '0.6');
            svg.appendChild(gridLine);
            
            // X-axis label
            if (xValue > 0 || i === 0) {
              const xLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
              xLabel.setAttribute('x', xPos);
              xLabel.setAttribute('y', margin.top + chartHeight + 15);
              xLabel.setAttribute('text-anchor', 'middle');
              xLabel.setAttribute('fill', 'var(--muted)');
              xLabel.setAttribute('font-size', '10');
              xLabel.textContent = xValue;
              svg.appendChild(xLabel);
            }
          }

          sortedEntries.forEach(([value, count], i) => {
            const barWidth = count * xScale;
            const barY = margin.top + i * barHeight;
            const barHeightActual = Math.max(1, barHeight - 1);
            
            const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            rect.setAttribute('x', margin.left);
            rect.setAttribute('y', barY);
            rect.setAttribute('width', barWidth);
            rect.setAttribute('height', barHeightActual);
            // Gradient color coding based on frequency rank
            let gradientUrl;
            if (i === 0) {
              gradientUrl = `url(#highHGrad_${gradientId})`; // Highest frequency
            } else if (i <= 2) {
              gradientUrl = `url(#medHGrad_${gradientId})`; // Top 3
            } else {
              gradientUrl = `url(#lowHGrad_${gradientId})`; // Lower frequency
            }
            rect.setAttribute('fill', gradientUrl);
            rect.setAttribute('opacity', '1');
            rect.setAttribute('cursor', 'pointer');
            
            // Add smooth slide-in animation to categorical bars
            const animateWidth = document.createElementNS('http://www.w3.org/2000/svg', 'animate');
            animateWidth.setAttribute('attributeName', 'width');
            animateWidth.setAttribute('from', '0');
            animateWidth.setAttribute('to', barWidth);
            animateWidth.setAttribute('dur', `${0.6 + i * 0.1}s`);
            animateWidth.setAttribute('fill', 'freeze');
            animateWidth.setAttribute('begin', `${i * 0.15}s`);
            rect.appendChild(animateWidth);
            
            // Add hover effects for categorical bars
            rect.addEventListener('mouseenter', (e) => showTooltip(e, {
              type: 'categorical',
              value: value,
              count: count,
              percentage: ((count / data.length) * 100).toFixed(1)
            }));
            rect.addEventListener('mouseleave', hideTooltip);
            rect.addEventListener('mouseover', (e) => rect.setAttribute('opacity', '0.9'));
            rect.addEventListener('mouseout', (e) => rect.setAttribute('opacity', '0.7'));
            
            svg.appendChild(rect);

            // Add count label inside bar if wide enough, otherwise outside
            const countLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            const labelX = barWidth > 40 ? margin.left + barWidth - 5 : margin.left + barWidth + 3;
            const labelAnchor = barWidth > 40 ? 'end' : 'start';
            const labelColor = barWidth > 40 ? 'white' : 'var(--text)';
            
            countLabel.setAttribute('x', labelX);
            countLabel.setAttribute('y', barY + barHeightActual / 2 + 3);
            countLabel.setAttribute('text-anchor', labelAnchor);
            countLabel.setAttribute('fill', labelColor);
            countLabel.setAttribute('font-size', '11');
            countLabel.setAttribute('font-weight', '600');
            countLabel.textContent = count;
            svg.appendChild(countLabel);

            // Add value label
            const valueLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            const valueLabelX = barWidth > 100 ? margin.left + 5 : margin.left + barWidth + 25;
            const valueLabelColor = barWidth > 100 ? 'white' : 'var(--text)';
            
            valueLabel.setAttribute('x', valueLabelX);
            valueLabel.setAttribute('y', barY + barHeightActual / 2 + 3);
            valueLabel.setAttribute('fill', valueLabelColor);
            valueLabel.setAttribute('font-size', '10');
            valueLabel.textContent = `${value.slice(0, 15)}${value.length > 15 ? '...' : ''}`;
            svg.appendChild(valueLabel);
          });
        }

        return svg;
      }

      // Tooltip functions for histogram interactivity
      function showTooltip(event, data) {
        const tooltip = el('#histogramTooltip');
        if (!tooltip) return;
        
        let content = '';
        if (data.type === 'numeric') {
          content = `
            <div style="font-weight: 600; color: var(--accent); margin-bottom: 4px;">Numeric Range</div>
            <div>Range: ${data.rangeLabel || data.rangeMin + ' - ' + data.rangeMax}</div>
            <div>Count: ${data.count} (${data.percentage}%)</div>
          `;
        } else if (data.type === 'categorical') {
          content = `
            <div style="font-weight: 600; color: var(--accent2); margin-bottom: 4px;">Category</div>
            <div>Value: "${data.value}"</div>
            <div>Count: ${data.count} (${data.percentage}%)</div>
          `;
        }
        
        tooltip.innerHTML = content;
        tooltip.style.opacity = '1';
        
        // Position tooltip near mouse
        const rect = tooltip.parentElement.getBoundingClientRect();
        const x = event.clientX - rect.left + 10;
        const y = event.clientY - rect.top - 10;
        tooltip.style.left = `${x}px`;
        tooltip.style.top = `${y}px`;
      }

      function hideTooltip() {
        const tooltip = el('#histogramTooltip');
        if (tooltip) tooltip.style.opacity = '0';
      }

      // Print histograms with pleasant formatting
      function printHistogramsPage() {
        const printWindow = window.open('', '_blank');
        if (!printWindow) return;

        const container = el('#histogramContainer');
        if (!container) return;

        printWindow.document.write(`
          <!DOCTYPE html>
          <html>
          <head>
            <title>DATAPHREAK - Data Distribution Histograms</title>
            <style>
              @media print {
                body { margin: 0.5in; font-family: system-ui, sans-serif; }
                h1 { color: #22c55e; border-bottom: 2px solid #22c55e; padding-bottom: 8px; }
                h4 { color: #38bdf8; margin-top: 24px; }
                .histogram-item { page-break-inside: avoid; margin-bottom: 20px; }
                svg { max-width: 100%; }
              }
            </style>
          </head>
          <body>
            <h1>📊 DATAPHREAK - Data Distribution Histograms</h1>
            <p>Generated on: ${new Date().toLocaleString()}</p>
            <p>Dataset: ${el('#datasetName')?.textContent || 'Unknown'}</p>
            ${container.innerHTML}
          </body>
          </html>
        `);
        
        printWindow.document.close();
        setTimeout(() => {
          printWindow.print();
          printWindow.close();
        }, 500);
      }

      // Attach event listeners for operations
      const opApplyBtn = el('#opApply');
      if (opApplyBtn) opApplyBtn.addEventListener('click', applyDataOperations);
      
      // Quick Action button event listeners
      const quickDownloadCSVBtn = el('#quickDownloadCSV');
      if (quickDownloadCSVBtn) quickDownloadCSVBtn.addEventListener('click', downloadCleanedDataCSV);
      const quickDownloadJSONBtn = el('#quickDownloadJSON');
      if (quickDownloadJSONBtn) quickDownloadJSONBtn.addEventListener('click', downloadCleanedDataJSON);
      const quickAnalyzeBtn = el('#quickAnalyzeKeys');
      if (quickAnalyzeBtn) quickAnalyzeBtn.addEventListener('click', analyseUniqueKeys);
      const quickAddIdBtn = el('#quickAddId');
      if (quickAddIdBtn) quickAddIdBtn.addEventListener('click', generateSurrogateId);
      
      // Quick Actions event listeners
      const quickCleanAllBtn = el('#quickCleanAll');
      if (quickCleanAllBtn) quickCleanAllBtn.addEventListener('click', () => {
        debugLog('quickCleanAll', 'Button clicked');
        try {
          // Validate state before proceeding
          debugLog('quickCleanAll', 'Validating state', {
            hasHeaders: !!STATE.headers,
            headerCount: STATE.headers?.length || 0,
            hasRows: !!STATE.rows,
            rowCount: STATE.rows?.length || 0
          });
          
          if (!STATE.headers || STATE.headers.length === 0) {
            debugLog('quickCleanAll', 'No headers found');
            showRulesStatus('Please load data first', 'error');
            return;
          }
          
          if (!STATE.rows || STATE.rows.length === 0) {
            debugLog('quickCleanAll', 'No rows found');
            showRulesStatus('No data rows to clean', 'error');
            return;
          }
          
          // Check if another operation is in progress
          if (quickCleanAllBtn.disabled) {
            showRulesStatus('Operation already in progress', 'error');
            return;
          }
          
          // Disable button to prevent multiple clicks
          quickCleanAllBtn.disabled = true;
          quickCleanAllBtn.textContent = '🔄 Cleaning...';
          
          // Select all fields and enable all cleaning operations
          const columns = el('#opColumns');
          if (!columns) {
            throw new Error('Column selector not found');
          }
          
          if (columns.options.length === 0) {
            throw new Error('No columns available for cleaning');
          }
          
          // Select all options
          for (let i = 0; i < columns.options.length; i++) {
            columns.options[i].selected = true;
          }
          
          // Enable cleaning checkboxes with validation
          const trim = el('#opTrim'); 
          const norm = el('#opNormalize'); 
          const clean = el('#opClean');
          
          if (trim) trim.checked = true;
          if (norm) norm.checked = true;
          if (clean) clean.checked = true;
          // Don't auto-enable SF conversion as it adds columns
          
          // Apply operations with timeout for large datasets
          debugLog('quickCleanAll', 'Starting data operations');
          setTimeout(() => {
            try {
              applyDataOperations();
              debugLog('quickCleanAll', 'Data operations completed successfully');
              showRulesStatus('Data cleaning completed successfully', 'ok');
            } catch (error) {
              debugError('quickCleanAll', error, 'During data operations');
              showRulesStatus('Error during cleaning: ' + error.message, 'error');
            } finally {
              // Re-enable button
              quickCleanAllBtn.disabled = false;
              quickCleanAllBtn.textContent = '🧹 Clean All';
              debugLog('quickCleanAll', 'Button re-enabled');
            }
          }, 100);
          
        } catch (error) {
          debugError('quickCleanAll', error, 'Setting up clean operation');
          showRulesStatus('Error preparing clean operation: ' + error.message, 'error');
          // Re-enable button on error
          quickCleanAllBtn.disabled = false;
          quickCleanAllBtn.textContent = '🧹 Clean All';
        }
      });
      
      // Note: quickAnalyzeKeys handler is now defined above in the main operations section
      
      const quickPrepareBtn = el('#quickPrepare');
      if (quickPrepareBtn) quickPrepareBtn.addEventListener('click', async () => {
        try {
          if (STATE.headers.length === 0) {
            showRulesStatus('Please load data first', 'error');
            return;
          }
          
          // First clean all data
          const columns = el('#opColumns');
          if (columns && columns.options.length > 0) {
            // Select all options
            for (let i = 0; i < columns.options.length; i++) {
              columns.options[i].selected = true;
            }
            // Enable cleaning checkboxes
            const trim = el('#opTrim'); if (trim) trim.checked = true;
            const norm = el('#opNormalize'); if (norm) norm.checked = true;
            const clean = el('#opClean'); if (clean) clean.checked = true;
            
            // Apply cleaning
            applyDataOperations();
            
            // Then analyze keys after a short delay
            setTimeout(() => {
              try {
                analyseUniqueKeys();
                showRulesStatus('Data prepared: cleaned and key analysis complete!', 'ok');
              } catch (error) {
                showRulesStatus('Error during key analysis: ' + error.message, 'error');
              }
            }, 1000);
          }
        } catch (error) {
          showRulesStatus('Error during data preparation: ' + error.message, 'error');
        }
      });

      const quickExportSummaryBtn = el('#quickExportSummary');
      if (quickExportSummaryBtn) quickExportSummaryBtn.addEventListener('click', () => {
        if (STATE.headers.length === 0) {
          showRulesStatus('Please load data first', 'error');
          return;
        }
        
        // Export data dictionary
        exportDataDict(STATE.headers, STATE.profiles, STATE.rules, STATE.ruleResults);
        toast('Data dictionary exported', 'ok');
      });

    })();

    // Collapsible panels: attach click handlers to chevron toggles. When a
    // toggle is clicked, the nearest card is collapsed/expanded by toggling
    // the `collapsed` class. Collapsed cards hide their contents except for
    // the heading, and the chevron rotates.
    (function() {
      // Helper function to check if clicked element is interactive (avoid code duplication)
      function isInteractiveElement(target) {
        return target.tagName === 'BUTTON' || 
               target.tagName === 'A' || 
               target.tagName === 'SELECT' ||
               target.tagName === 'INPUT' ||
               target.closest('button') ||
               target.closest('a') ||
               target.closest('select') ||
               target.closest('input') ||
               target.closest('h2'); // Let h2 handler deal with h2 clicks
      }
      
      function initCollapsibles() {
        // Attach click handler to each chevron toggle. Clicking the chevron
        // will collapse or expand the card.
        document.querySelectorAll('.collapse-toggle').forEach(tog => {
          tog.addEventListener('click', ev => {
            ev.preventDefault();
            ev.stopPropagation(); // Prevent event bubbling
            const card = tog.closest('.card');
            if (card) {
              card.classList.toggle('collapsed');
            }
          });
        });
        
        // Also attach click handler to the entire heading (h2) that contains
        // a collapse toggle. This makes the whole header bar clickable,
        // improving usability when the chevron is small. Handle both direct h2
        // children and h2 elements inside .card-header divs.
        document.querySelectorAll('.card h2').forEach(h => {
          const toggle = h.querySelector('.collapse-toggle');
          if (toggle) {
            h.style.cursor = 'pointer';
            h.addEventListener('click', ev => {
              // Prevent collapse when clicking on interactive elements
              const target = ev.target;
              const isInteractive = target.tagName === 'BUTTON' || 
                                   target.tagName === 'A' || 
                                   target.tagName === 'SELECT' ||
                                   target.tagName === 'INPUT' ||
                                   target.closest('button') ||
                                   target.closest('a') ||
                                   target.closest('select') ||
                                   target.closest('input') ||
                                   target.closest('.field-btn') ||
                                   target.closest('.card-header button');
              
              if (isInteractive) {
                return; // Don't collapse when clicking interactive elements
              }
              
              ev.preventDefault();
              ev.stopPropagation();
              const card = h.closest('.card');
              if (card) {
                card.classList.toggle('collapsed');
              }
            });
          }
        });
        
        // Also make .card-header divs clickable (but not their buttons or selects)
        document.querySelectorAll('.card-header').forEach(header => {
          const toggle = header.querySelector('.collapse-toggle');
          if (toggle) {
            header.style.cursor = 'pointer';
            header.addEventListener('click', ev => {
              const target = ev.target;
              
              // Prevent collapse when clicking on interactive elements
              if (isInteractiveElement(target)) {
                return; // Don't collapse when clicking interactive elements
              }
              
              ev.preventDefault();
              ev.stopPropagation();
              const card = header.closest('.card');
              if (card) {
                card.classList.toggle('collapsed');
              }
            });
          }
        });
        
        // Also make .section-header divs clickable (fix for Data Overview and Data Quality)
        document.querySelectorAll('.section-header').forEach(header => {
          const toggle = header.querySelector('.collapse-toggle');
          if (toggle) {
            header.style.cursor = 'pointer';
            header.addEventListener('click', ev => {
              const target = ev.target;
              
              // Prevent collapse when clicking on interactive elements
              if (isInteractiveElement(target)) {
                return; // Don't collapse when clicking interactive elements
              }
              
              ev.preventDefault();
              ev.stopPropagation();
              const card = header.closest('.card');
              if (card) {
                card.classList.toggle('collapsed');
              }
            });
          }
        });
      }
      
      // Run immediately after the DOM elements are defined. Because this
      // script appears at the end of the document, the DOM is ready.
      initCollapsibles();
      
    })();
  </script>

  <!-- Toast notification container. This hidden element will hold brief
       messages for errors and confirmations. Using aria-live ensures
       that screen readers announce the contents when new toasts are
       added. -->
  <div id="toast" aria-live="polite" class="small" style="position:fixed;right:16px;bottom:16px;max-width:360px;z-index:300"></div>
</body>
</html>